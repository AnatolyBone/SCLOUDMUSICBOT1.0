// lib/TaskQueue.js

export class TaskQueue {
    constructor(options = {}) {
        this.maxConcurrent = options.maxConcurrent || 1;
        this.taskProcessor = options.taskProcessor;
        if (typeof this.taskProcessor !== 'function') {
            throw new Error('Task processor function is required');
        }
        this.queue = [];
        this.active = 0;
    }

    add(task) {
        this.queue.push(task);
        this.processNext();
    }

    async processNext() {
        if (this.active >= this.maxConcurrent || this.queue.length === 0) {
            return;
        }

        const task = this.queue.shift();
        this.active++;
        
        console.log(`[TaskQueue] –ó–∞–ø—É—Å–∫–∞—é –∑–∞–¥–∞—á—É. –ê–∫—Ç–∏–≤–Ω–æ: ${this.active}, –í –æ—á–µ—Ä–µ–¥–∏: ${this.size}`);

        try {
            await this.taskProcessor(task);
        } catch (err) {
            console.error('üî¥ [TaskQueue] –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –Ω–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –≤ task processor:', err);
        } finally {
            this.active--;
            console.log(`[TaskQueue] –ó–∞–¥–∞—á–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –ê–∫—Ç–∏–≤–Ω–æ: ${this.active}`);
            this.processNext();
        }
    }

    get size() {
        return this.queue.length;
    }

    get activeTasks() {
        return this.active;
    }
}