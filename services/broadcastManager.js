// services/broadcastManager.js

import { ADMIN_ID } from '../config.js';
import { getAlreadySentUserIds, logBroadcastSent, updateUserField } from '../db.js';
import { isDownloadQueueActive } from './downloadManager.js';
import { isShuttingDown } from './appState.js';

/**
 * –í—ã–ø–æ–ª–Ω—è–µ—Ç –æ–¥–∏–Ω "—Å–ø—Ä–∏–Ω—Ç" —Ä–∞—Å—Å—ã–ª–∫–∏, —Ä–∞–±–æ—Ç–∞—è –ø–æ—Ä—Ü–∏—è–º–∏ –∏ —Å –ª–∏–º–∏—Ç–æ–º –ø–æ –≤—Ä–µ–º–µ–Ω–∏.
 * @returns {Promise<{completed: boolean, report: object}>} - –û—Ç—á–µ—Ç –æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –∏ —Ñ–ª–∞–≥, –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –ª–∏ —Ä–∞—Å—Å—ã–ª–∫–∞ –ø–æ–ª–Ω–æ—Å—Ç—å—é.
 */
export async function runSingleBroadcast(bot, task, users, taskId = null) {
    const TIME_LIMIT_MS = 50000; // –†–∞–±–æ—Ç–∞—Ç—å –Ω–µ –¥–æ–ª—å—à–µ 50 —Å–µ–∫—É–Ω–¥ –∑–∞ –æ–¥–∏–Ω –∑–∞–ø—É—Å–∫
    const isPreview = !taskId;
    const startTime = Date.now();

    const alreadySentIds = isPreview ? new Set() : await getAlreadySentUserIds(taskId);
    const usersToSend = users.filter(user => !alreadySentIds.has(user.id));

    if (usersToSend.length === 0 && users.length > 0 && !isPreview) {
        return { completed: true, report: { successCount: users.length, errorCount: 0, totalUsers: users.length } };
    }
    
    console.log(`[Broadcast Worker] –°–ø—Ä–∏–Ω—Ç –¥–ª—è #${taskId}. –ö –æ—Ç–ø—Ä–∞–≤–∫–µ: ${usersToSend.length} –∏–∑ ${users.length}.`);

    let successCount = 0;
    let errorCount = 0;

    for (const user of usersToSend) {
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ ‚Ññ1: –°–∏–≥–Ω–∞–ª –Ω–∞ –æ–±—â–µ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã
        if (isShuttingDown) {
            console.log(`[Broadcast Worker] –ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª shutdown. –ü—Ä–µ—Ä—ã–≤–∞—é —Ä–∞—Å—Å—ã–ª–∫—É #${taskId}.`);
            break;
        }
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ ‚Ññ2: –£—Å—Ç—É–ø–∞–µ–º –¥–æ—Ä–æ–≥—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–º –∑–∞–¥–∞—á–∞–º
        if (!isPreview && isDownloadQueueActive()) {
            console.log(`[Broadcast Worker] –û—á–µ—Ä–µ–¥—å —Å–∫–∞—á–∏–≤–∞–Ω–∏—è —Å—Ç–∞–ª–∞ –∞–∫—Ç–∏–≤–Ω–æ–π. –†–∞—Å—Å—ã–ª–∫–∞ #${taskId} –ø—Ä–∏–æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞.`);
            break;
        }
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ ‚Ññ3: –ó–∞—â–∏—Ç–∞ –æ—Ç —Å–ª–∏—à–∫–æ–º –¥–æ–ª–≥–æ–π —Ä–∞–±–æ—Ç—ã
        if (Date.now() - startTime > TIME_LIMIT_MS) {
            console.log(`[Broadcast Worker] –î–æ—Å—Ç–∏–≥–Ω—É—Ç –ª–∏–º–∏—Ç –≤—Ä–µ–º–µ–Ω–∏. –†–∞—Å—Å—ã–ª–∫–∞ #${taskId} –±—É–¥–µ—Ç –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∞ –ø–æ–∑–∂–µ.`);
            break;
        }

        try {
            const personalMessage = (task.message || '').replace(/{first_name}/g, user.first_name || '–¥–æ—Ä–æ–≥–æ–π –¥—Ä—É–≥');
            const options = { parse_mode: 'HTML', disable_web_page_preview: task.disable_web_page_preview, disable_notification: task.disable_notification };
            if (task.keyboard?.length > 0) options.reply_markup = { inline_keyboard: task.keyboard };
            
            const fileId = task.file_id;
            if (fileId) {
                if (personalMessage) options.caption = personalMessage;
                const mimeType = task.file_mime_type || '';
                if (mimeType.startsWith('image/')) await bot.telegram.sendPhoto(user.id, fileId, options);
                else if (mimeType.startsWith('video/')) await bot.telegram.sendVideo(user.id, fileId, options);
                else if (mimeType.startsWith('audio/')) await bot.telegram.sendAudio(user.id, fileId, options);
                else await bot.telegram.sendDocument(user.id, fileId, options);
            } else if (personalMessage) {
                await bot.telegram.sendMessage(user.id, personalMessage, options);
            }
            
            if (!isPreview) await logBroadcastSent(taskId, user.id);
            successCount++;
        } catch (e) {
            errorCount++;
            if (e.response?.error_code === 403) await updateUserField(user.id, 'active', false);
        }
        
        await new Promise(resolve => setTimeout(resolve, 40)); // –ë–∞–∑–æ–≤–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ ~25 msg/sec
    }
    
    const totalSuccess = successCount + alreadySentIds.size;
    const report = { successCount: totalSuccess, errorCount, totalUsers: users.length };
    const completed = totalSuccess >= users.length; // –°—á–∏—Ç–∞–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–Ω–æ–π, –µ—Å–ª–∏ –≤—Å–µ –ø–æ–ª—É—á–∏–ª–∏

    if (isPreview) {
        console.log(`[Broadcast Worker] –ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –∑–∞–≤–µ—Ä—à–µ–Ω.`, { successCount, errorCount });
    } else {
        console.log(`[Broadcast Worker] –°–ø—Ä–∏–Ω—Ç #${taskId} –∑–∞–≤–µ—Ä—à–µ–Ω. –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ —ç—Ç–æ–π —Å–µ—Å—Å–∏–∏: ${successCount}. –û–±—â–∏–π –ø—Ä–æ–≥—Ä–µ—Å—Å: ${totalSuccess}/${users.length}`);
    }
    
    if (completed && !isPreview) {
        if (users.length > 1 || (users.length === 1 && users[0].id !== ADMIN_ID)) {
           try {
                const audienceName = (task.target_audience || 'unknown').replace('_', ' ');
                const reportMessage = `üì¢ <b>–û—Ç—á–µ—Ç –ø–æ —Ä–∞—Å—Å—ã–ª–∫–µ #${taskId}</b> (–ó–ê–í–ï–†–®–ï–ù–ê)\n\n‚úÖ –£—Å–ø–µ—à–Ω–æ: <b>${totalSuccess}</b>\n‚ùå –û—à–∏–±–∫–∏: <b>${errorCount}</b>\nüë• –ê—É–¥–∏—Ç–æ—Ä–∏—è: <b>${audienceName}</b> (${users.length} —á–µ–ª.)`;
                await bot.telegram.sendMessage(ADMIN_ID, reportMessage, { parse_mode: 'HTML' });
            } catch (e) { console.error('–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ç—á–µ—Ç –∞–¥–º–∏–Ω—É:', e.message); }
        }
    }

    return { completed, report };
}