// services/broadcastManager.js

import { ADMIN_ID } from '../config.js';
import { 
    getAlreadySentUserIds, 
    logBroadcastSent, 
    updateUserField 
} from '../db.js';
import { isDownloadQueueActive } from './downloadManager.js';

/**
 * –í—ã–ø–æ–ª–Ω—è–µ—Ç –æ—Ç–ø—Ä–∞–≤–∫—É –æ–¥–Ω–æ–π –∑–∞–¥–∞—á–∏ —Ä–∞—Å—Å—ã–ª–∫–∏ —Å –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–π —Å–∫–æ—Ä–æ—Å—Ç—å—é.
 * @param {Telegraf} bot - –≠–∫–∑–µ–º–ø–ª—è—Ä Telegraf –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π.
 * @param {object} task - –û–±—ä–µ–∫—Ç –∑–∞–¥–∞—á–∏ –∏–∑ –ë–î.
 * @param {Array<object>} users - –ú–∞—Å—Å–∏–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏.
 * @param {number|null} taskId - ID –∑–∞–¥–∞—á–∏.
 * @returns {Promise<object>} - –û—Ç—á–µ—Ç –æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏.
 */
export async function runSingleBroadcast(bot, task, users, taskId = null) {
    const isPreview = !taskId;

    if (isPreview) {
        console.log(`[Broadcast Worker] –ó–∞–ø—É—Å–∫ –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —Ä–∞—Å—Å—ã–ª–∫–∏.`);
    } else {
        console.log(`[Broadcast Worker] –ó–∞–ø—É—Å–∫ —Ä–∞—Å—Å—ã–ª–∫–∏ #${taskId} –¥–ª—è ${users.length} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.`);
    }

    const alreadySentIds = isPreview ? new Set() : await getAlreadySentUserIds(taskId);
    if (alreadySentIds.size > 0) {
        console.log(`[Broadcast Worker] –ù–∞–π–¥–µ–Ω–æ ${alreadySentIds.size} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, –∫–æ—Ç–æ—Ä—ã–µ —É–∂–µ –ø–æ–ª—É—á–∏–ª–∏ —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ. –û–Ω–∏ –±—É–¥—É—Ç –ø—Ä–æ–ø—É—â–µ–Ω—ã.`);
    }

    const usersToSend = users.filter(user => !alreadySentIds.has(user.id));
    
    if (usersToSend.length === 0 && users.length > 0 && !isPreview) {
        console.log(`[Broadcast Worker] –ù–µ—Ç –Ω–æ–≤—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ –∑–∞–¥–∞—á–µ #${taskId}. –†–∞—Å—Å—ã–ª–∫–∞ —Å—á–∏—Ç–∞–µ—Ç—Å—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω–æ–π.`);
        return { successCount: users.length, errorCount: 0, totalUsers: users.length };
    }
    
    if (!isPreview) {
        console.log(`[Broadcast Worker] –ö –æ—Ç–ø—Ä–∞–≤–∫–µ –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ ${usersToSend.length} –Ω–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π.`);
    }

    let successCount = 0;
    let errorCount = 0;
    let counter = 0;
    const reportInterval = 50;

    for (const user of usersToSend) {
        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∑–∞–¥–µ—Ä–∂–∫—É –ü–ï–†–ï–î –æ—Ç–ø—Ä–∞–≤–∫–æ–π
        const isBusy = isDownloadQueueActive();
        const delayMs = isBusy ? 500 : 35; // 500–º—Å –µ—Å–ª–∏ –∑–∞–Ω—è—Ç, 35–º—Å –µ—Å–ª–∏ —Å–≤–æ–±–æ–¥–µ–Ω
        await new Promise(resolve => setTimeout(resolve, delayMs));

        try {
            const personalMessage = (task.message || '').replace(/{first_name}/g, user.first_name || '–¥–æ—Ä–æ–≥–æ–π –¥—Ä—É–≥');
            const options = {
                parse_mode: 'HTML',
                disable_web_page_preview: task.disable_web_page_preview,
                disable_notification: task.disable_notification
            };
            if (task.keyboard && task.keyboard.length > 0) {
                options.reply_markup = { inline_keyboard: task.keyboard };
            }
            
            const fileId = task.file_id;
            if (fileId) {
                if (personalMessage) options.caption = personalMessage;
                const mimeType = task.file_mime_type || '';
                
                if (mimeType.startsWith('image/')) await bot.telegram.sendPhoto(user.id, fileId, options);
                else if (mimeType.startsWith('video/')) await bot.telegram.sendVideo(user.id, fileId, options);
                else if (mimeType.startsWith('audio/')) await bot.telegram.sendAudio(user.id, fileId, options);
                else await bot.telegram.sendDocument(user.id, fileId, options);
            } else if (personalMessage) {
                await bot.telegram.sendMessage(user.id, personalMessage, options);
            }
            
            if (!isPreview) {
                await logBroadcastSent(taskId, user.id);
            }
            successCount++;
        } catch (e) {
            errorCount++;
            if (e.response?.error_code === 403) await updateUserField(user.id, 'active', false);
        }
        
        counter++;
        if (!isPreview && counter % reportInterval === 0) {
            console.log(`[Broadcast Worker] –ü—Ä–æ–≥—Ä–µ—Å—Å —Ä–∞—Å—Å—ã–ª–∫–∏ #${taskId}: –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ ${counter} –∏–∑ ${usersToSend.length}...`);
        }
    }
    
    const totalSuccess = successCount + alreadySentIds.size;
    const report = { successCount: totalSuccess, errorCount, totalUsers: users.length };
    
    if (isPreview) {
        console.log(`[Broadcast Worker] –ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –∑–∞–≤–µ—Ä—à–µ–Ω.`, { successCount, errorCount });
    } else {
        console.log(`[Broadcast Worker] –†–∞—Å—Å—ã–ª–∫–∞ #${taskId} –∑–∞–≤–µ—Ä—à–µ–Ω–∞.`, report);
        if (users.length > 1 || (users.length === 1 && users[0].id !== ADMIN_ID)) {
            try {
                const audienceName = (task.target_audience || 'unknown').replace('_', ' ');
                const reportMessage = `üì¢ <b>–û—Ç—á–µ—Ç –ø–æ —Ä–∞—Å—Å—ã–ª–∫–µ #${taskId}</b>\n\n` +
                                    `‚úÖ –£—Å–ø–µ—à–Ω–æ: <b>${totalSuccess}</b>\n` +
                                    `‚ùå –û—à–∏–±–∫–∏: <b>${errorCount}</b>\n` +
                                    `üë• –ê—É–¥–∏—Ç–æ—Ä–∏—è: <b>${audienceName}</b> (${users.length} —á–µ–ª.)`;
                
                await bot.telegram.sendMessage(ADMIN_ID, reportMessage, { parse_mode: 'HTML' });
            } catch (e) { console.error('–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ç—á–µ—Ç –∞–¥–º–∏–Ω—É:', e.message); }
        }
    }

    return report;
}