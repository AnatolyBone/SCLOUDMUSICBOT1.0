// services/broadcastManager.js
import { ADMIN_ID } from '../config.js';
import { getAlreadySentUserIds, logBroadcastSent, updateUserField } from '../db.js';

export async function runSingleBroadcast(bot, task, users, taskId = null) {
    const isPreview = !taskId;
    const alreadySentIds = isPreview ? new Set() : await getAlreadySentUserIds(taskId);
    const usersToSend = users.filter(user => !alreadySentIds.has(user.id));

    if (usersToSend.length === 0 && users.length > 0 && !isPreview) {
        console.log(`[Broadcast] –ù–µ—Ç –Ω–æ–≤—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ –∑–∞–¥–∞—á–µ #${taskId}.`);
        return { successCount: users.length, errorCount: 0, totalUsers: users.length };
    }
    console.log(`[Broadcast] –ó–∞–ø—É—Å–∫ –¥–ª—è ${usersToSend.length} –Ω–æ–≤—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π (–≤—Å–µ–≥–æ –≤ –∞—É–¥–∏—Ç–æ—Ä–∏–∏ ${users.length}).`);
    let successCount = 0, errorCount = 0;
    for (const user of usersToSend) {
        try {
            const personalMessage = (task.message || '').replace(/{first_name}/g, user.first_name || '–¥–æ—Ä–æ–≥–æ–π –¥—Ä—É–≥');
            const options = { parse_mode: 'HTML', disable_web_page_preview: task.disable_web_page_preview, disable_notification: task.disable_notification };
            if (task.keyboard?.length > 0) options.reply_markup = { inline_keyboard: task.keyboard };
            const fileId = task.file_id;
            if (fileId) {
                if (personalMessage) options.caption = personalMessage;
                const mimeType = task.file_mime_type || '';
                if (mimeType.startsWith('image/')) await bot.telegram.sendPhoto(user.id, fileId, options);
                else if (mimeType.startsWith('video/')) await bot.telegram.sendVideo(user.id, fileId, options);
                else if (mimeType.startsWith('audio/')) await bot.telegram.sendAudio(user.id, fileId, options);
                else await bot.telegram.sendDocument(user.id, fileId, options);
            } else if (personalMessage) await bot.telegram.sendMessage(user.id, personalMessage, options);

            if (!isPreview) await logBroadcastSent(taskId, user.id);
            successCount++;
        } catch (e) {
            errorCount++;
            if (e.response?.error_code === 403) await updateUserField(user.id, 'active', false);
        }
        await new Promise(resolve => setTimeout(resolve, 40)); // ~25 msg/sec
    }
    
    const totalSuccess = successCount + alreadySentIds.size;
    const report = { successCount: totalSuccess, errorCount, totalUsers: users.length };
    
    if (isPreview) {
        console.log(`[Broadcast] –ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –∑–∞–≤–µ—Ä—à–µ–Ω.`, { successCount, errorCount });
    } else {
        console.log(`[Broadcast] –†–∞—Å—Å—ã–ª–∫–∞ #${taskId} –∑–∞–≤–µ—Ä—à–µ–Ω–∞.`, report);
        if (users.length > 1 || (users.length === 1 && users[0].id !== ADMIN_ID)) {
           try {
                const audienceName = (task.target_audience || 'unknown').replace('_', ' ');
                const reportMessage = `üì¢ <b>–û—Ç—á–µ—Ç –ø–æ —Ä–∞—Å—Å—ã–ª–∫–µ #${taskId}</b>\n\n‚úÖ –£—Å–ø–µ—à–Ω–æ: <b>${totalSuccess}</b>\n‚ùå –û—à–∏–±–∫–∏: <b>${errorCount}</b>\nüë• –ê—É–¥–∏—Ç–æ—Ä–∏—è: <b>${audienceName}</b> (${users.length} —á–µ–ª.)`;
                await bot.telegram.sendMessage(ADMIN_ID, reportMessage, { parse_mode: 'HTML' });
            } catch (e) { console.error('–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ç—á–µ—Ç –∞–¥–º–∏–Ω—É:', e.message); }
        }
    }
    return report;
}