// services/notifier.js
import { findUsersExpiringIn, markStageNotified, updateUserField, pool, logUserAction } from '../db.js';
import { T } from '../config/texts.js';

let lastNotificationDate = null;

function pluralDays(n) {
  const a = Math.abs(n) % 100;
  const b = a % 10;
  if (a > 10 && a < 20) return '–¥–Ω–µ–π';
  if (b > 1 && b < 5) return '–¥–Ω—è';
  if (b === 1) return '–¥–µ–Ω—å';
  return '–¥–Ω–µ–π';
}

// –î–Ω–µ–≤–Ω–æ–π –Ω–æ—Ç–∞–π—Ñ–µ—Ä: 3–¥/1–¥/0–¥ (—É —Ç–µ–±—è —É–∂–µ –±—ã–ª)
export async function checkAndSendExpirationNotifications(bot) {
  const now = new Date();
  const currentDate = now.toISOString().slice(0, 10);
  if (currentDate === lastNotificationDate) return;
  if (now.getUTCHours() < 10) return;

  console.log(`[Notifier] –°—Ç–∞—Ä—Ç —Ä–∞—Å—Å—ã–ª–∫–∏ –∑–∞ ${currentDate} (UTC>=10:00).`);

  const stages = [
    { days: 3, flag: 'notified_exp_3d', key: 'exp_3d' },
    { days: 1, flag: 'notified_exp_1d', key: 'exp_1d' },
    { days: 0, flag: 'notified_exp_0d', key: 'exp_0d' }
  ];

  try {
    for (const s of stages) {
      const users = await findUsersExpiringIn(s.days, s.flag);
      if (!users?.length) continue;
      console.log(`[Notifier] –≠—Ç–∞–ø ${s.days}–¥: ${users.length} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.`);

      for (const u of users) {
        const name = u.first_name || '–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å';
        const daysWord = pluralDays(s.days);
        let tpl = T(s.key) || (
          s.days === 3
            ? `üëã –ü—Ä–∏–≤–µ—Ç, {name}!\n–í–∞—à–∞ –ø–æ–¥–ø–∏—Å–∫–∞ –∏—Å—Ç–µ–∫–∞–µ—Ç —á–µ—Ä–µ–∑ {days} {days_word}.\n–ù–µ –∑–∞–±—É–¥—å—Ç–µ –ø—Ä–æ–¥–ª–∏—Ç—å: /premium`
            : s.days === 1
              ? `üëã –ü—Ä–∏–≤–µ—Ç, {name}!\n–í–∞—à–∞ –ø–æ–¥–ø–∏—Å–∫–∞ –∏—Å—Ç–µ–∫–∞–µ—Ç –∑–∞–≤—Ç—Ä–∞.\n–ü—Ä–æ–¥–ª–∏—Ç–µ –∑–∞—Ä–∞–Ω–µ–µ: /premium`
              : `‚ö†Ô∏è –ü—Ä–∏–≤–µ—Ç, {name}!\n–í–∞—à–∞ –ø–æ–¥–ø–∏—Å–∫–∞ –∏—Å—Ç–µ–∫–∞–µ—Ç —Å–µ–≥–æ–¥–Ω—è.\n–ü—Ä–æ–¥–ª–∏—Ç–µ —Å–µ–π—á–∞—Å: /premium`
        );
        const msg = tpl.replace('{name}', name).replace('{days}', String(s.days)).replace('{days_word}', daysWord);

        try {
          await bot.telegram.sendMessage(u.id, msg);
          await markStageNotified(u.id, s.flag);
          await logUserAction(u.id, 'premium_expiring_notified', { stage: s.flag, premium_until: u.premium_until });
        } catch (e) {
          if (e?.response?.error_code === 403) {
            await updateUserField(u.id, 'active', false).catch(() => {});
            await markStageNotified(u.id, s.flag).catch(() => {});
          } else {
            console.error(`[Notifier] –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ ${u.id}:`, e?.message || e);
          }
        }
        await new Promise(r => setTimeout(r, 300));
      }
    }
  } catch (e) {
    console.error('[Notifier] Fatal:', e);
  } finally {
    lastNotificationDate = currentDate;
    console.log('[Notifier] –ó–∞–≤–µ—Ä—à–µ–Ω–æ.');
  }
}

// –ü–æ—á–∞—Å–æ–≤–æ–π –Ω–æ—Ç–∞–π—Ñ–µ—Ä: —Å—Ç—Ä–∞—Ö—É–µ—Ç "—Å–µ–≥–æ–¥–Ω—è" (0d), —á—Ç–æ–±—ã –Ω–µ –ø—Ä–æ–º–∞—Ö–Ω—É—Ç—å—Å—è
export async function notifyExpiringTodayHourly(bot, lookaheadHours = 24) {
  try {
    const { rows: users } = await pool.query(
      `
      SELECT id, first_name, premium_until
      FROM users
      WHERE premium_limit <> 5
        AND premium_until IS NOT NULL
        AND premium_until > NOW()
        AND premium_until <= NOW() + ($1 || ' hours')::interval
        AND COALESCE(notified_exp_0d, false) = false
      LIMIT 300
      `,
      [lookaheadHours]
    );

    if (!users.length) return;

    console.log(`[Notifier/Hourly-0d] –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤: ${users.length}`);

    for (const u of users) {
      const untilText = new Date(u.premium_until).toLocaleString('ru-RU', {
        day: '2-digit', month: '2-digit', year: 'numeric',
        hour: '2-digit', minute: '2-digit'
      });
      const text =
        `‚è≥ –í–∞—à–∞ –ø–æ–¥–ø–∏—Å–∫–∞ –∏—Å—Ç–µ–∫–∞–µ—Ç —Å–µ–≥–æ–¥–Ω—è.\n\n` +
        `–î–∞—Ç–∞ –æ–∫–æ–Ω—á–∞–Ω–∏—è: ${untilText}.\n` +
        `–ß—Ç–æ–±—ã –Ω–µ –ø–æ—Ç–µ—Ä—è—Ç—å –ø–æ–≤—ã—à–µ–Ω–Ω—ã–π –ª–∏–º–∏—Ç, –ø—Ä–æ–¥–ª–∏—Ç–µ –ø–æ–¥–ø–∏—Å–∫—É: /premium`;

      try {
        await bot.telegram.sendMessage(u.id, text);
      } catch (e) {
        console.warn('[Notifier/Hourly-0d] send fail', u.id, e.message);
      } finally {
        // –ø–æ–º–µ—á–∞–µ–º –≤–Ω–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞, —á—Ç–æ–±—ã –Ω–µ –¥—É–¥–æ—Å–∏—Ç—å
        await markStageNotified(u.id, 'notified_exp_0d').catch(() => {});
        await logUserAction(u.id, 'premium_expiring_notified', { stage: 'notified_exp_0d', premium_until: u.premium_until }).catch(() => {});
      }
      await new Promise(r => setTimeout(r, 250));
    }
  } catch (e) {
    console.error('[Notifier/Hourly-0d] error:', e.message);
  }
}