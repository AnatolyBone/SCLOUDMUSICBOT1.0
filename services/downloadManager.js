// services/downloadManager.js (–§–ò–ù–ê–õ–¨–ù–ê–Ø –ö–û–†–†–ï–ö–¢–ù–ê–Ø –í–ï–†–°–Ø)
// services/downloadManager.js (–≤–≤–µ—Ä—Ö—É)
import { STORAGE_CHANNEL_ID } from '../config.js';
import { Markup } from 'telegraf';
import { CHANNEL_USERNAME } from '../config.js';
import path from 'path';
import fs from 'fs';
import ytdl from 'youtube-dl-exec';
import { fileURLToPath } from 'url';
import crypto from 'crypto';
import pLimit from 'p-limit';

import { bot } from '../bot.js';
import { T } from '../config/texts.js';
import { TaskQueue } from '../lib/TaskQueue.js';
import {
    getUser,
    resetDailyLimitIfNeeded,
    logEvent,
    updateUserField,
    findCachedTrack,
    cacheTrack,
    incrementDownloadsAndSaveTrack
} from '../db.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(path.dirname(__filename));
const cacheDir = path.join(__dirname, 'cache');

const YTDL_TIMEOUT = 60;
const TRACK_TITLE_LIMIT = 100;
const UNLIMITED_PLAYLIST_LIMIT = 100;
const FAKE_USER_AGENT = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36';

const ytdlLimit = pLimit(1);

function sanitizeFilename(name) {
    return (name || 'track').replace(/[<>:"/\\|?*]+/g, '').trim();
}

async function safeSendMessage(userId, text, extra = {}) {
    try {
        if (!bot) throw new Error("Bot is not initialized");
        return await bot.telegram.sendMessage(userId, text, extra);
    } catch (e) {
        if (e.response?.error_code === 403) {
            console.warn(`[SafeSend] –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${userId} –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª –±–æ—Ç–∞.`);
            await updateUserField(userId, 'active', false);
        } else {
            console.error(`[SafeSend] –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è ${userId}:`, e.message);
        }
        return null;
    }
}

// –í –§–ê–ô–õ–ï services/downloadManager.js

// >>>>> –ó–ê–ú–ï–ù–ò–¢–ï –í–°–Æ –§–£–ù–ö–¶–ò–Æ trackDownloadProcessor –ù–ê –≠–¢–£ <<<<<

async function trackDownloadProcessor(task) {
    const { userId, url, trackName, trackId, uploader } = task;
    let tempFilePath = null;
    let statusMessage = null;
    
    try {
        statusMessage = await safeSendMessage(userId, `‚è≥ –ù–∞—á–∏–Ω–∞—é –æ–±—Ä–∞–±–æ—Ç–∫—É —Ç—Ä–µ–∫–∞: "${trackName}"`);
        console.log(`[Worker] –ù–∞—á–∏–Ω–∞—é —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ: ${trackName}`);
        tempFilePath = path.join(cacheDir, `${trackId}-${crypto.randomUUID()}.mp3`);
        
        await ytdl(url, {
            output: tempFilePath,
            extractAudio: true, audioFormat: 'mp3',
            retries: 3, "socket-timeout": YTDL_TIMEOUT,
            'user-agent': FAKE_USER_AGENT
        });
        
        if (!fs.existsSync(tempFilePath)) throw new Error(`–§–∞–π–ª –Ω–µ –±—ã–ª —Å–æ–∑–¥–∞–Ω`);
        
        if (statusMessage) await bot.telegram.editMessageText(userId, statusMessage.message_id, undefined, `‚úÖ –°–∫–∞—á–∞–ª. –û—Ç–ø—Ä–∞–≤–ª—è—é...`).catch(()=>{});
        
        // 1. –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç—Ä–µ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
        const sentToUserMessage = await bot.telegram.sendAudio(userId, { source: fs.createReadStream(tempFilePath) }, { 
            title: trackName, 
            performer: uploader || 'SoundCloud' 
        });
        
        if (statusMessage) await bot.telegram.deleteMessage(userId, statusMessage.message_id).catch(()=>{});

        // 2. –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–¥–µ–ª–∞–µ–º —ç—Ç–æ —Å—Ä–∞–∑—É)
        if (sentToUserMessage?.audio?.file_id) {
            await incrementDownloadsAndSaveTrack(userId, trackName, sentToUserMessage.audio.file_id, url);
        }

        // 3. –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ –∫—ç—à–∏—Ä—É–µ–º —Ç—Ä–µ–∫ –≤ —Ñ–æ–Ω–µ, –Ω–µ –∑–∞–¥–µ—Ä–∂–∏–≤–∞—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        (async () => {
            if (STORAGE_CHANNEL_ID) {
                try {
                    console.log(`[Cache] –û—Ç–ø—Ä–∞–≤–ª—è—é "${trackName}" –≤ –∫–∞–Ω–∞–ª-—Ö—Ä–∞–Ω–∏–ª–∏—â–µ...`);
                    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–æ–ø–∏—é –≤ –∫–∞–Ω–∞–ª-—Ö—Ä–∞–Ω–∏–ª–∏—â–µ
                    const sentToStorageMessage = await bot.telegram.sendAudio(STORAGE_CHANNEL_ID, { source: tempFilePath });
                    
                    // –ï—Å–ª–∏ —É—Å–ø–µ—à–Ω–æ, —Å–æ—Ö—Ä–∞–Ω—è–µ–º file_id –∏–∑ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞ –≤ –±–∞–∑—É –∫—ç—à–∞
                    if (sentToStorageMessage?.audio?.file_id) {
                        await cacheTrack(url, sentToStorageMessage.audio.file_id, trackName);
                        console.log(`‚úÖ [Cache] –¢—Ä–µ–∫ "${trackName}" —É—Å–ø–µ—à–Ω–æ –∑–∞–∫—ç—à–∏—Ä–æ–≤–∞–Ω.`);
                    }
                } catch (e) {
                    console.error(`‚ùå [Cache] –û—à–∏–±–∫–∞ –ø—Ä–∏ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–∏ —Ç—Ä–µ–∫–∞ "${trackName}":`, e.message);
                } finally {
                    // –í–∞–∂–Ω–æ! –£–¥–∞–ª—è–µ–º —Ñ–∞–π–ª —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ —Ç–æ–≥–æ, –∫–∞–∫ –æ–±–µ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∑–∞–≤–µ—Ä—à–∏–ª–∏—Å—å.
                    if (fs.existsSync(tempFilePath)) {
                        await fs.promises.unlink(tempFilePath).catch(err => console.error("–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞:", err));
                    }
                }
            } else {
                 // –ï—Å–ª–∏ –Ω–µ—Ç –∫–∞–Ω–∞–ª–∞, –ø—Ä–æ—Å—Ç–æ —É–¥–∞–ª—è–µ–º —Ñ–∞–π–ª
                 if (fs.existsSync(tempFilePath)) {
                    await fs.promises.unlink(tempFilePath).catch(err => console.error("–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞:", err));
                }
            }
        })();

    } catch (err) {
        // ... (–±–ª–æ–∫ catch –æ—Å—Ç–∞–µ—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ...
        let userErrorMessage = `‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å —Ç—Ä–µ–∫: "${trackName}"`;
        const errorDetails = err.stderr || err.message || '';
        if (err.name === 'TimeoutError' || errorDetails.includes('timed out')) {
            userErrorMessage += '. –ü—Ä–∏—á–∏–Ω–∞: —Ç–∞–π–º–∞—É—Ç.';
        }
        console.error(`‚ùå –û—à–∏–±–∫–∞ –≤–æ—Ä–∫–µ—Ä–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ "${trackName}":`, errorDetails);
        if (statusMessage) {
            await bot.telegram.editMessageText(userId, statusMessage.message_id, undefined, userErrorMessage).catch(()=>{});
        } else {
            await safeSendMessage(userId, userErrorMessage);
        }

        // –ï—Å–ª–∏ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞, —Ç–æ–∂–µ –Ω—É–∂–Ω–æ —É–¥–∞–ª–∏—Ç—å –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
        if (tempFilePath && fs.existsSync(tempFilePath)) {
            await fs.promises.unlink(tempFilePath).catch(() => {});
        }
    } 
    // –ë–ª–æ–∫ finally —É–¥–∞–ª–µ–Ω, —Ç.–∫. –ª–æ–≥–∏–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –ø–µ—Ä–µ–Ω–µ—Å–µ–Ω–∞ –≤–Ω—É—Ç—Ä—å
}
export const downloadQueue = new TaskQueue({
    maxConcurrent: 1, // –í–∞–∂–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏
    taskProcessor: trackDownloadProcessor
});

export async function enqueue(ctx, userId, url) {
    // –í —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –±–æ–ª—å—à–µ –Ω–µ—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π processingMessage, —Ç.–∫. –º—ã —É–±—Ä–∞–ª–∏ –µ—ë –æ–±—Ä–∞–±–æ—Ç–∫—É
    try {
        await resetDailyLimitIfNeeded(userId);
        
        const user = await getUser(userId);
        const remainingLimit = user.premium_limit - (user.downloads_today || 0);

        // >>>>> –ù–ê–ß–ê–õ–û –ò–ó–ú–ï–ù–ï–ù–ò–ô <<<<<
        if (remainingLimit <= 0) {
            let message = T('limitReached');
            let bonusMessageText = '';
            if (!user.subscribed_bonus_used) {
                const cleanUsername = CHANNEL_USERNAME.replace('@', '');
                const channelLink = `[${CHANNEL_USERNAME}](https://t.me/${cleanUsername})`;
                bonusMessageText = `üéÅ –£ —Ç–µ–±—è –µ—Å—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã–π –±–æ–Ω—É—Å! –ü–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ ${channelLink} –∏ –ø–æ–ª—É—á–∏ *7 –¥–Ω–µ–π —Ç–∞—Ä–∏—Ñ–∞ Plus*.\n\n`;
            }
            message = message.replace('{bonus_message}', bonusMessageText);
            const extra = { parse_mode: 'Markdown' };
            if (!user.subscribed_bonus_used) {
                extra.reply_markup = {
                    inline_keyboard: [[ Markup.button.callback('‚úÖ –Ø –ø–æ–¥–ø–∏—Å–∞–ª—Å—è, –∑–∞–±—Ä–∞—Ç—å –±–æ–Ω—É—Å', 'check_subscription') ]]
                };
            }
            return await safeSendMessage(userId, message, extra);
        }
        // >>>>> –ö–û–ù–ï–¶ –ò–ó–ú–ï–ù–ï–ù–ò–ô <<<<<

        const info = await ytdlLimit(() => ytdl(url, {
            dumpSingleJson: true,
            retries: 2,
            "socket-timeout": YTDL_TIMEOUT,
            'user-agent': FAKE_USER_AGENT
        }));
        
        if (!info) throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ');

        const isPlaylist = Array.isArray(info.entries) && info.entries.length > 0;
        let tracksToProcess = [];
        let playlistInfo = null;

        if (isPlaylist) {
            console.log(`[Enqueue] –û–±–Ω–∞—Ä—É–∂–µ–Ω –ø–ª–µ–π–ª–∏—Å—Ç –æ—Ç ${userId}. –¢—Ä–µ–∫–æ–≤: ${info.entries.length}`);
            playlistInfo = { id: info.id, title: info.title };
            tracksToProcess = info.entries
                .filter(e => e && e.webpage_url)
                .map(e => ({
                    url: e.webpage_url, trackId: e.id,
                    trackName: sanitizeFilename(e.title).slice(0, TRACK_TITLE_LIMIT),
                    uploader: e.uploader
                }));

            let maxTracksForPlaylist;
            if (user.premium_limit <= 10) maxTracksForPlaylist = 5;
            else if (user.premium_limit >= 10000) maxTracksForPlaylist = UNLIMITED_PLAYLIST_LIMIT;
            else maxTracksForPlaylist = Infinity;
            
            const originalCount = tracksToProcess.length;
            const limitToProcess = Math.min(originalCount, maxTracksForPlaylist, remainingLimit);

            if (limitToProcess < originalCount) {
                 await safeSendMessage(userId, `‚ÑπÔ∏è –í –ø–ª–µ–π–ª–∏—Å—Ç–µ ${originalCount} —Ç—Ä–µ–∫–æ–≤. –° —É—á–µ—Ç–æ–º –≤–∞—à–µ–≥–æ —Ç–∞—Ä–∏—Ñ–∞ –∏ –¥–Ω–µ–≤–Ω–æ–≥–æ –ª–∏–º–∏—Ç–∞ –±—É–¥–µ—Ç –∑–∞–≥—Ä—É–∂–µ–Ω–æ: ${limitToProcess}.`);
            }
            tracksToProcess = tracksToProcess.slice(0, limitToProcess);
        } else {
            tracksToProcess.push({
                url: info.webpage_url || url, trackId: info.id,
                trackName: sanitizeFilename(info.title).slice(0, TRACK_TITLE_LIMIT),
                uploader: info.uploader
            });
        }
        
        if (tracksToProcess.length === 0) {
            return await safeSendMessage(userId, '–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —Ç—Ä–µ–∫–∏ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏.');
        }

        const tasksFromCache = [];
        const tasksToDownload = [];
        for (const track of tracksToProcess) {
            const cached = await findCachedTrack(track.url);
            if (cached) {
                tasksFromCache.push({ ...track, ...cached });
            } else {
                tasksToDownload.push(track);
            }
        }
        
        if (tasksFromCache.length > 0) {
            let sentFromCacheCount = 0;
            const userForCache = await getUser(userId);
            let remainingLimitForCache = userForCache.premium_limit - (userForCache.downloads_today || 0);

            for (const track of tasksFromCache) {
                if (remainingLimitForCache <= 0) break;
                try {
                    await bot.telegram.sendAudio(userId, track.fileId, { title: track.trackName, performer: track.uploader });
                    await incrementDownloadsAndSaveTrack(userId, track.trackName, track.fileId, track.url);
                    sentFromCacheCount++;
                    remainingLimitForCache--;
                } catch (err) {
                    if (err.response?.error_code === 403) { await updateUserField(userId, 'active', false); return; }
                    else if (err.description?.includes('FILE_REFERENCE_EXPIRED')) tasksToDownload.push(track);
                    else console.error(`‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∏–∑ –∫—ç—à–∞ –¥–ª—è ${userId}: ${err.message}`);
                }
            }
            if (sentFromCacheCount > 0) {
                await safeSendMessage(userId, `‚úÖ ${sentFromCacheCount} —Ç—Ä–µ–∫(–æ–≤) –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –º–≥–Ω–æ–≤–µ–Ω–Ω–æ –∏–∑ –∫—ç—à–∞.`);
            }
        }
        
        if (tasksToDownload.length > 0) {
            const userAfterCache = await getUser(userId);
            const currentLimitAfterCache = userAfterCache.premium_limit - (userAfterCache.downloads_today || 0);
            if (currentLimitAfterCache <= 0) return await safeSendMessage(userId, 'üö´ –í–∞—à –ª–∏–º–∏—Ç –∏—Å—á–µ—Ä–ø–∞–Ω —Ç—Ä–µ–∫–∞–º–∏ –∏–∑ –∫—ç—à–∞.');
            
            const tasksToReallyDownload = tasksToDownload.slice(0, currentLimitAfterCache);

            if (tasksToReallyDownload.length > 0) {
                await safeSendMessage(userId, `‚è≥ ${tasksToReallyDownload.length} —Ç—Ä–µ–∫(–æ–≤) –¥–æ–±–∞–≤–ª–µ–Ω–æ –≤ –æ—á–µ—Ä–µ–¥—å. –í—ã –ø–æ–ª—É—á–∏—Ç–µ –∏—Ö –ø–æ –º–µ—Ä–µ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏.`);
                
                if (isPlaylist && playlistInfo) {
                    await logEvent(userId, 'download_playlist');
                }
                
                for (const track of tasksToReallyDownload) {
                    downloadQueue.add({ userId, ...track, playlistInfo, priority: user.premium_limit });
                    if(!isPlaylist) await logEvent(userId, 'download');
                }
            }
        }
    } catch (err) {
        // –ú—ã —É–±—Ä–∞–ª–∏ processingMessage, –ø–æ—ç—Ç–æ–º—É –µ–≥–æ –Ω–µ –Ω—É–∂–Ω–æ —É–¥–∞–ª—è—Ç—å
        const errorMessage = err.stderr || err.message || '';
        if (err.name === 'TimeoutError' || errorMessage.includes('timed out')) {
            console.error(`‚ùå –¢–∞–π–º–∞—É—Ç –≤ enqueue –¥–ª—è ${userId}:`, errorMessage);
            await safeSendMessage(userId, '‚ùå –û—à–∏–±–∫–∞: SoundCloud –æ—Ç–≤–µ—á–∞–µ—Ç —Å–ª–∏—à–∫–æ–º –¥–æ–ª–≥–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
        } else if (errorMessage.includes('404: Not Found') || errorMessage.includes('403: Forbidden')) {
            console.warn(`[User Error] –¢—Ä–µ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω (404/403) –¥–ª—è ${userId}.`);
            await safeSendMessage(userId, '‚ùå –¢—Ä–µ–∫ –ø–æ —ç—Ç–æ–π —Å—Å—ã–ª–∫–µ –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –¥–æ—Å—Ç—É–ø –∫ –Ω–µ–º—É –æ–≥—Ä–∞–Ω–∏—á–µ–Ω.');
        } else {
            console.error(`‚ùå –ì–ª–æ–±–∞–ª—å–Ω–∞—è –æ—à–∏–±–∫–∞ –≤ enqueue –¥–ª—è ${userId}:`, err);
            await safeSendMessage(userId, `‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å—Å—ã–ª–∫–∏.`);
        }
    }
}