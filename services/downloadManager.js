// services/downloadManager.js (ULTRA-FAST FINAL VERSION with FFmpeg & Storage)

import scdl from 'soundcloud-downloader';
import pMap from 'p-map';
import Redis from 'ioredis';
import { Markup } from 'telegraf';
import path from 'path';
import ffmpegPath from 'ffmpeg-static';
import fs from 'fs';
import os from 'os';
import crypto from 'crypto';
import ytdl from 'youtube-dl-exec';

import { bot } from '../bot.js';
import { T } from '../config/texts.js';
import { TaskQueue } from '../lib/TaskQueue.js';
import * as db from '../db.js';
import { getSetting } from './settingsManager.js';
import { STORAGE_CHANNEL_ID, CHANNEL_USERNAME, PROXY_URL } from '../config.js';

// ========================= CONFIGURATION =========================

const cacheDir = path.join(os.tmpdir(), 'cache');
if (!fs.existsSync(cacheDir)) fs.mkdirSync(cacheDir, { recursive: true });

const MAX_FILE_SIZE_BYTES = 49 * 1024 * 1024; // 49 –ú–ë
const MAX_CONCURRENT_DOWNLOADS = parseInt(process.env.MAX_CONCURRENT_DOWNLOADS, 10) || 5;
const YTDL_TIMEOUT = 90;
const FAKE_USER_AGENT = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36';

const FFMPEG_AVAILABLE =
  (!!ffmpegPath && fs.existsSync(ffmpegPath)) &&
  process.env.FFMPEG_AVAILABLE !== '0' &&
  process.env.FFMPEG_STATIC_SKIP_DOWNLOAD !== '1';

// üî• Redis –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –∫—ç—à–∞
const redis = new Redis(process.env.REDIS_URL || 'redis://localhost:6379', {
  retryStrategy: (times) => {
    if (times > 10) {
      console.error('[Redis] –ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –ø–æ–ø—ã—Ç–æ–∫ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è.');
      return null;
    }
    return Math.min(times * 100, 3000);
  },
  maxRetriesPerRequest: 3
});

redis.on('connect', () => console.log('‚úÖ [Redis] –ü–æ–¥–∫–ª—é—á–µ–Ω –∫ –∫—ç—à—É —Ç—Ä–µ–∫–æ–≤'));
redis.on('error', (err) => console.error('‚ùå [Redis] –û—à–∏–±–∫–∞:', err.message));

// –ë–∞–∑–æ–≤—ã–µ –∞—Ä–≥—É–º–µ–Ω—Ç—ã –¥–ª—è youtube-dl (–¥–ª—è –ø–ª–µ–π–ª–∏—Å—Ç–æ–≤ –≤ bot.js)
export const YTDL_COMMON = {
  'ffmpeg-location': ffmpegPath || undefined,
  'user-agent': FAKE_USER_AGENT,
  proxy: PROXY_URL || undefined,
  retries: 2,
  'socket-timeout': YTDL_TIMEOUT,
  'no-warnings': true,
  'no-check-certificate': true,
  'prefer-free-formats': true,
  'extractor-args': 'soundcloud:client_id=a3e059563d7fd3372b49b37f00a00bcf'
};

// ========================= HELPER FUNCTIONS =========================

function sanitizeFilename(name) {
  if (!name || typeof name !== 'string') return 'track';
  return name.replace(/[<>:"/\\|?*]+/g, '').trim().slice(0, 200) || 'track';
}

function getCacheKey(url, metadata) {
  // –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: ID —Ç—Ä–µ–∫–∞ > –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π URL
  if (metadata?.id) return `sc:${metadata.id}`;
  return `sc:${url.replace(/\?.*$/, '')}`;
}

async function safeSendMessage(userId, text, extra = {}) {
  try {
    return await bot.telegram.sendMessage(userId, text, extra);
  } catch (e) {
    if (e.response?.error_code === 403) {
      try { 
        await db.updateUserField(userId, 'active', false); 
      } catch (dbErr) {
        console.error(`[DB] –î–µ–∞–∫—Ç–∏–≤–∞—Ü–∏—è user ${userId}:`, dbErr.message);
      }
    }
    return null;
  }
}

async function incrementDownload(userId, trackTitle, fileId, cacheKey) {
  if (typeof db.incrementDownloadsAndLogPg === 'function') {
    return await db.incrementDownloadsAndLogPg(userId, trackTitle, fileId, cacheKey);
  }
  return await db.incrementDownloadsAndSaveTrack(userId, trackTitle, fileId, cacheKey);
}

async function getUserUsage(userId) {
  if (typeof db.getUserUsage === 'function') return await db.getUserUsage(userId);
  if (typeof db.getUserLite === 'function') return await db.getUserLite(userId);
  return await db.getUser(userId);
}

// ========================= REDIS CACHE =========================

async function getCachedTrack(url, metadata) {
  try {
    const cacheKey = getCacheKey(url, metadata);
    const cached = await redis.get(cacheKey);
    
    if (cached) {
      const data = JSON.parse(cached);
      console.log(`[Cache] ‚ö° HIT –¥–ª—è ${url}`);
      return data;
    }
    
    // Fallback –Ω–∞ PostgreSQL
    const pgCached = await db.findCachedTrack(cacheKey) || await db.findCachedTrack(url);
    
    if (pgCached?.fileId) {
      console.log(`[Cache] ‚ö° HIT –≤ PostgreSQL –¥–ª—è ${url}`);
      // –î—É–±–ª–∏—Ä—É–µ–º –≤ Redis –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞ –≤ –±—É–¥—É—â–µ–º
      await redis.setex(cacheKey, 2592000, JSON.stringify(pgCached));
      return pgCached;
    }
    
    console.log(`[Cache] ‚ùå MISS –¥–ª—è ${url}`);
    return null;
  } catch (e) {
    console.error('[Cache] –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è:', e.message);
    return null;
  }
}

async function setCachedTrack(url, fileId, metadata) {
  try {
    const cacheKey = getCacheKey(url, metadata);
    const data = {
      fileId,
      trackName: metadata.title,
      artist: metadata.artist,
      duration: metadata.duration,
      thumbnail: metadata.thumbnail,
      cachedAt: Date.now()
    };
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ Redis (30 –¥–Ω–µ–π)
    await redis.setex(cacheKey, 2592000, JSON.stringify(data));
    console.log(`[Cache] üíæ Redis: ${metadata.title}`);
    
    // –î—É–±–ª–∏—Ä—É–µ–º –≤ PostgreSQL –¥–ª—è –¥–æ–ª–≥–æ—Å—Ä–æ—á–Ω–æ–≥–æ —Ö—Ä–∞–Ω–µ–Ω–∏—è
    await db.cacheTrack({
      url: cacheKey,
      fileId,
      title: metadata.title,
      artist: metadata.artist,
      duration: metadata.duration,
      thumbnail: metadata.thumbnail
    }).catch(e => console.error('[DB Cache] –û—à–∏–±–∫–∞:', e.message));
    
  } catch (e) {
    console.error('[Cache] –û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏:', e.message);
  }
}

// ========================= FILE SIZE CHECK =========================

async function checkFileSize(url) {
  try {
    // –î–ª—è SoundCloud –∏—Å–ø–æ–ª—å–∑—É–µ–º scdl API (–±—ã—Å—Ç—Ä–µ–µ)
    const info = await scdl.getInfo(url);
    
    // –£ SoundCloud —Ç—Ä–µ–∫–∏ –æ–±—ã—á–Ω–æ –¥–æ 10 –ú–ë, –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–ª—å–∫–æ duration
    if (info.duration && info.duration > 3600000) { // > 1 —á–∞—Å–∞
      console.warn('[Pre-flight] –¢—Ä–µ–∫ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π:', info.duration / 1000 / 60, '–º–∏–Ω');
      return { ok: false, reason: 'FILE_TOO_LONG' };
    }
    
    return { ok: true };
  } catch (e) {
    console.warn('[Pre-flight] –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏:', e.message);
    return { ok: true, reason: 'CHECK_FAILED' };
  }
}

// ========================= CACHE CLEANUP =========================

function startCacheCleanup() {
  const cleanupInterval = setInterval(async () => {
    try {
      const files = await fs.promises.readdir(cacheDir);
      const now = Date.now();
      let cleaned = 0;
      
      await Promise.all(files.map(async (file) => {
        try {
          const filePath = path.join(cacheDir, file);
          const stats = await fs.promises.stat(filePath);
          
          // –£–¥–∞–ª—è–µ–º —Ñ–∞–π–ª—ã —Å—Ç–∞—Ä—à–µ 30 –º–∏–Ω—É—Ç
          if (now - stats.mtimeMs > 1800000) {
            await fs.promises.unlink(filePath);
            cleaned++;
          }
        } catch {}
      }));
      
      if (cleaned > 0) {
        console.log(`[Cache Cleanup] üßπ –£–¥–∞–ª–µ–Ω–æ ${cleaned} –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤`);
      }
    } catch (err) {
      console.error('[Cache Cleanup] –û—à–∏–±–∫–∞:', err.message);
    }
  }, 1800000); // –ö–∞–∂–¥—ã–µ 30 –º–∏–Ω—É—Ç
  
  process.on('SIGTERM', () => clearInterval(cleanupInterval));
  process.on('SIGINT', () => clearInterval(cleanupInterval));
}

startCacheCleanup();

// ========================= TRACK PROCESSOR =========================

async function processTrack(userId, url) {
  let tempFilePath = null;
  let statusMessage = null;
  const startTime = Date.now();
  
  try {
    // 1Ô∏è‚É£ –ü–æ–ª—É—á–µ–Ω–∏–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö
    let info;
    try {
      info = await scdl.getInfo(url);
    } catch (scdlError) {
      console.error(`[Track] –û—à–∏–±–∫–∞ scdl.getInfo –¥–ª—è ${url}:`, scdlError.message);
      throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç—Ä–µ–∫–µ');
    }
    
    if (!info) {
      throw new Error('–¢—Ä–µ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω');
    }
    
    const metadata = {
      id: info.id,
      title: sanitizeFilename(info.title || 'Unknown Track'),
      artist: info.user?.username || 'Unknown Artist',
      duration: info.duration ? Math.round(info.duration / 1000) : undefined,
      thumbnail: info.artwork_url || info.user?.avatar_url
    };
    
    console.log(`[Track] üìù –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é: "${metadata.title}" by ${metadata.artist}`);
    
    // 2Ô∏è‚É£ –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—ç—à–∞
    const cached = await getCachedTrack(url, metadata);
    
    if (cached?.fileId) {
      console.log(`[Track] ‚ö° –û—Ç–ø—Ä–∞–≤–∫–∞ –∏–∑ –∫—ç—à–∞: ${cached.trackName}`);
      
      await bot.telegram.sendAudio(userId, cached.fileId, {
        title: cached.trackName,
        performer: cached.artist,
        duration: cached.duration
      });
      
      await incrementDownload(userId, cached.trackName, cached.fileId, getCacheKey(url, metadata));
      
      const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
      console.log(`[Track] ‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –∑–∞ ${elapsed}—Å (–∫—ç—à)`);
      return;
    }
    
    // 3Ô∏è‚É£ –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–∑–º–µ—Ä–∞
    statusMessage = await safeSendMessage(userId, 'üîç –ü—Ä–æ–≤–µ—Ä—è—é –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å...');
    
    const sizeCheck = await checkFileSize(url);
    if (!sizeCheck.ok && sizeCheck.reason === 'FILE_TOO_LONG') {
      throw new Error('FILE_TOO_LONG');
    }
    
    // 4Ô∏è‚É£ –°–∫–∞—á–∏–≤–∞–Ω–∏–µ —Å –æ–±–ª–æ–∂–∫–æ–π (—á–µ—Ä–µ–∑ –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª –¥–ª—è FFmpeg)
    if (statusMessage) {
      await bot.telegram.editMessageText(
        userId,
        statusMessage.message_id,
        undefined,
        '‚è¨ –°–∫–∞—á–∏–≤–∞—é —Ç—Ä–µ–∫...'
      ).catch(() => {});
    }
    
    const tempFileName = `${metadata.id || crypto.randomUUID()}.mp3`;
    tempFilePath = path.join(cacheDir, tempFileName);
    
    console.log(`[Track] üöÄ –°–∫–∞—á–∏–≤–∞—é: ${metadata.title}`);
    
    // –°–∫–∞—á–∏–≤–∞–µ–º —á–µ—Ä–µ–∑ scdl –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–∞ –¥–∏—Å–∫ (–¥–ª—è –≤—Å—Ç—Ä–∞–∏–≤–∞–Ω–∏—è –æ–±–ª–æ–∂–∫–∏)
    const stream = await scdl.download(url);
    const writeStream = fs.createWriteStream(tempFilePath);
    
    await new Promise((resolve, reject) => {
      stream.pipe(writeStream);
      stream.on('error', reject);
      writeStream.on('finish', resolve);
      writeStream.on('error', reject);
    });
    
    console.log(`[Track] ‚úÖ –°–∫–∞—á–∞–Ω–æ: ${(await fs.promises.stat(tempFilePath)).size / 1024 / 1024} –ú–ë`);
    
    // 5Ô∏è‚É£ –í—Å—Ç—Ä–∞–∏–≤–∞–Ω–∏–µ –æ–±–ª–æ–∂–∫–∏ —á–µ—Ä–µ–∑ FFmpeg (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω)
    if (FFMPEG_AVAILABLE && metadata.thumbnail) {
      try {
        console.log(`[Track] üé® –í—Å—Ç—Ä–∞–∏–≤–∞—é –æ–±–ª–æ–∂–∫—É...`);
        
        const tempWithCover = tempFilePath.replace('.mp3', '-cover.mp3');
        
        await ytdl(url, {
          output: tempWithCover,
          'extract-audio': true,
          'audio-format': 'mp3',
          'embed-thumbnail': true,
          'add-metadata': true,
          'ffmpeg-location': ffmpegPath,
          ...YTDL_COMMON
        });
        
        // –ó–∞–º–µ–Ω—è–µ–º —Ñ–∞–π–ª –≤–µ—Ä—Å–∏–µ–π —Å –æ–±–ª–æ–∂–∫–æ–π
        await fs.promises.unlink(tempFilePath);
        tempFilePath = tempWithCover;
        
        console.log(`[Track] ‚úÖ –û–±–ª–æ–∂–∫–∞ –≤—Å—Ç—Ä–æ–µ–Ω–∞`);
      } catch (ffmpegErr) {
        console.warn('[Track] ‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –≤—Å—Ç—Ä–æ–∏—Ç—å –æ–±–ª–æ–∂–∫—É:', ffmpegErr.message);
        // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º —Å —Ñ–∞–π–ª–æ–º –±–µ–∑ –æ–±–ª–æ–∂–∫–∏
      }
    }
    
    // 6Ô∏è‚É£ –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–∑–º–µ—Ä–∞ —Ñ–∞–π–ª–∞
    const fileStats = await fs.promises.stat(tempFilePath);
    
    if (fileStats.size > MAX_FILE_SIZE_BYTES) {
      throw new Error('FILE_TOO_LARGE');
    }
    
    // 7Ô∏è‚É£ –û—Ç–ø—Ä–∞–≤–∫–∞ –≤ –∫–∞–Ω–∞–ª-—Ö—Ä–∞–Ω–∏–ª–∏—â–µ (–µ—Å–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ)
    if (statusMessage) {
      await bot.telegram.editMessageText(
        userId,
        statusMessage.message_id,
        undefined,
        'üì§ –û—Ç–ø—Ä–∞–≤–ª—è—é —Ç—Ä–µ–∫...'
      ).catch(() => {});
    }
    
    let finalFileId = null;
    const safeFilename = `${metadata.title}.mp3`;
    
        if (STORAGE_CHANNEL_ID) {
      try {
        console.log(`[Track] üíæ –ó–∞–≥—Ä—É–∂–∞—é –≤ –∫–∞–Ω–∞–ª-—Ö—Ä–∞–Ω–∏–ª–∏—â–µ...`);
        
        const sentToStorage = await bot.telegram.sendAudio(
          STORAGE_CHANNEL_ID,
          { source: fs.createReadStream(tempFilePath), filename: safeFilename },
          { 
            title: metadata.title, 
            performer: metadata.artist, 
            duration: metadata.duration 
          }
        );
        
        if (sentToStorage?.audio?.file_id) {
          finalFileId = sentToStorage.audio.file_id;
          
          // –ö—ç—à–∏—Ä—É–µ–º file_id
          await setCachedTrack(url, finalFileId, metadata);
          
          console.log(`[Track] ‚úÖ –ó–∞–∫—ç—à–∏—Ä–æ–≤–∞–Ω–æ –≤ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ: ${metadata.title}`);
        }
      } catch (storageErr) {
        console.error('[Track] ‚ö†Ô∏è –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –≤ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ:', storageErr.message);
        // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –±–µ–∑ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è
      }
    }
    
    // 8Ô∏è‚É£ –û—Ç–ø—Ä–∞–≤–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
    if (finalFileId) {
      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —á–µ—Ä–µ–∑ file_id (–±—ã—Å—Ç—Ä–æ)
      await bot.telegram.sendAudio(userId, finalFileId, {
        title: metadata.title,
        performer: metadata.artist,
        duration: metadata.duration
      });
    } else {
      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ñ–∞–π–ª –Ω–∞–ø—Ä—è–º—É—é
      console.warn('[Track] –û—Ç–ø—Ä–∞–≤–ª—è—é —Ñ–∞–π–ª –Ω–∞–ø—Ä—è–º—É—é (—Ö—Ä–∞–Ω–∏–ª–∏—â–µ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ)');
      
      const sentMsg = await bot.telegram.sendAudio(
        userId,
        { source: fs.createReadStream(tempFilePath), filename: safeFilename },
        { 
          title: metadata.title, 
          performer: metadata.artist, 
          duration: metadata.duration 
        }
      );
      
      finalFileId = sentMsg?.audio?.file_id;
      
      // –ö—ç—à–∏—Ä—É–µ–º file_id –¥–ª—è –±—É–¥—É—â–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
      if (finalFileId) {
        await setCachedTrack(url, finalFileId, metadata);
      }
    }
    
    // 9Ô∏è‚É£ –£–¥–∞–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
    if (statusMessage) {
      await bot.telegram.deleteMessage(userId, statusMessage.message_id).catch(() => {});
    }
    
    // üîü –ò–Ω–∫—Ä–µ–º–µ–Ω—Ç —Å—á–µ—Ç—á–∏–∫–∞
    if (finalFileId) {
      await incrementDownload(userId, metadata.title, finalFileId, getCacheKey(url, metadata));
    }
    
    const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
    console.log(`[Track] ‚úÖ –ó–∞–≤–µ—Ä—à–µ–Ω–æ –∑–∞ ${elapsed}—Å (–Ω–æ–≤–∞—è –∑–∞–≥—Ä—É–∑–∫–∞)`);
    
  } catch (err) {
    const errorDetails = err?.message || '';
    let userMsg = '‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å —Ç—Ä–µ–∫.';
    
    if (errorDetails.includes('FILE_TOO_LARGE')) {
      userMsg = '‚ùå –§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π (–º–∞–∫—Å. 49 –ú–ë).';
    } else if (errorDetails.includes('FILE_TOO_LONG')) {
      userMsg = '‚ùå –¢—Ä–µ–∫ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å. 1 —á–∞—Å).';
    } else if (errorDetails.includes('Not a SoundCloud')) {
      userMsg = '‚ùå –ù–µ–≤–µ—Ä–Ω–∞—è —Å—Å—ã–ª–∫–∞ –Ω–∞ SoundCloud.';
    } else if (errorDetails.includes('timed out') || errorDetails.includes('timeout')) {
      userMsg = '‚ùå –ü—Ä–µ–≤—ã—à–µ–Ω–æ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è.';
    } else if (errorDetails.includes('404') || errorDetails.includes('not found')) {
      userMsg = '‚ùå –¢—Ä–µ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ —É–¥–∞–ª—ë–Ω.';
    } else if (errorDetails.includes('403') || errorDetails.includes('Forbidden')) {
      userMsg = '‚ùå –î–æ—Å—Ç—É–ø –∫ —Ç—Ä–µ–∫—É –æ–≥—Ä–∞–Ω–∏—á–µ–Ω.';
    } else if (errorDetails.includes('private') || errorDetails.includes('geo')) {
      userMsg = '‚ùå –¢—Ä–µ–∫ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω (–ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∏–ª–∏ geo-–±–ª–æ–∫).';
    }
    
    console.error(`[Track] ‚ùå –û—à–∏–±–∫–∞ –¥–ª—è user ${userId}:`, errorDetails);
    
    if (statusMessage) {
      await bot.telegram.editMessageText(
        userId,
        statusMessage.message_id,
        undefined,
        userMsg
      ).catch(() => {});
    } else {
      await safeSendMessage(userId, userMsg);
    }
    
  } finally {
    // –û—á–∏—Å—Ç–∫–∞ –≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞
    if (tempFilePath) {
      fs.promises.unlink(tempFilePath).catch(() => {});
    }
  }
}

// ========================= MAIN ENQUEUE FUNCTION =========================

export function enqueue(ctx, userId, url) {
  (async () => {
    try {
      // 1Ô∏è‚É£ –í–∞–ª–∏–¥–∞—Ü–∏—è
      if (!url || typeof url !== 'string' || !url.includes('soundcloud.com')) {
        await safeSendMessage(userId, '‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Å—Å—ã–ª–∫–∞ –Ω–∞ SoundCloud');
        return;
      }
      
      // 2Ô∏è‚É£ –ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏–º–∏—Ç–æ–≤
      await db.resetDailyLimitIfNeeded(userId);
      const user = await getUserUsage(userId);
      
      if (!user || user.downloads_today >= user.premium_limit) {
        const bonusAvailable = Boolean(CHANNEL_USERNAME && !user?.subscribed_bonus_used);
        const cleanUsername = CHANNEL_USERNAME?.replace('@', '');
        const bonusText = bonusAvailable
          ? `\n\nüéÅ –î–æ—Å—Ç—É–ø–µ–Ω –±–æ–Ω—É—Å! –ü–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ <a href="https://t.me/${cleanUsername}">@${cleanUsername}</a> –∏ –ø–æ–ª—É—á–∏ <b>7 –¥–Ω–µ–π —Ç–∞—Ä–∏—Ñ–∞ Plus</b>.`
          : '';

        const text = `${T('limitReached')}${bonusText}`;
        const extra = { parse_mode: 'HTML', disable_web_page_preview: true };

        if (bonusAvailable) {
          extra.reply_markup = {
            inline_keyboard: [[ 
              Markup.button.callback('‚úÖ –Ø –ø–æ–¥–ø–∏—Å–∞–ª—Å—è, –∑–∞–±—Ä–∞—Ç—å –±–æ–Ω—É—Å', 'check_subscription') 
            ]]
          };
        }

        await safeSendMessage(userId, text, extra);
        return;
      }
      
      // 3Ô∏è‚É£ –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç—Ä–µ–∫–∞
      await processTrack(userId, url);
      
    } catch (err) {
      console.error('[Enqueue] ‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞:', err.message);
      await safeSendMessage(userId, '‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å—Å—ã–ª–∫–∏.');
    }
  })();
}

// ========================= QUEUE =========================

export const downloadQueue = new TaskQueue({
  maxConcurrent: MAX_CONCURRENT_DOWNLOADS,
  taskProcessor: async (task) => {
    await processTrack(task.userId, task.url);
  }
});

console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë  üöÄ Download Manager v3.0 (Ultra-Fast + Storage)         ‚ïë
‚ïü‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ï¢
‚ïë  ‚ö° –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏:                                          ‚ïë
‚ïë    ‚úÖ Soundcloud-downloader (–≤–º–µ—Å—Ç–æ youtube-dl)          ‚ïë
‚ïë    ‚úÖ Redis –∫—ç—à (–º–≥–Ω–æ–≤–µ–Ω–Ω–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞)                    ‚ïë
‚ïë    ‚úÖ FFmpeg –¥–ª—è –æ–±–ª–æ–∂–µ–∫                                 ‚ïë
‚ïë    ‚úÖ –ö–∞–Ω–∞–ª-—Ö—Ä–∞–Ω–∏–ª–∏—â–µ –¥–ª—è –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è                    ‚ïë
‚ïë    ‚úÖ –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ (–¥–æ ${MAX_CONCURRENT_DOWNLOADS} —Ç—Ä–µ–∫–æ–≤)               ‚ïë
‚ïë    ‚úÖ –ê–≤—Ç–æ–æ—á–∏—Å—Ç–∫–∞ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤                       ‚ïë
‚ïü‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ï¢
‚ïë  üìä –ü–∞—Ä–∞–º–µ—Ç—Ä—ã:                                            ‚ïë
‚ïë    ‚Ä¢ Max Concurrent: ${MAX_CONCURRENT_DOWNLOADS}                                  ‚ïë
‚ïë    ‚Ä¢ Max File Size: 49 –ú–ë                                ‚ïë
‚ïë    ‚Ä¢ Cache TTL: 30 –¥–Ω–µ–π                                  ‚ïë
‚ïë    ‚Ä¢ FFmpeg: ${FFMPEG_AVAILABLE ? '‚úÖ –î–æ—Å—Ç—É–ø–µ–Ω' : '‚ùå –û—Ç–∫–ª—é—á–µ–Ω'}                                ‚ïë
‚ïë    ‚Ä¢ Storage: ${STORAGE_CHANNEL_ID ? '‚úÖ –ù–∞—Å—Ç—Ä–æ–µ–Ω' : '‚ö†Ô∏è –ù–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω'}                             ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
`);

// ========================= EXPORTS =========================

export default {
  enqueue,
  downloadQueue,
  processTrack
};