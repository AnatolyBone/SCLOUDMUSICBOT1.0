// services/downloadManager.js (–§–ò–ù–ê–õ–¨–ù–ê–Ø –í–ï–†–°–ò–Ø –° –†–ê–°–®–ò–†–ï–ù–ù–´–ú –õ–û–ì–ì–ò–†–û–í–ê–ù–ò–ï–ú)

import { STORAGE_CHANNEL_ID, CHANNEL_USERNAME, PROXY_URL, ADMIN_ID } from '../config.js';
import { Markup } from 'telegraf';
import path from 'path';
import fs from 'fs';
import { fileURLToPath } from 'url';
import crypto from 'crypto';
import { spawn } from 'child_process';
import { bot } from '../bot.js';
import { T } from '../config/texts.js';
import { TaskQueue } from '../lib/TaskQueue.js';
import {
    getUser, resetDailyLimitIfNeeded, logEvent, updateUserField,
    findCachedTrack, cacheTrack, incrementDownloadsAndSaveTrack
} from '../db.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(path.dirname(__filename));
const cacheDir = path.join(__dirname, 'cache');

const YTDL_TIMEOUT = 180;
const TRACK_TITLE_LIMIT = 100;
const UNLIMITED_PLAYLIST_LIMIT = 100;
const FAKE_USER_AGENT = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36';

function sanitizeFilename(name) {
    return (name || 'track').replace(/[<>:"/\\|?*]+/g, '').trim();
}

async function safeSendMessage(userId, text, extra = {}) {
    try {
        if (!bot) throw new Error("Bot is not initialized");
        return await bot.telegram.sendMessage(userId, text, extra);
    } catch (e) {
        if (e.response?.error_code === 403) {
            console.warn(`[SafeSend] –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${userId} –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª –±–æ—Ç–∞.`);
            await updateUserField(userId, 'active', false);
        } else {
            console.error(`[SafeSend] –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è ${userId}:`, e.message);
        }
        return null;
    }
}

function spawnAsync(command, args) {
    return new Promise((resolve, reject) => {
        const process = spawn(command, args, { timeout: YTDL_TIMEOUT * 1000 });
        let stdout = '';
        let stderr = '';

        process.stdout.on('data', (data) => stdout += data.toString());
        process.stderr.on('data', (data) => stderr += data.toString());

        process.on('close', (code) => {
            if (code === 0) {
                resolve({ stdout, stderr });
            } else {
                const error = new Error(`Command failed with exit code ${code}`);
                error.stdout = stdout;
                error.stderr = stderr;
                reject(error);
            }
        });

        process.on('error', (err) => {
            if (err.code === 'ETIMEDOUT') {
                const timeoutError = new Error('Process timed out');
                timeoutError.name = 'TimeoutError';
                reject(timeoutError);
            } else {
                reject(err);
            }
        });
    });
}

async function trackDownloadProcessor(task) {
    const { userId, source, metadata } = task;
    const { title, uploader, id: trackId, duration, thumbnail } = metadata;
    const roundedDuration = duration ? Math.round(duration) : undefined;
    
    let tempFilePath = null;
    let statusMessage = null;
    
    try {
        statusMessage = await safeSendMessage(userId, `‚è≥ –ù–∞—á–∏–Ω–∞—é —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ —Ç—Ä–µ–∫–∞: "${title}"`);
        console.log(`[Worker] –ù–∞—á–∏–Ω–∞—é —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ "${title}" (–∏—Å—Ç–æ—á–Ω–∏–∫: ${source})`);
        
        const tempFileName = `${trackId}-${crypto.randomUUID()}.mp3`;
        tempFilePath = path.join(cacheDir, tempFileName);
        
        const command = 'yt-dlp';
        const args = [];
        
        if (source === 'spotify') {
            const searchQuery = `${title} ${uploader}`;
            console.log(`[Worker] Spotify —Ç—Ä–µ–∫. –ò—â—É –Ω–∞ YouTube Music –ø–æ –∑–∞–ø—Ä–æ—Å—É: "${searchQuery}"`);
            args.push('--default-search', 'ytmsearch1', searchQuery);
        } else {
            args.push(task.url);
        }

        args.push(
            '--verbose', // <== –í–û–¢ –≠–¢–û –ò–ó–ú–ï–ù–ï–ù–ò–ï –î–õ–Ø –î–ï–¢–ê–õ–¨–ù–û–ô –î–ò–ê–ì–ù–û–°–¢–ò–ö–ò
            '--max-downloads', '1',
            '-o', tempFilePath,
            '-x',
            '--audio-format', 'mp3',
            '--embed-thumbnail',
            '--retries', '3',
            '--socket-timeout', '30',
            '--user-agent', FAKE_USER_AGENT
        );

        if (PROXY_URL) {
            console.log(`[Worker] –ò—Å–ø–æ–ª—å–∑—É—é –ø—Ä–æ–∫—Å–∏: ${PROXY_URL}`);
            args.push('--proxy', PROXY_URL);
        } else {
            console.log(`[Worker] –†–∞–±–æ—Ç–∞—é –±–µ–∑ –ø—Ä–æ–∫—Å–∏.`);
        }
        
        console.log(`[Worker] –í—ã–ø–æ–ª–Ω—è—é –∫–æ–º–∞–Ω–¥—É: ${command} ${args.map(a => a.includes(' ') ? `"${a}"` : a).join(' ')}`);
        
        await spawnAsync(command, args);
        
        if (!fs.existsSync(tempFilePath)) throw new Error(`–§–∞–π–ª –Ω–µ –±—ã–ª —Å–æ–∑–¥–∞–Ω –ø–æ—Å–ª–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è yt-dlp`);
        
        if (statusMessage) await bot.telegram.editMessageText(userId, statusMessage.message_id, undefined, `‚úÖ –°–∫–∞—á–∞–ª. –û—Ç–ø—Ä–∞–≤–ª—è—é...`).catch(() => {});
        
        const sentToUserMessage = await bot.telegram.sendAudio(userId, { source: fs.createReadStream(tempFilePath) }, {
            title: title,
            performer: uploader || 'Unknown Artist',
            duration: roundedDuration
        });
        
        if (statusMessage) await bot.telegram.deleteMessage(userId, statusMessage.message_id).catch(() => {});
        
        const cacheUrl = task.spotifyUrl || task.url;
        
        if (sentToUserMessage?.audio?.file_id) {
            await incrementDownloadsAndSaveTrack(userId, title, sentToUserMessage.audio.file_id, cacheUrl);
        }
        
        (async () => {
            if (STORAGE_CHANNEL_ID && sentToUserMessage?.audio?.file_id) {
                try {
                    console.log(`[Cache] –û—Ç–ø—Ä–∞–≤–ª—è—é "${title}" –≤ –∫–∞–Ω–∞–ª-—Ö—Ä–∞–Ω–∏–ª–∏—â–µ...`);
                    const sentToStorageMessage = await bot.telegram.sendAudio(
                        STORAGE_CHANNEL_ID,
                        sentToUserMessage.audio.file_id
                    );
                    
                    if (sentToStorageMessage?.audio?.file_id) {
                        await cacheTrack({
                            url: cacheUrl,
                            fileId: sentToStorageMessage.audio.file_id,
                            title: title,
                            artist: uploader,
                            duration: roundedDuration,
                            thumbnail: thumbnail
                        });
                        console.log(`‚úÖ [Cache] –¢—Ä–µ–∫ "${title}" —É—Å–ø–µ—à–Ω–æ –∑–∞–∫—ç—à–∏—Ä–æ–≤–∞–Ω.`);
                    }
                } catch (e) {
                    console.error(`‚ùå [Cache] –û—à–∏–±–∫–∞ –ø—Ä–∏ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–∏ —Ç—Ä–µ–∫–∞ "${title}":`, e.message);
                }
            }
        })().finally(() => {
            if (fs.existsSync(tempFilePath)) {
                fs.promises.unlink(tempFilePath).catch(err => console.error("–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞:", err));
            }
        });
        
    } catch (err) {
        let userErrorMessage = `‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å —Ç—Ä–µ–∫: "${title}"`;
        const errorDetails = err.stderr || err.message || ''; // stderr –±—É–¥–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å –¥–µ—Ç–∞–ª—å–Ω—ã–π –ª–æ–≥
        if (err.name === 'TimeoutError' || errorDetails.includes('timed out')) {
            userErrorMessage += '. –ü—Ä–∏—á–∏–Ω–∞: —Ç–∞–π–º–∞—É—Ç.';
        } else if (errorDetails.includes('exit code 101')) {
            userErrorMessage += '. –ü—Ä–∏—á–∏–Ω–∞: —Å–µ—Ç–µ–≤–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏.';
        }
        // –í—ã–≤–æ–¥–∏–º –≤ –∫–æ–Ω—Å–æ–ª—å –ø–æ–ª–Ω—ã–π –¥–µ—Ç–∞–ª—å–Ω—ã–π –ª–æ–≥ –æ—à–∏–±–∫–∏
        console.error(`‚ùå –û—à–∏–±–∫–∞ –≤–æ—Ä–∫–µ—Ä–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ "${title}":\n---STDERR---\n${errorDetails}\n------------`);
        if (statusMessage) {
            await bot.telegram.editMessageText(userId, statusMessage.message_id, undefined, userErrorMessage).catch(() => {});
        } else {
            await safeSendMessage(userId, userErrorMessage);
        }
        
        if (tempFilePath && fs.existsSync(tempFilePath)) {
            await fs.promises.unlink(tempFilePath).catch(() => {});
        }
    }
}

export const downloadQueue = new TaskQueue({
    maxConcurrent: 1,
    taskProcessor: trackDownloadProcessor
});

export async function enqueue(ctx, userId, url) {
    let statusMessage = null;
    try {
        await resetDailyLimitIfNeeded(userId);
        let user = await getUser(userId);

        if (user.downloads_today >= user.premium_limit) {
            let message = T('limitReached');
            let bonusMessageText = '';
            if (!user.subscribed_bonus_used) {
                const cleanUsername = CHANNEL_USERNAME.replace('@', '');
                const channelLink = `[${CHANNEL_USERNAME}](https://t.me/${cleanUsername})`;
                bonusMessageText = `\n\nüéÅ –£ —Ç–µ–±—è –µ—Å—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã–π –±–æ–Ω—É—Å! –ü–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ ${channelLink} –∏ –ø–æ–ª—É—á–∏ *7 –¥–Ω–µ–π —Ç–∞—Ä–∏—Ñ–∞ Plus*.`;
            }
            message = message.replace('{bonus_message}', bonusMessageText);
            const extra = { parse_mode: 'Markdown' };
            if (!user.subscribed_bonus_used) {
                extra.reply_markup = { inline_keyboard: [[ Markup.button.callback('‚úÖ –Ø –ø–æ–¥–ø–∏—Å–∞–ª—Å—è, –∑–∞–±—Ä–∞—Ç—å –±–æ–Ω—É—Å', 'check_subscription') ]] };
            }
            return await safeSendMessage(userId, message, extra);
        }

        statusMessage = await safeSendMessage(userId, 'üîç –ü–æ–ª—É—á–∞—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç—Ä–µ–∫–µ...');
        
        const infoArgs = [
            url,
            '--dump-single-json',
            '--retries', '2',
            '--socket-timeout', '20',
            '--user-agent', FAKE_USER_AGENT,
        ];
        
        if (PROXY_URL) {
            infoArgs.push('--proxy', PROXY_URL);
        }
        
        const { stdout } = await spawnAsync('yt-dlp', infoArgs);
        const info = JSON.parse(stdout);
        if (!info) throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ');
        
        const source = url.includes('spotify.com') ? 'spotify' : 'soundcloud';
        const isPlaylist = Array.isArray(info.entries);
        const entries = isPlaylist ? info.entries : [info];

        let tracksToProcess = entries
            .filter(e => e && (e.webpage_url || e.url))
            .map(e => ({
                url: e.webpage_url || e.url, 
                source: source,
                spotifyUrl: source === 'spotify' ? (e.webpage_url || e.url) : null,
                metadata: {
                    id: e.id,
                    title: sanitizeFilename(e.title || 'Unknown Title').slice(0, TRACK_TITLE_LIMIT),
                    uploader: e.uploader || e.artist || 'Unknown Artist',
                    duration: e.duration,
                    thumbnail: e.thumbnail,
                }
            }));
        
        if (tracksToProcess.length === 0) {
            return await safeSendMessage(userId, '–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —Ç—Ä–µ–∫–∏ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏.');
        }

        if (isPlaylist) {
            let playlistLimit = Infinity;
            let originalCount = tracksToProcess.length;
            if (user.premium_limit <= 10) playlistLimit = 5;
            else if (user.premium_limit >= 10000) playlistLimit = UNLIMITED_PLAYLIST_LIMIT;
            
            const remainingDailyLimit = user.premium_limit - user.downloads_today;
            const limitToProcess = Math.min(originalCount, playlistLimit, remainingDailyLimit);

            if (limitToProcess < originalCount) {
                 await safeSendMessage(userId, `‚ÑπÔ∏è –í –ø–ª–µ–π–ª–∏—Å—Ç–µ ${originalCount} —Ç—Ä–µ–∫–æ–≤. –° —É—á–µ—Ç–æ–º –≤–∞—à–µ–≥–æ —Ç–∞—Ä–∏—Ñ–∞ –∏ –¥–Ω–µ–≤–Ω–æ–≥–æ –ª–∏–º–∏—Ç–∞ –±—É–¥–µ—Ç –∑–∞–≥—Ä—É–∂–µ–Ω–æ: ${limitToProcess}.`);
            }
            tracksToProcess.length = limitToProcess;
        }
        
        if (statusMessage) {
            await bot.telegram.editMessageText(userId, statusMessage.message_id, undefined, 'üîÑ –ü—Ä–æ–≤–µ—Ä—è—é –∫—ç—à...').catch(() => {});
        }

        const tasksToDownload = [];
        let sentFromCacheCount = 0;

        for (const track of tracksToProcess) {
            const cacheKey = track.spotifyUrl || track.url;
            const cached = await findCachedTrack(cacheKey);

            if (cached) {
                user = await getUser(userId);
                if (user.downloads_today >= user.premium_limit) break;
                try {
                    await bot.telegram.sendAudio(userId, cached.fileId, { title: track.metadata.title, performer: track.metadata.uploader });
                    await incrementDownloadsAndSaveTrack(userId, track.metadata.title, cached.fileId, cacheKey);
                    sentFromCacheCount++;
                } catch (err) {
                    if (err.response?.error_code === 403) { await updateUserField(userId, 'active', false); return; }
                    else if (err.description?.includes('FILE_REFERENCE_EXPIRED')) tasksToDownload.push(track);
                    else console.error(`‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∏–∑ –∫—ç—à–∞ –¥–ª—è ${userId}: ${err.message}`);
                }
            } else {
                tasksToDownload.push(track);
            }
        }
        
       let finalMessage = '';
        if (sentFromCacheCount > 0) {
            finalMessage += `‚úÖ ${sentFromCacheCount} —Ç—Ä–µ–∫(–æ–≤) –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –∏–∑ –∫—ç—à–∞.\n`;
        }
        
        if (tasksToDownload.length > 0) {
            user = await getUser(userId);
            const remainingLimit = user.premium_limit - user.downloads_today;
            
            if (remainingLimit > 0) {
                const tasksToReallyDownload = tasksToDownload.slice(0, remainingLimit);
                finalMessage += `‚è≥ ${tasksToReallyDownload.length} —Ç—Ä–µ–∫(–æ–≤) –¥–æ–±–∞–≤–ª–µ–Ω–æ –≤ –æ—á–µ—Ä–µ–¥—å. –í—ã –ø–æ–ª—É—á–∏—Ç–µ –∏—Ö –ø–æ –º–µ—Ä–µ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏.`;
                
                if (isPlaylist) await logEvent(userId, 'download_playlist');
                
                for (const track of tasksToReallyDownload) {
                    downloadQueue.add({ userId, ...track, priority: user.premium_limit });
                    if (!isPlaylist) await logEvent(userId, 'download');
                }
            } else if (sentFromCacheCount === 0) {
                finalMessage += `üö´ –í–∞—à –¥–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç –∏—Å—á–µ—Ä–ø–∞–Ω.`;
            }
        }
        
        if (statusMessage) {
            await bot.telegram.editMessageText(userId, statusMessage.message_id, undefined, finalMessage || "–í—Å–µ —Ç—Ä–µ–∫–∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã.").catch(() => {});
        } else if (finalMessage) {
            await safeSendMessage(userId, finalMessage);
        }

    } catch (err) {
        const errorMessage = err.stderr || err.message || '';
        let userMessage = `‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å—Å—ã–ª–∫–∏.`;
        if (err.name === 'TimeoutError' || errorMessage.includes('timed out')) {
            console.error(`‚ùå –¢–∞–π–º–∞—É—Ç –≤ enqueue –¥–ª—è ${userId}:`, errorMessage);
            userMessage = '‚ùå –û—à–∏–±–∫–∞: –°–µ—Ä–≤–∏—Å (SoundCloud/Spotify) –æ—Ç–≤–µ—á–∞–µ—Ç —Å–ª–∏—à–∫–æ–º –¥–æ–ª–≥–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.';
        } else if (errorMessage.includes('404: Not Found') || errorMessage.includes('403: Forbidden')) {
            console.warn(`[User Error] –¢—Ä–µ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω (404/403) –¥–ª—è ${userId}.`);
            userMessage = '‚ùå –¢—Ä–µ–∫ –ø–æ —ç—Ç–æ–π —Å—Å—ã–ª–∫–µ –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –¥–æ—Å—Ç—É–ø –∫ –Ω–µ–º—É –æ–≥—Ä–∞–Ω–∏—á–µ–Ω.';
        } else {
            console.error(`‚ùå –ì–ª–æ–±–∞–ª—å–Ω–∞—è –æ—à–∏–±–∫–∞ –≤ enqueue –¥–ª—è ${userId}:`, err);
            try {
                const adminErrorMessage = `üî¥ **–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏!**\n\n` +
                                          `**–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:** \`${userId}\`\n**URL:** \`${url}\`\n\n` +
                                          `**–¢–µ–∫—Å—Ç –æ—à–∏–±–∫–∏:**\n\`\`\`\n${errorMessage.slice(0, 1000)}\n\`\`\``;
                await bot.telegram.sendMessage(ADMIN_ID, adminErrorMessage, { parse_mode: 'Markdown' });
            } catch (adminNotifyError) {
                console.error("!! –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ –∞–¥–º–∏–Ω—É:", adminNotifyError.message);
            }
        }
        if (statusMessage) {
            await bot.telegram.editMessageText(userId, statusMessage.message_id, undefined, userMessage).catch(() => {});
        } else {
            await safeSendMessage(userId, userMessage);
        }
    }
}