// services/downloadManager.js (–§–ò–ù–ê–õ–¨–ù–ê–Ø –í–ï–†–°–ò–Ø - –°–¢–ê–†–ê–Ø –õ–û–ì–ò–ö–ê –° –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø–ú–ò, SPOTIFY –û–¢–ö–õ–Æ–ß–ï–ù)

import { STORAGE_CHANNEL_ID, CHANNEL_USERNAME, PROXY_URL } from '../config.js';
import { Markup } from 'telegraf';
import path from 'path';
import fs from 'fs';
import ytdl from 'youtube-dl-exec';
import { fileURLToPath } from 'url';
import crypto from 'crypto';
import { bot } from '../bot.js';
import { T } from '../config/texts.js';
import { TaskQueue } from '../lib/TaskQueue.js';
import {
    getUser, resetDailyLimitIfNeeded, logEvent, updateUserField,
    findCachedTrack, cacheTrack, incrementDownloadsAndSaveTrack
} from '../db.js';
// import { spotifyEnqueue } from './spotifyManager.js'; // <-- Spotify –∏–º–ø–æ—Ä—Ç —É–¥–∞–ª–µ–Ω

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(path.dirname(__filename));
const cacheDir = path.join(__dirname, 'cache');
if (!fs.existsSync(cacheDir)) fs.mkdirSync(cacheDir);

const YTDL_TIMEOUT = 180;
const MAX_FILE_SIZE_BYTES = 49 * 1024 * 1024;
const UNLIMITED_PLAYLIST_LIMIT = 100;
const FAKE_USER_AGENT = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36';

function sanitizeFilename(name) {
    return (name || 'track').replace(/[<>:"/\\|?*]+/g, '').trim();
}

async function safeSendMessage(userId, text, extra = {}) {
    try {
        return await bot.telegram.sendMessage(userId, text, extra);
    } catch (e) {
        if (e.response?.error_code === 403) await updateUserField(userId, 'active', false);
        return null;
    }
}

async function trackDownloadProcessor(task) {
    try {
        const { userId, source, url, originalUrl, metadata } = task;
        const { title, uploader, id: trackId, duration, thumbnail } = metadata;
        const roundedDuration = duration ? Math.round(duration) : undefined;
        let tempFilePath = null;
        let statusMessage = null;
        try {
            statusMessage = await safeSendMessage(userId, `‚è≥ –ù–∞—á–∏–Ω–∞—é —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ —Ç—Ä–µ–∫–∞: "${title}"`);
            console.log(`[Worker] –ü–æ–ª—É—á–µ–Ω–∞ –∑–∞–¥–∞—á–∞ –¥–ª—è "${title}" (–∏—Å—Ç–æ—á–Ω–∏–∫: ${source}).`);
            const tempFileName = `${trackId || 'track'}-${crypto.randomUUID()}.mp3`;
            tempFilePath = path.join(cacheDir, tempFileName);
            await ytdl(url, {
                output: tempFilePath, extractAudio: true, audioFormat: 'mp3',
                embedThumbnail: true, retries: 3, "socket-timeout": YTDL_TIMEOUT,
                'user-agent': FAKE_USER_AGENT, proxy: PROXY_URL || undefined,
            });
            if (!fs.existsSync(tempFilePath)) throw new Error(`–§–∞–π–ª –Ω–µ –±—ã–ª —Å–æ–∑–¥–∞–Ω.`);
            const stats = await fs.promises.stat(tempFilePath);
            if (stats.size > MAX_FILE_SIZE_BYTES) throw new Error(`FILE_TOO_LARGE`);
            if (statusMessage) await bot.telegram.editMessageText(userId, statusMessage.message_id, undefined, `‚úÖ –°–∫–∞—á–∞–ª. –û—Ç–ø—Ä–∞–≤–ª—è—é...`).catch(() => {});
            const sentToUserMessage = await bot.telegram.sendAudio(userId, { source: fs.createReadStream(tempFilePath) }, {
                title, performer: uploader || 'Unknown Artist', duration: roundedDuration
            });
            if (statusMessage) await bot.telegram.deleteMessage(userId, statusMessage.message_id).catch(() => {});
            const cacheKey = originalUrl || url;
            if (sentToUserMessage?.audio?.file_id) {
                await incrementDownloadsAndSaveTrack(userId, title, sentToUserMessage.audio.file_id, cacheKey);
                if (STORAGE_CHANNEL_ID) {
                    try {
                        const sentToStorage = await bot.telegram.sendAudio(STORAGE_CHANNEL_ID, sentToUserMessage.audio.file_id);
                        await cacheTrack({ url: cacheKey, fileId: sentToStorage.audio.file_id, title, artist: uploader, duration: roundedDuration, thumbnail });
                        console.log(`‚úÖ [Cache] –¢—Ä–µ–∫ "${title}" —É—Å–ø–µ—à–Ω–æ –∑–∞–∫—ç—à–∏—Ä–æ–≤–∞–Ω.`);
                    } catch (e) { console.error(`‚ùå [Cache] –û—à–∏–±–∫–∞ –ø—Ä–∏ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–∏ —Ç—Ä–µ–∫–∞ "${title}":`, e.message); }
                }
            }
        } catch (err) {
            const errorDetails = err.stderr || err.message || '';
            let userErrorMessage = `‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å —Ç—Ä–µ–∫: "${title}"`;
            if (errorDetails.includes('FILE_TOO_LARGE')) userErrorMessage += '. –û–Ω —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π.';
            else if (errorDetails.includes('timed out')) userErrorMessage += '. –û—à–∏–±–∫–∞ —Å–µ—Ç–∏.';
            console.error(`‚ùå –û—à–∏–±–∫–∞ –≤–æ—Ä–∫–µ—Ä–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ "${title}":`, errorDetails);
            if (statusMessage) await bot.telegram.editMessageText(userId, statusMessage.message_id, undefined, userErrorMessage).catch(() => {});
            else await safeSendMessage(userId, userErrorMessage);
        } finally {
            if (tempFilePath && fs.existsSync(tempFilePath)) {
                fs.promises.unlink(tempFilePath).catch(e => console.error("–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞:", e));
            }
        }
    } catch (e) {
        console.error('üî¥ –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –ù–ï–ü–ï–†–ï–•–í–ê–ß–ï–ù–ù–ê–Ø –û–®–ò–ë–ö–ê –í –í–û–†–ö–ï–†–ï!', e);
    }
}

export const downloadQueue = new TaskQueue({
    maxConcurrent: 1,
    taskProcessor: trackDownloadProcessor
});

export function enqueue(ctx, userId, url) {
    (async () => {
        let statusMessage = null;
        try {
            // ==========================================================
            //         –ò–ó–ú–ï–ù–ï–ù–ò–ï: –£–±–∏—Ä–∞–µ–º –≤—ã–∑–æ–≤ Spotify
            // ==========================================================
            // –ú—ã –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ —ç—Ç–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ —É–∂–µ —Å–¥–µ–ª–∞–Ω–∞ –≤ bot.js,
            // –Ω–æ –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π —Å—Ç–∞–≤–∏–º –∑–¥–µ—Å—å –∑–∞–≥–ª—É—à–∫—É.
            if (url.includes('spotify.com')) {
                return; 
            }
            
            await resetDailyLimitIfNeeded(userId);
            let user = await getUser(userId);
            if (user.downloads_today >= user.premium_limit) {
                let message = T('limitReached');
                let bonusMessageText = '';
                if (!user.subscribed_bonus_used) {
                    const cleanUsername = CHANNEL_USERNAME.replace('@', '');
                    const channelLink = `[${CHANNEL_USERNAME}](https://t.me/${cleanUsername})`;
                    bonusMessageText = `\n\nüéÅ –£ —Ç–µ–±—è –µ—Å—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã–π –±–æ–Ω—É—Å! –ü–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ ${channelLink} –∏ –ø–æ–ª—É—á–∏ *7 –¥–Ω–µ–π —Ç–∞—Ä–∏—Ñ–∞ Plus*.`;
                }
                message = message.replace('{bonus_message}', bonusMessageText);
                const extra = { parse_mode: 'Markdown' };
                if (!user.subscribed_bonus_used) {
                    extra.reply_markup = { inline_keyboard: [[ Markup.button.callback('‚úÖ –Ø –ø–æ–¥–ø–∏—Å–∞–ª—Å—è, –∑–∞–±—Ä–∞—Ç—å –±–æ–Ω—É—Å', 'check_subscription') ]] };
                }
                await safeSendMessage(userId, message, extra);
                return;
            }
            statusMessage = await safeSendMessage(userId, 'üîç –ü–æ–ª—É—á–∞—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç—Ä–µ–∫–µ...');
            const info = await ytdl(url, {
                dumpSingleJson: true, retries: 2, "socket-timeout": YTDL_TIMEOUT,
                'user-agent': FAKE_USER_AGENT, proxy: PROXY_URL || undefined,
            });
            if (!info) throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ');
            const isPlaylist = Array.isArray(info.entries); 
            const entries = isPlaylist ? info.entries : [info];
            let tracksToProcess = entries.filter(e => e && (e.webpage_url || e.url)).map(e => ({
                url: e.webpage_url || e.url, originalUrl: e.webpage_url || e.url, 
                source: 'soundcloud', metadata: {
                    id: e.id, title: sanitizeFilename(e.title || 'Unknown Title'),
                    uploader: e.uploader || 'Unknown Artist', duration: e.duration, thumbnail: e.thumbnail,
                }
            }));
            if (tracksToProcess.length === 0) {
                await safeSendMessage(userId, '–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —Ç—Ä–µ–∫–∏ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏.');
                return;
            }
            if (isPlaylist) {
                const originalCount = tracksToProcess.length;
                let playlistLimit = UNLIMITED_PLAYLIST_LIMIT;
                if (user.premium_limit <= 10) playlistLimit = 5;
                const remainingDailyLimit = user.premium_limit - user.downloads_today;
                const limitToProcess = Math.min(originalCount, playlistLimit, remainingDailyLimit);
                if (limitToProcess < originalCount) {
                     await safeSendMessage(userId, `‚ÑπÔ∏è –í –ø–ª–µ–π–ª–∏—Å—Ç–µ ${originalCount} —Ç—Ä–µ–∫–æ–≤. –° —É—á–µ—Ç–æ–º –≤–∞—à–µ–≥–æ —Ç–∞—Ä–∏—Ñ–∞ –∏ –¥–Ω–µ–≤–Ω–æ–≥–æ –ª–∏–º–∏—Ç–∞ –±—É–¥–µ—Ç –∑–∞–≥—Ä—É–∂–µ–Ω–æ: ${limitToProcess}.`);
                }
                tracksToProcess = tracksToProcess.slice(0, limitToProcess);
            }
            if (statusMessage) await bot.telegram.editMessageText(userId, statusMessage.message_id, undefined, 'üîÑ –ü—Ä–æ–≤–µ—Ä—è—é –∫—ç—à...').catch(() => {});
            const tasksToDownload = [];
            let sentFromCacheCount = 0;
            for (const track of tracksToProcess) {
                const cached = await findCachedTrack(track.url);
                if (cached) {
                    user = await getUser(userId);
                    if (user.downloads_today >= user.premium_limit) break;
                    try {
                        // –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ –æ—à–∏–±–∫–∞: –≤ —Å—Ç–∞—Ä–æ–º –∫–æ–¥–µ cached –Ω–µ –∏–º–µ–ª metadata
                        await bot.telegram.sendAudio(userId, cached.fileId, { title: cached.trackName, performer: track.metadata.uploader });
                        await incrementDownloadsAndSaveTrack(userId, cached.trackName, cached.fileId, track.url);
                        sentFromCacheCount++;
                    } catch (err) {
                        if (err.description?.includes('FILE_REFERENCE_EXPIRED')) tasksToDownload.push(track);
                        else console.error(`‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∏–∑ –∫—ç—à–∞ –¥–ª—è ${userId}:`, err.message);
                    }
                } else {
                    tasksToDownload.push(track);
                }
            }
            let finalMessage = '';
            if (sentFromCacheCount > 0) finalMessage += `‚úÖ ${sentFromCacheCount} —Ç—Ä–µ–∫(–æ–≤) –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –∏–∑ –∫—ç—à–∞.\n`;
            if (tasksToDownload.length > 0) {
                user = await getUser(userId);
                const remainingLimit = user.premium_limit - user.downloads_today;
                if (remainingLimit > 0) {
                    const tasksToReallyDownload = tasksToDownload.slice(0, remainingLimit);
                    finalMessage += `‚è≥ ${tasksToReallyDownload.length} —Ç—Ä–µ–∫(–æ–≤) –¥–æ–±–∞–≤–ª–µ–Ω–æ –≤ –æ—á–µ—Ä–µ–¥—å.`;
                    for (const task of tasksToReallyDownload) {
                        downloadQueue.add({ userId, ...task, priority: user.premium_limit });
                    }
                } else if (sentFromCacheCount === 0) { finalMessage += `üö´ –í–∞—à –¥–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç –∏—Å—á–µ—Ä–ø–∞–Ω.`; }
            }
            if (statusMessage) await bot.telegram.editMessageText(userId, statusMessage.message_id, undefined, finalMessage || "–í—Å–µ —Ç—Ä–µ–∫–∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã.").catch(() => {});
            else if (finalMessage) await safeSendMessage(userId, finalMessage);
        } catch (err) {
            const errorMessage = err.stderr || err.message || '';
            let userMessage = `‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å—Å—ã–ª–∫–∏.`;
            if (errorMessage.includes('timed out')) userMessage = '‚ùå –û—à–∏–±–∫–∞ —Å–µ—Ç–∏ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ç—Ä–µ–∫–µ.';
            else if (errorMessage.includes('404')) userMessage = '‚ùå –¢—Ä–µ–∫ –ø–æ —ç—Ç–æ–π —Å—Å—ã–ª–∫–µ –Ω–µ –Ω–∞–π–¥–µ–Ω.';
            else console.error(`‚ùå –ì–ª–æ–±–∞–ª—å–Ω–∞—è –æ—à–∏–±–∫–∞ –≤ enqueue –¥–ª—è ${userId}:`, err);
            if (statusMessage) await bot.telegram.editMessageText(userId, statusMessage.message_id, undefined, userMessage).catch(() => {});
            else await safeSendMessage(userId, userMessage);
        }
    })();
}