// services/downloadManager.js (—É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è —Å –ø–ª–µ–π–ª–∏—Å—Ç–∞–º–∏)

import ytdl from 'youtube-dl-exec';
import path from 'path';
import fs from 'fs';
import os from 'os';
import crypto from 'crypto';
import ffmpegPath from 'ffmpeg-static';
import { fileURLToPath } from 'url';

import { bot } from '../bot.js';
import * as db from '../db.js';
import { TaskQueue } from '../lib/TaskQueue.js';
import { STORAGE_CHANNEL_ID, PROXY_URL } from '../config.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(path.dirname(__filename));

// ========================= –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø =========================
const cacheDir = path.join(os.tmpdir(), 'soundcloud-cache');
if (!fs.existsSync(cacheDir)) fs.mkdirSync(cacheDir, { recursive: true });

const MAX_FILE_SIZE = 49 * 1024 * 1024; // 49 –ú–ë
const MAX_CONCURRENT = 2; // –î–ª—è –±–µ—Å–ø–ª–∞—Ç–Ω–æ–≥–æ Render.com

// –õ–∏–º–∏—Ç—ã –ø–ª–µ–π–ª–∏—Å—Ç–æ–≤ –ø–æ —Ç–∞—Ä–∏—Ñ–∞–º
const PLAYLIST_LIMITS = {
  free: 10,
  plus: 30,
  pro: 100,
  unlimited: 200
};

// –ë–∞–∑–æ–≤—ã–µ –æ–ø—Ü–∏–∏ –¥–ª—è yt-dlp
const YTDL_OPTIONS = {
  'ffmpeg-location': ffmpegPath,
  'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
  'no-warnings': true,
  'socket-timeout': 60,
  proxy: PROXY_URL || undefined
};

// ========================= –£–¢–ò–õ–ò–¢–´ =========================

function sanitizeFilename(name) {
  return (name || 'track').replace(/[<>:"/\\|?*]+/g, '').trim() || 'track';
}

function getCacheKey(url) {
  try {
    const parsed = new URL(url);
    return `${parsed.hostname}${parsed.pathname}`;
  } catch {
    return url;
  }
}

function getPlaylistLimit(dailyLimit) {
  if (dailyLimit >= 10000) return PLAYLIST_LIMITS.unlimited;
  if (dailyLimit >= 100) return PLAYLIST_LIMITS.pro;
  if (dailyLimit >= 30) return PLAYLIST_LIMITS.plus;
  return PLAYLIST_LIMITS.free;
}

// ========================= –û–°–ù–û–í–ù–û–ô –í–û–†–ö–ï–† =========================

async function processDownload(task) {
  const { userId, url, metadata } = task;
  let tempFile = null;
  
  try {
    // 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à
    const cacheKey = getCacheKey(url);
    const cached = await db.findCachedTrack(cacheKey);
    
    if (cached?.fileId) {
      console.log(`[Cache HIT] ${cached.trackName}`);
      try {
        await bot.telegram.sendAudio(userId, cached.fileId, {
          title: cached.trackName,
          performer: cached.artist,
          duration: cached.duration
        });
        
        await db.incrementDownloadsAndSaveTrack(
          userId, 
          cached.trackName, 
          cached.fileId, 
          cacheKey
        );
        return;
      } catch (err) {
        if (err?.description?.includes('file_id')) {
          await db.deleteCachedTrack(cacheKey);
        }
      }
    }
    
    // 2. –ü–æ–ª—É—á–∞–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ (–µ—Å–ª–∏ –∏—Ö –Ω–µ—Ç)
    let info = metadata;
    if (!info) {
      console.log(`[Download] –ü–æ–ª—É—á–∞—é –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ: ${url}`);
      info = await ytdl(url, {
        'dump-single-json': true,
        'no-playlist': true,
        ...YTDL_OPTIONS
      });
    }
    
    if (!info) throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ');
    
    const title = sanitizeFilename(info.title || 'Unknown');
    const artist = info.uploader || 'Unknown Artist';
    const duration = Math.round(info.duration || 0);
    
    // 3. –°–∫–∞—á–∏–≤–∞–µ–º —Ñ–∞–π–ª
    const tempFileName = `${crypto.randomUUID()}.mp3`;
    tempFile = path.join(cacheDir, tempFileName);
    
    console.log(`[Download] –°–∫–∞—á–∏–≤–∞—é: ${title}`);
    await ytdl(url, {
      output: tempFile,
      'extract-audio': true,
      'audio-format': 'mp3',
      'audio-quality': 5,
      ...YTDL_OPTIONS
    });
    
    // 4. –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–º–µ—Ä
    const stats = await fs.promises.stat(tempFile);
    if (stats.size > MAX_FILE_SIZE) {
      throw new Error('FILE_TOO_LARGE');
    }
    
    // 5. –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∏ –∫—ç—à–∏—Ä—É–µ–º
    let fileId = null;
    
    if (STORAGE_CHANNEL_ID) {
      try {
        const stored = await bot.telegram.sendAudio(
          STORAGE_CHANNEL_ID,
          { source: fs.createReadStream(tempFile), filename: `${title}.mp3` },
          { title, performer: artist, duration }
        );
        fileId = stored.audio?.file_id;
      } catch (err) {
        console.error('[Storage] –û—à–∏–±–∫–∞:', err.message);
      }
    }
    
    if (fileId) {
      await bot.telegram.sendAudio(userId, fileId, {
        title,
        performer: artist,
        duration
      });
    } else {
      const sent = await bot.telegram.sendAudio(
        userId,
        { source: fs.createReadStream(tempFile), filename: `${title}.mp3` },
        { title, performer: artist, duration }
      );
      fileId = sent.audio?.file_id;
    }
    
    if (fileId) {
      await db.cacheTrack({
        url: cacheKey,
        fileId,
        title,
        artist,
        duration
      });
      
      await db.incrementDownloadsAndSaveTrack(userId, title, fileId, cacheKey);
    }
    
  } catch (err) {
    console.error(`[Download] –û—à–∏–±–∫–∞:`, err.message);
    
    let errorMsg = '‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å —Ç—Ä–µ–∫';
    if (err.message === 'FILE_TOO_LARGE') errorMsg = '‚ùå –§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π';
    else if (err.message?.includes('404')) errorMsg = '‚ùå –¢—Ä–µ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω';
    
    await bot.telegram.sendMessage(userId, errorMsg).catch(() => {});
    
  } finally {
    if (tempFile) {
      fs.promises.unlink(tempFile).catch(() => {});
    }
  }
}

// ========================= –û–ß–ï–†–ï–î–¨ =========================

export const downloadQueue = new TaskQueue({
  maxConcurrent: MAX_CONCURRENT,
  taskProcessor: processDownload
});

// ========================= –ì–õ–ê–í–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø =========================

export async function enqueue(ctx, userId, url) {
  try {
    // 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –ª–∏–º–∏—Ç–æ–≤
    const user = await db.getUser(userId);
    if (user.downloads_today >= user.premium_limit) {
      await bot.telegram.sendMessage(userId, '‚ùå –î–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç –∏—Å—á–µ—Ä–ø–∞–Ω');
      return;
    }
    
    const remaining = user.premium_limit - user.downloads_today;
    const playlistLimit = Math.min(getPlaylistLimit(user.premium_limit), remaining);
    
    // 2. –ü–æ–ª—É—á–∞–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ (—Å —É—á–µ—Ç–æ–º –ø–ª–µ–π–ª–∏—Å—Ç–æ–≤)
    console.log(`[Enqueue] –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é URL: ${url}`);
    const info = await ytdl(url, {
      'dump-single-json': true,
      'playlist-end': playlistLimit,
      ...YTDL_OPTIONS
    });
    
    if (!info) {
      throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ');
    }
    
    // 3. –û–ø—Ä–µ–¥–µ–ª—è–µ–º, —ç—Ç–æ –ø–ª–µ–π–ª–∏—Å—Ç –∏–ª–∏ –æ–¥–∏–Ω–æ—á–Ω—ã–π —Ç—Ä–µ–∫
    const isPlaylist = Array.isArray(info.entries) && info.entries.length > 1;
    const tracks = isPlaylist ? info.entries : [info];
    
    // 4. –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –ø–ª–µ–π–ª–∏—Å—Ç–µ
    if (isPlaylist) {
      await bot.telegram.sendMessage(
        userId,
        `üìã –û–±–Ω–∞—Ä—É–∂–µ–Ω –ø–ª–µ–π–ª–∏—Å—Ç\n` +
        `üìä –¢—Ä–µ–∫–æ–≤: ${tracks.length}/${info.entries.length}\n` +
        `‚è≥ –ù–∞—á–∏–Ω–∞—é –æ–±—Ä–∞–±–æ—Ç–∫—É...`
      );
    }
    
    // 5. –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ç—Ä–µ–∫–∏
    let sentFromCache = 0;
    let addedToQueue = 0;
    
    for (const track of tracks.slice(0, playlistLimit)) {
      if (!track) continue;
      
      const trackUrl = track.webpage_url || track.url || url;
      const cacheKey = getCacheKey(trackUrl);
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à
      const cached = await db.findCachedTrack(cacheKey);
      
      if (cached?.fileId) {
        try {
          await bot.telegram.sendAudio(userId, cached.fileId, {
            title: cached.trackName,
            performer: cached.artist,
            duration: cached.duration
          });
          
          await db.incrementDownloadsAndSaveTrack(
            userId,
            cached.trackName,
            cached.fileId,
            cacheKey
          );
          
          sentFromCache++;
          continue;
        } catch (err) {
          if (err?.description?.includes('file_id')) {
            await db.deleteCachedTrack(cacheKey);
          }
        }
      }
      
      // –î–æ–±–∞–≤–ª—è–µ–º –≤ –æ—á–µ—Ä–µ–¥—å
      downloadQueue.add({
        userId,
        url: trackUrl,
        metadata: track,
        priority: user.premium_limit || 0
      });
      addedToQueue++;
    }
    
    // 6. –ò—Ç–æ–≥–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
    let statusMsg = '';
    if (sentFromCache > 0) {
      statusMsg += `‚úÖ –ò–∑ –∫—ç—à–∞: ${sentFromCache}\n`;
    }
    if (addedToQueue > 0) {
      statusMsg += `‚è≥ –í –æ—á–µ—Ä–µ–¥–∏: ${addedToQueue}\n`;
      statusMsg += `üìç –ü–æ–∑–∏—Ü–∏—è: ${downloadQueue.size}`;
    }
    
    if (statusMsg) {
      await bot.telegram.sendMessage(userId, statusMsg);
    }
    
  } catch (err) {
    console.error('[Enqueue] –û—à–∏–±–∫–∞:', err.message);
    await bot.telegram.sendMessage(userId, '‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏').catch(() => {});
  }
}

// ========================= –û–ß–ò–°–¢–ö–ê –ö–≠–®–ê =========================

setInterval(() => {
  fs.readdir(cacheDir, (err, files) => {
    if (err) return;
    
    const now = Date.now();
    files.forEach(file => {
      const filePath = path.join(cacheDir, file);
      fs.stat(filePath, (err, stats) => {
        if (!err && now - stats.mtimeMs > 1800000) {
          fs.unlink(filePath, () => {});
        }
      });
    });
  });
}, 1800000);

// ========================= –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø =========================

export function initializeDownloadManager() {
  console.log('[DownloadManager] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω');
  console.log(`[DownloadManager] –ú–∞–∫—Å. –∑–∞–≥—Ä—É–∑–æ–∫: ${MAX_CONCURRENT}`);
  console.log(`[DownloadManager] –•—Ä–∞–Ω–∏–ª–∏—â–µ: ${STORAGE_CHANNEL_ID ? '‚úÖ' : '‚ùå'}`);
}