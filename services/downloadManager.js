// services/downloadManager.js

import path from 'path';
import fs from 'fs';
import ytdl from 'youtube-dl-exec';
import { fileURLToPath } from 'url';
import crypto from 'crypto';
import pLimit from 'p-limit';

// <<< –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü—Ä–∞–≤–∏–ª—å–Ω—ã–µ, –ø—Ä—è–º—ã–µ –∏–º–ø–æ—Ä—Ç—ã >>>
import { bot } from '../bot.js';
import redisService from './redisClient.js';
import { T } from '../config/texts.js';
import { TaskQueue } from '../lib/TaskQueue.js';
import {
    getUser,
    resetDailyLimitIfNeeded,
    saveTrackForUser,
    logEvent,
    logUserActivity,
    incrementDownloads,
    updateUserField,
    findCachedTrack,
    cacheTrack
} from '../db.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(path.dirname(__filename));
const cacheDir = path.join(__dirname, 'cache');

const TELEGRAM_FILE_LIMIT_MB = 49;
const MAX_PLAYLIST_TRACKS_FREE = 10;
const TRACK_TITLE_LIMIT = 100;
const YTDL_TIMEOUT = 60; // 60 —Å–µ–∫—É–Ω–¥

// –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º ytdl –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö, —á—Ç–æ–±—ã –Ω–µ –ø–µ—Ä–µ–≥—Ä—É–∂–∞—Ç—å CPU
const ytdlLimit = pLimit(1);

function sanitizeFilename(name) {
    return (name || 'track').replace(/[<>:"/\\|?*]+/g, '').trim();
}

async function safeSendMessage(userId, text, extra = {}) {
    try {
        return await bot.telegram.sendMessage(userId, text, extra);
    } catch (e) {
        if (e.response?.error_code === 403) {
            console.warn(`[SafeSend] –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${userId} –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª –±–æ—Ç–∞.`);
            await updateUserField(userId, 'active', false);
        } else {
            console.error(`[SafeSend] –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è ${userId}:`, e.message);
        }
        return null;
    }
}

async function trackDownloadProcessor(task) {
    const { userId, url, trackName, trackId, uploader, playlistUrl } = task;
    let tempFilePath = null;
    let statusMessage = null;
    
    try {
        statusMessage = await safeSendMessage(userId, `‚è≥ –ù–∞—á–∏–Ω–∞—é –æ–±—Ä–∞–±–æ—Ç–∫—É —Ç—Ä–µ–∫–∞: "${trackName}"`);

        console.log(`[Worker] –ù–∞—á–∏–Ω–∞—é —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ: ${trackName}`);
        tempFilePath = path.join(cacheDir, `${trackId}-${crypto.randomUUID()}.mp3`);
        
        await ytdl(url, {
            extractAudio: true, audioFormat: 'mp3', output: tempFilePath,
            embedMetadata: true,
            postprocessorArgs: `-metadata artist="${uploader || 'SoundCloud'}" -metadata title="${trackName}"`,
            retries: 3, "socket-timeout": YTDL_TIMEOUT
        });
        
        if (!fs.existsSync(tempFilePath)) {
            throw new Error(`–§–∞–π–ª –Ω–µ –±—ã–ª —Å–æ–∑–¥–∞–Ω –ø–æ—Å–ª–µ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è: ${tempFilePath}`);
        }

        const stats = await fs.promises.stat(tempFilePath);
        if (stats.size / (1024 * 1024) > TELEGRAM_FILE_LIMIT_MB) {
            throw new Error(`–¢—Ä–µ–∫ "${trackName}" —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π (–±–æ–ª—å—à–µ ${TELEGRAM_FILE_LIMIT_MB} –ú–ë).`);
        }

        if (statusMessage) {
            await bot.telegram.editMessageText(userId, statusMessage.message_id, undefined, `‚úÖ –°–∫–∞—á–∞–ª. –û—Ç–ø—Ä–∞–≤–ª—è—é –≤–∞–º "${trackName}"...`).catch(() => {});
        }
        
        const sentMessage = await bot.telegram.sendAudio(userId, { source: fs.createReadStream(tempFilePath) }, {
             title: trackName, performer: uploader || 'SoundCloud'
        });
        
        if (statusMessage) {
            await bot.telegram.deleteMessage(userId, statusMessage.message_id).catch(() => {});
        }
        
        if (sentMessage?.audio?.file_id) {
            console.log(`[Worker] –¢—Ä–µ–∫ "${trackName}" –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω, –∫—ç—à–∏—Ä—É—é...`);
            await cacheTrack(url, sentMessage.audio.file_id, trackName);
            await saveTrackForUser(userId, trackName, sentMessage.audio.file_id);
            await incrementDownloads(userId, trackName, url);
        }
        
        if (playlistUrl) {
            const redisClient = redisService.getClient();
            const playlistKey = `playlist:${userId}:${playlistUrl}`;
            const remaining = await redisClient.decr(playlistKey);
            if (remaining <= 0) {
                await safeSendMessage(userId, '‚úÖ –í—Å–µ —Ç—Ä–µ–∫–∏ –∏–∑ –ø–ª–µ–π–ª–∏—Å—Ç–∞ –∑–∞–≥—Ä—É–∂–µ–Ω—ã.');
                await redisClient.del(playlistKey);
            }
        }
        
    } catch (err) {
        let userErrorMessage = `‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å —Ç—Ä–µ–∫: "${trackName}"`;
        const errorDetails = err.stderr || err.message || '';

        if (err.name === 'TimeoutError' || errorDetails.includes('timed out')) {
            userErrorMessage += '. –ü—Ä–∏—á–∏–Ω–∞: —Å–ª–∏—à–∫–æ–º –¥–æ–ª–≥–æ–µ —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ (—Ç–∞–π–º–∞—É—Ç).';
            console.error(`‚ùå –¢–∞–π–º–∞—É—Ç –≤–æ—Ä–∫–µ—Ä–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ "${trackName}"`);
        } else {
            console.error(`‚ùå –û—à–∏–±–∫–∞ –≤–æ—Ä–∫–µ—Ä–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ "${trackName}":`, errorDetails, err);
        }

        if (statusMessage) {
            await bot.telegram.editMessageText(userId, statusMessage.message_id, undefined, userErrorMessage).catch(() => {});
        } else {
            await safeSendMessage(userId, userErrorMessage);
        }
    } finally {
        if (tempFilePath && fs.existsSync(tempFilePath)) {
            await fs.promises.unlink(tempFilePath).catch(e => console.error(`–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª ${tempFilePath}:`, e));
        }
    }
}

export const downloadQueue = new TaskQueue({
    maxConcurrent: 4, // –û–ø—Ç–∏–º–∞–ª—å–Ω–æ –¥–ª—è –±–µ—Å–ø–ª–∞—Ç–Ω–æ–≥–æ —Ç–∞—Ä–∏—Ñ–∞
    taskProcessor: trackDownloadProcessor
});

export async function enqueue(ctx, userId, url) {
    let processingMessage = null;
    try {
        await logUserActivity(userId);
        await resetDailyLimitIfNeeded(userId);
        
        processingMessage = await safeSendMessage(userId, 'üîç –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é —Å—Å—ã–ª–∫—É...');
        
        // –û–±–æ—Ä–∞—á–∏–≤–∞–µ–º –≤—ã–∑–æ–≤ ytdl –≤ –Ω–∞—à –ª–∏–º–∏—Ç, —á—Ç–æ–±—ã –Ω–µ –ø–µ—Ä–µ–≥—Ä—É–∂–∞—Ç—å CPU –Ω–∞ —Å—Ç–∞—Ä—Ç–µ
        const info = await ytdlLimit(() => ytdl(url, { dumpSingleJson: true, retries: 2, "socket-timeout": YTDL_TIMEOUT }));
        
        if (!info) {
            throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –ø–æ —Å—Å—ã–ª–∫–µ.');
        }

        if (processingMessage) {
            await bot.telegram.deleteMessage(userId, processingMessage.message_id).catch(() => {});
            processingMessage = null;
        }

        // <<< –ò–°–ü–†–ê–í–õ–ï–ù–û: –ó–∞–ø—Ä–µ—Ç –ø–ª–µ–π–ª–∏—Å—Ç–æ–≤ –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –ø–∞–º—è—Ç–∏ –Ω–∞ –±–µ—Å–ø–ª–∞—Ç–Ω–æ–º —Ç–∞—Ä–∏—Ñ–µ >>>
        const isPlaylist = Array.isArray(info.entries) && info.entries.length > 0;
        
        if (isPlaylist) {
            console.warn(`[OPTIMIZATION] –û—Ç–∫–ª–æ–Ω–µ–Ω –ø–ª–µ–π–ª–∏—Å—Ç –æ—Ç ${userId} –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ —Ä–µ—Å—É—Ä—Å–æ–≤.`);
            await safeSendMessage(userId, '‚ÑπÔ∏è –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–ª–µ–π–ª–∏—Å—Ç–æ–≤ –≤—Ä–µ–º–µ–Ω–Ω–æ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∞ –¥–ª—è –ø–æ–≤—ã—à–µ–Ω–∏—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤–ª—è–π—Ç–µ —Ç—Ä–µ–∫–∏ –ø–æ –æ–¥–Ω–æ–π —Å—Å—ã–ª–∫–µ.');
            return;
        }

        let tracksToProcess = [{
            url: info.webpage_url || url, trackId: info.id,
            trackName: sanitizeFilename(info.title).slice(0, TRACK_TITLE_LIMIT),
            uploader: info.uploader || 'SoundCloud'
        }];
        
        const user = await getUser(userId);
        let remainingLimit = user.premium_limit - user.downloads_today;
        
        if (remainingLimit <= 0) {
            return await safeSendMessage(userId, T('limitReached'));
        }
        
        const tasksFromCache = [];
        const tasksToDownload = [];
        
        for (const track of tracksToProcess) {
            const cachedTrack = await findCachedTrack(track.url);
            if (cachedTrack) {
                tasksFromCache.push({ ...track, ...cachedTrack });
            } else {
                tasksToDownload.push(track);
            }
        }
        
        if (tasksFromCache.length > 0) {
            let sentFromCacheCount = 0;
            for (const track of tasksFromCache) {
                try {
                    await bot.telegram.sendAudio(userId, track.fileId, { caption: track.trackName, title: track.trackName });
                    await saveTrackForUser(userId, track.trackName, track.fileId);
                    await incrementDownloads(userId, track.trackName, track.url);
                    sentFromCacheCount++;
                } catch (err) {
                    if (err.response?.error_code === 403) { await updateUserField(userId, 'active', false); return; }
                    else if (err.description?.includes('FILE_REFERENCE_EXPIRED')) {
                        tasksToDownload.push(track);
                    } else {
                        console.error(`‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∏–∑ –∫—ç—à–∞ –¥–ª—è ${userId}: ${err.message}`);
                    }
                }
            }
            if (sentFromCacheCount > 0) {
                await safeSendMessage(userId, `‚úÖ ${sentFromCacheCount} —Ç—Ä–µ–∫(–æ–≤) –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –º–≥–Ω–æ–≤–µ–Ω–Ω–æ –∏–∑ –∫—ç—à–∞.`);
            }
        }
        
        if (tasksToDownload.length > 0) {
            const userAfterCache = await getUser(userId);
            const currentLimit = userAfterCache.premium_limit - userAfterCache.downloads_today;
            if (currentLimit <= 0) {
                return await safeSendMessage(userId, 'üö´ –í–∞—à –ª–∏–º–∏—Ç –∏—Å—á–µ—Ä–ø–∞–Ω —Ç—Ä–µ–∫–∞–º–∏ –∏–∑ –∫—ç—à–∞.');
            }

            const tasksToReallyDownload = tasksToDownload.slice(0, currentLimit);
            
            if (tasksToReallyDownload.length > 0) {
                await safeSendMessage(userId, `‚è≥ ${tasksToReallyDownload.length} —Ç—Ä–µ–∫(–æ–≤) –¥–æ–±–∞–≤–ª–µ–Ω–æ –≤ –æ—á–µ—Ä–µ–¥—å. –í—ã –ø–æ–ª—É—á–∏—Ç–µ –∏—Ö –ø–æ –º–µ—Ä–µ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏.`);
                
                for (const track of tasksToReallyDownload) {
                    downloadQueue.add({ userId, ...track, playlistUrl: null, priority: user.premium_limit });
                    await logEvent(userId, 'download');
                }
            }
        }
    } catch (err) {
        if (processingMessage) {
            await bot.telegram.deleteMessage(userId, processingMessage.message_id).catch(() => {});
        }

        const errorMessage = err.stderr || err.message || '';

        if (err.name === 'TimeoutError' || errorMessage.includes('timed out')) {
            console.error(`‚ùå –¢–∞–π–º–∞—É—Ç –≤ enqueue –¥–ª—è ${userId}:`, errorMessage);
            await safeSendMessage(userId, '‚ùå –û—à–∏–±–∫–∞: SoundCloud –æ—Ç–≤–µ—á–∞–µ—Ç —Å–ª–∏—à–∫–æ–º –¥–æ–ª–≥–æ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
        } else if (errorMessage.includes('404: Not Found')) {
            console.warn(`[User Error] –¢—Ä–µ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω (404) –¥–ª—è ${userId}.`);
            await safeSendMessage(userId, '‚ùå –¢—Ä–µ–∫ –ø–æ —ç—Ç–æ–π —Å—Å—ã–ª–∫–µ –Ω–µ –Ω–∞–π–¥–µ–Ω. –í–æ–∑–º–æ–∂–Ω–æ, –æ–Ω –±—ã–ª —É–¥–∞–ª–µ–Ω –∏–ª–∏ —Å—Å—ã–ª–∫–∞ –Ω–µ–≤–µ—Ä–Ω–∞.');
        } else {
            console.error(`‚ùå –ì–ª–æ–±–∞–ª—å–Ω–∞—è –æ—à–∏–±–∫–∞ –≤ enqueue –¥–ª—è ${userId}:`, err);
            await safeSendMessage(userId, `‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–µ–π —Å—Å—ã–ª–∫–∏.`);
        }
    }
}