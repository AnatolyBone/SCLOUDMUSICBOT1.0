// services/downloadManager.js (–û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–ê–Ø –í–ï–†–°–ò–Ø 2.0)

import fetch from 'node-fetch';
import pMap from 'p-map';
import { STORAGE_CHANNEL_ID, CHANNEL_USERNAME, PROXY_URL } from '../config.js';
import { Markup } from 'telegraf';
import path from 'path';
import ffmpegPath from 'ffmpeg-static';
import fs from 'fs';
import os from 'os';
import { fileURLToPath } from 'url';
import crypto from 'crypto';
import ytdl from 'youtube-dl-exec';
import got from 'got'; // npm install got

import { bot } from '../bot.js';
import { T } from '../config/texts.js';
import { TaskQueue } from '../lib/TaskQueue.js';
import * as db from '../db.js';
import { getSetting } from './settingsManager.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(path.dirname(__filename));

// ========================= CONFIGURATION =========================

const cacheDir = path.join(os.tmpdir(), 'cache');
if (!fs.existsSync(cacheDir)) fs.mkdirSync(cacheDir, { recursive: true });

const YTDL_TIMEOUT = 90; // –£–º–µ–Ω—å—à–µ–Ω–æ —Å 120
const MAX_FILE_SIZE_BYTES = 49 * 1024 * 1024;
const FAKE_USER_AGENT = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36';

// üî• –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–æ –¥–ª—è Render.com (–º–æ–∂–Ω–æ —É–≤–µ–ª–∏—á–∏—Ç—å –¥–æ 4 –ø—Ä–∏ –Ω–∞–ª–∏—á–∏–∏ RAM)
const MAX_CONCURRENT_DOWNLOADS = parseInt(process.env.MAX_CONCURRENT_DOWNLOADS, 10) || 2;

const FFMPEG_AVAILABLE =
  (!!ffmpegPath && fs.existsSync(ffmpegPath)) &&
  process.env.FFMPEG_AVAILABLE !== '0' &&
  process.env.FFMPEG_STATIC_SKIP_DOWNLOAD !== '1';

// üî• –ë–∞–∑–æ–≤—ã–µ –∞—Ä–≥—É–º–µ–Ω—Ç—ã youtube-dl (–æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω—ã)
export const YTDL_COMMON = {
  'user-agent': FAKE_USER_AGENT,
  proxy: PROXY_URL || undefined,
  retries: 2, // –£–º–µ–Ω—å—à–µ–Ω–æ —Å 3
  'socket-timeout': YTDL_TIMEOUT,
  'no-warnings': true,
  'no-check-certificate': true, // –£—Å–∫–æ—Ä—è–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ
  'prefer-free-formats': true, // –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç –æ—Ç–∫—Ä—ã—Ç—ã–º —Ñ–æ—Ä–º–∞—Ç–∞–º
  'extractor-args': 'soundcloud:client_id=a3e059563d7fd3372b49b37f00a00bcf', // –ü—É–±–ª–∏—á–Ω—ã–π client_id
};

// üî• –ê—Ä–≥—É–º–µ–Ω—Ç—ã –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è (–±–µ–∑ ffmpeg –µ—Å–ª–∏ –Ω–µ –Ω—É–∂–µ–Ω)
const YTDL_DOWNLOAD = {
  ...YTDL_COMMON,
  'ffmpeg-location': FFMPEG_AVAILABLE ? ffmpegPath : undefined,
  'extract-audio': true,
  'audio-format': 'mp3',
  'audio-quality': 0,
  'embed-thumbnail': true,
  'add-metadata': true,
  'format': 'bestaudio[ext=mp3]/bestaudio/best', // –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç –≥–æ—Ç–æ–≤–æ–º—É MP3
};

// ========================= HELPER FUNCTIONS =========================

function sanitizeFilename(name) {
  if (!name || typeof name !== 'string') return 'track';
  return name.replace(/[<>:"/\\|?*]+/g, '').trim().slice(0, 200) || 'track';
}

function getCacheKey(meta, fallbackUrl) {
  if (meta?.id) return `sc:${meta.id}`;
  if (meta?.title && meta?.uploader) {
    return `sc:${sanitizeFilename(meta.title)}_${sanitizeFilename(meta.uploader)}`.toLowerCase();
  }
  return fallbackUrl || 'unknown';
}

async function safeSendMessage(userId, text, extra = {}) {
  try {
    return await bot.telegram.sendMessage(userId, text, extra);
  } catch (e) {
    if (e.response?.error_code === 403) {
      try { 
        await db.updateUserField(userId, 'active', false); 
      } catch (dbErr) {
        console.error(`[DB] –î–µ–∞–∫—Ç–∏–≤–∞—Ü–∏—è user ${userId}:`, dbErr.message);
      }
    }
    return null;
  }
}

async function incrementDownload(userId, trackTitle, fileId, cacheKey) {
  if (typeof db.incrementDownloadsAndLogPg === 'function') {
    return await db.incrementDownloadsAndLogPg(userId, trackTitle, fileId, cacheKey);
  }
  return await db.incrementDownloadsAndSaveTrack(userId, trackTitle, fileId, cacheKey);
}

async function getUserUsage(userId) {
  if (typeof db.getUserUsage === 'function') return await db.getUserUsage(userId);
  if (typeof db.getUserLite === 'function') return await db.getUserLite(userId);
  return await db.getUser(userId);
}

function extractMetadataFromInfo(info) {
  const e = Array.isArray(info?.entries) ? info.entries[0] : info;
  if (!e) return null;

  const ext = e.ext || e.requested_downloads?.[0]?.ext || null;
  const acodec = e.acodec || e.requested_downloads?.[0]?.acodec || null;
  const filesize = e.filesize || e.filesize_approx || e.requested_downloads?.[0]?.filesize || null;

  return {
    id: e.id,
    title: sanitizeFilename(e.title || 'Unknown Title'),
    uploader: e.uploader || 'Unknown Artist',
    duration: e.duration ? Math.round(e.duration) : undefined,
    thumbnail: e.thumbnail,
    ext,
    acodec,
    filesize
  };
}

// üî• –ù–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è: –ø—Ä–æ–≤–µ—Ä–∫–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ URL
function isSafeUrl(url) {
  try {
    const parsed = new URL(url);
    if (!['http:', 'https:'].includes(parsed.protocol)) return false;
    
    const hostname = parsed.hostname.toLowerCase();
    const blockedHosts = ['localhost', '127.0.0.1', '0.0.0.0', '::1', '169.254.169.254'];
    if (blockedHosts.includes(hostname)) return false;
    if (/^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.)/.test(hostname)) return false;
    
    return true;
  } catch {
    return false;
  }
}

// üî• –£–ª—É—á—à–µ–Ω–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–∑–º–µ—Ä–∞ —Ñ–∞–π–ª–∞
async function checkFileSize(url) {
  try {
    let streamUrl = await ytdl(url, { 'get-url': true, ...YTDL_COMMON });
    if (Array.isArray(streamUrl)) streamUrl = streamUrl[0];
    
    if (!streamUrl || typeof streamUrl !== 'string') {
      return { ok: false, reason: 'NO_STREAM_URL' };
    }
    
    if (!isSafeUrl(streamUrl)) {
      console.warn('[Pre-flight] –ù–µ–±–µ–∑–æ–ø–∞—Å–Ω—ã–π URL');
      return { ok: false, reason: 'UNSAFE_URL' };
    }
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º got –≤–º–µ—Å—Ç–æ fetch (–±—ã—Å—Ç—Ä–µ–µ)
    const response = await got.head(streamUrl, {
      timeout: { request: 5000 },
      headers: { 'User-Agent': FAKE_USER_AGENT },
      throwHttpErrors: false
    });
    
    const size = parseInt(response.headers['content-length'], 10);
    
    if (!size) {
      console.warn('[Pre-flight] –†–∞–∑–º–µ—Ä –Ω–µ–∏–∑–≤–µ—Å—Ç–µ–Ω, –ø—Ä–æ–¥–æ–ª–∂–∞—é');
      return { ok: true, reason: 'SIZE_UNKNOWN' };
    }
    
    if (size > MAX_FILE_SIZE_BYTES) {
      console.warn(`[Pre-flight] –§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π: ${(size / 1024 / 1024).toFixed(2)} –ú–ë`);
      return { ok: false, reason: 'FILE_TOO_LARGE', size };
    }
    
    console.log(`[Pre-flight] ‚úÖ –†–∞–∑–º–µ—Ä: ${(size / 1024 / 1024).toFixed(2)} –ú–ë`);
    return { ok: true, size };
    
  } catch (e) {
    console.warn('[Pre-flight] –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏:', e.message);
    return { ok: true, reason: 'CHECK_FAILED' };
  }
}

// üî• –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –æ—á–∏—Å—Ç–∫–∞ –∫–µ—à–∞ (–æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–æ)
function startCacheCleanup() {
  const cleanupInterval = setInterval(async () => {
    try {
      const files = await fs.promises.readdir(cacheDir);
      const now = Date.now();
      let cleaned = 0;
      
      await Promise.all(files.map(async (file) => {
        try {
          const filePath = path.join(cacheDir, file);
          const stats = await fs.promises.stat(filePath);
          
          // –£–¥–∞–ª—è–µ–º —Ñ–∞–π–ª—ã —Å—Ç–∞—Ä—à–µ 30 –º–∏–Ω—É—Ç (–≤–º–µ—Å—Ç–æ 1 —á–∞—Å–∞)
          if (now - stats.mtimeMs > 1800000) {
            await fs.promises.unlink(filePath);
            cleaned++;
          }
        } catch {}
      }));
      
      if (cleaned > 0) {
        console.log(`[Cache Cleanup] üßπ –£–¥–∞–ª–µ–Ω–æ ${cleaned} —Ñ–∞–π–ª–æ–≤`);
      }
    } catch (err) {
      console.error('[Cache Cleanup] –û—à–∏–±–∫–∞:', err.message);
    }
  }, 1800000); // –ö–∞–∂–¥—ã–µ 30 –º–∏–Ω—É—Ç
  
  process.on('SIGTERM', () => clearInterval(cleanupInterval));
  process.on('SIGINT', () => clearInterval(cleanupInterval));
}

startCacheCleanup();

// ========================= CORE WORKER =========================

/**
 * üî• –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–´–ô –í–û–†–ö–ï–†
 * –ò–∑–º–µ–Ω–µ–Ω–∏—è:
 * - Streaming upload –≥–¥–µ –≤–æ–∑–º–æ–∂–Ω–æ
 * - –ú–µ–Ω—å—à–µ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã—Ö —Å—Ç–∞—Ç—É—Å–æ–≤
 * - –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∫–µ—à–∞
 */
export async function trackDownloadProcessor(task) {
  let tempFilePath = null;
  let statusMessage = null;
  const userId = parseInt(task.userId, 10);
  
  if (!userId || isNaN(userId)) {
    console.error('[Worker] Invalid userId:', task.userId);
    return;
  }

  try {
    // 1Ô∏è‚É£ –ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏–º–∏—Ç–æ–≤
    const usage = await getUserUsage(userId);
    if (!usage || usage.downloads_today >= usage.premium_limit) {
      await safeSendMessage(userId, T('limitReached'));
      return;
    }

    // 2Ô∏è‚É£ –ü–æ–ª—É—á–µ–Ω–∏–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö (–¢–û–õ–¨–ö–û –µ—Å–ª–∏ –∏—Ö –Ω–µ—Ç –≤ –∑–∞–¥–∞—á–µ)
    let metadata = task.metadata;
    let cacheKey = task.cacheKey;
    const url = task.url || task.originalUrl;

    if (!metadata) {
      console.log(`[Worker] –ü–æ–ª—É—á–∞—é –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –¥–ª—è: ${url}`);
      
      try {
        const info = await ytdl(url, { 
          'dump-single-json': true,
          'no-playlist': true, // üî• –í–∞–∂–Ω–æ: —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ç—Ä–µ–∫!
          ...YTDL_COMMON 
        });
        
        metadata = extractMetadataFromInfo(info);
        if (!metadata) throw new Error('META_MISSING');
        
        cacheKey = getCacheKey(metadata, url);
        
      } catch (ytdlErr) {
        console.error('[Worker] –û—à–∏–±–∫–∞ youtube-dl:', ytdlErr.stderr || ytdlErr.message);
        throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç—Ä–µ–∫–µ');
      }
    }

    const { title, uploader, id: trackId, duration, thumbnail } = metadata;

    // 3Ô∏è‚É£ –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–µ—à–∞ (–ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ –º–µ—Ç–æ–¥–æ–≤)
    const cacheChecks = await Promise.all([
      db.findCachedTrack(cacheKey),
      db.findCachedTrack(url),
      typeof db.findCachedTrackByMeta === 'function' 
        ? db.findCachedTrackByMeta({ title, artist: uploader, duration })
        : null
    ]);

    const cached = cacheChecks.find(c => c?.fileId);

    if (cached?.fileId) {
      console.log(`[Worker] ‚ö° –ö–µ—à-–ø–æ–ø–∞–¥–∞–Ω–∏–µ: "${title}"`);
      
      await bot.telegram.sendAudio(userId, cached.fileId, {
        title: cached.trackName || title,
        performer: cached.artist || uploader,
        duration
      });
      
      await incrementDownload(userId, cached.trackName || title, cached.fileId, cacheKey);
      return;
    }

    // 4Ô∏è‚É£ –ù–∞—á–∞–ª–æ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è
    console.log(`[Worker] üéµ –°–∫–∞—á–∏–≤–∞—é: "${title}"`);
    statusMessage = await safeSendMessage(userId, `‚è≥ –°–∫–∞—á–∏–≤–∞—é: "${title}"`);

    // 5Ô∏è‚É£ –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–∑–º–µ—Ä–∞
    const sizeCheck = await checkFileSize(url);
    if (!sizeCheck.ok && sizeCheck.reason === 'FILE_TOO_LARGE') {
      throw new Error('FILE_TOO_LARGE');
    }

    // 6Ô∏è‚É£ –°–∫–∞—á–∏–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞
    const tempFileName = `${trackId || crypto.randomUUID()}.mp3`;
    tempFilePath = path.join(cacheDir, tempFileName);

    await ytdl(url, {
      output: tempFilePath,
      ...YTDL_DOWNLOAD
    });

    // 7Ô∏è‚É£ –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
    const stats = await fs.promises.stat(tempFilePath);
    
    if (stats.size === 0) {
      throw new Error('–°–∫–∞—á–∞–Ω–Ω—ã–π —Ñ–∞–π–ª –ø—É—Å—Ç–æ–π');
    }
    
    if (stats.size > MAX_FILE_SIZE_BYTES) {
      throw new Error('FILE_TOO_LARGE');
    }

    console.log(`[Worker] ‚úÖ –°–∫–∞—á–∞–Ω–æ ${(stats.size / 1024 / 1024).toFixed(2)} –ú–ë`);

    // 8Ô∏è‚É£ –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞
    if (statusMessage) {
      await bot.telegram.editMessageText(
        userId, 
        statusMessage.message_id, 
        undefined, 
        `üì§ –û—Ç–ø—Ä–∞–≤–ª—è—é: "${title}"`
      ).catch(() => {});
    }

    const safeFilename = `${sanitizeFilename(title)}.mp3`;
    let finalFileId = null;

    // 9Ô∏è‚É£ –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ –∫–∞–Ω–∞–ª–µ (–µ—Å–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ)
        // 9Ô∏è‚É£ –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ –∫–∞–Ω–∞–ª–µ (–µ—Å–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ)
    if (STORAGE_CHANNEL_ID) {
      try {
        const sentToStorage = await bot.telegram.sendAudio(
          STORAGE_CHANNEL_ID,
          { source: fs.createReadStream(tempFilePath), filename: safeFilename },
          { title, performer: uploader, duration }
        );
        
        if (sentToStorage?.audio?.file_id) {
          finalFileId = sentToStorage.audio.file_id;
          
          await db.cacheTrack({
            url: cacheKey,
            fileId: finalFileId,
            title,
            artist: uploader,
            duration,
            thumbnail
          });
          
          console.log(`[Worker] üíæ –ó–∞–∫—ç—à–∏—Ä–æ–≤–∞–Ω–æ: "${title}"`);
        }
      } catch (storageErr) {
        console.error(`[Worker] ‚ö†Ô∏è –û—à–∏–±–∫–∞ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è:`, storageErr.message);
      }
    }

    // üîü –û—Ç–ø—Ä–∞–≤–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
    if (finalFileId) {
      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —á–µ—Ä–µ–∑ file_id (–±—ã—Å—Ç—Ä–µ–µ)
      await bot.telegram.sendAudio(userId, finalFileId, {
        title,
        performer: uploader,
        duration
      });
    } else {
      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ñ–∞–π–ª –Ω–∞–ø—Ä—è–º—É—é
      const sentMsg = await bot.telegram.sendAudio(
        userId,
        { source: fs.createReadStream(tempFilePath), filename: safeFilename },
        { title, performer: uploader, duration }
      );
      
      finalFileId = sentMsg?.audio?.file_id;
      
      // –ö—ç—à–∏—Ä—É–µ–º file_id –¥–ª—è –±—É–¥—É—â–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
      if (finalFileId) {
        await db.cacheTrack({
          url: cacheKey,
          fileId: finalFileId,
          title,
          artist: uploader,
          duration,
          thumbnail
        });
      }
    }

    // 1Ô∏è‚É£1Ô∏è‚É£ –£–¥–∞–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
    if (statusMessage) {
      await bot.telegram.deleteMessage(userId, statusMessage.message_id).catch(() => {});
    }

    // 1Ô∏è‚É£2Ô∏è‚É£ –ò–Ω–∫—Ä–µ–º–µ–Ω—Ç —Å—á–µ—Ç—á–∏–∫–∞
    if (finalFileId) {
      await incrementDownload(userId, title, finalFileId, cacheKey);
    }

    console.log(`[Worker] ‚úÖ –ó–∞–≤–µ—Ä—à–µ–Ω–æ: "${title}" –¥–ª—è user ${userId}`);

  } catch (err) {
    const errorDetails = err?.stderr || err?.message || '';
    let userMsg = '‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å —Ç—Ä–µ–∫.';
    
    // –î–µ—Ç–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
    if (errorDetails.includes('FILE_TOO_LARGE')) {
      userMsg = '‚ùå –§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π (–º–∞–∫—Å. 49 –ú–ë).';
    } else if (errorDetails.includes('UNSAFE_URL')) {
      userMsg = '‚ùå –ù–µ–±–µ–∑–æ–ø–∞—Å–Ω–∞—è —Å—Å—ã–ª–∫–∞.';
    } else if (errorDetails.includes('timed out') || errorDetails.includes('timeout')) {
      userMsg = '‚ùå –ü—Ä–µ–≤—ã—à–µ–Ω–æ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.';
    } else if (errorDetails.includes('HTTP Error 404') || errorDetails.includes('not found')) {
      userMsg = '‚ùå –¢—Ä–µ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ —É–¥–∞–ª—ë–Ω.';
    } else if (errorDetails.includes('HTTP Error 403') || errorDetails.includes('Forbidden')) {
      userMsg = '‚ùå –î–æ—Å—Ç—É–ø –∫ —Ç—Ä–µ–∫—É –æ–≥—Ä–∞–Ω–∏—á–µ–Ω.';
    } else if (errorDetails.includes('private') || errorDetails.includes('geo')) {
      userMsg = '‚ùå –¢—Ä–µ–∫ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω (–ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∏–ª–∏ geo-–±–ª–æ–∫).';
    }
    
    console.error(`[Worker] ‚ùå –û—à–∏–±–∫–∞ –¥–ª—è user ${userId}:`, errorDetails);
    
    if (statusMessage) {
      await bot.telegram.editMessageText(
        userId,
        statusMessage.message_id,
        undefined,
        userMsg
      ).catch(() => {});
    } else {
      await safeSendMessage(userId, userMsg);
    }
    
  } finally {
    // –û—á–∏—Å—Ç–∫–∞ –≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞
    if (tempFilePath) {
      fs.promises.unlink(tempFilePath).catch(() => {});
    }
  }
}

// ========================= DOWNLOAD QUEUE =========================

export const downloadQueue = new TaskQueue({
  maxConcurrent: MAX_CONCURRENT_DOWNLOADS,
  taskProcessor: trackDownloadProcessor
});

console.log(`[DownloadManager] üöÄ –û—á–µ—Ä–µ–¥—å –∑–∞–ø—É—â–µ–Ω–∞ (max: ${MAX_CONCURRENT_DOWNLOADS} –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã—Ö)`);

// ========================= ENQUEUE FUNCTION =========================

/**
 * üî• –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –ü–û–°–¢–ê–ù–û–í–ö–ò –í –û–ß–ï–†–ï–î–¨
 * –û—Å–Ω–æ–≤–Ω—ã–µ —É–ª—É—á—à–µ–Ω–∏—è:
 * - –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ flat-playlist –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞
 * - –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –ø–æ–ª—É—á–∞—é—Ç—Å—è –≤ –≤–æ—Ä–∫–µ—Ä–µ, –∞ –Ω–µ –∑–∞—Ä–∞–Ω–µ–µ
 * - –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∫–µ—à–∞
 * - –ú–µ–Ω—å—à–µ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã—Ö —Å—Ç–∞—Ç—É—Å–æ–≤
 */
export function enqueue(ctx, userId, url) {
  (async () => {
    let statusMessage = null;
    const startTime = Date.now();

    try {
      // 1Ô∏è‚É£ –í–∞–ª–∏–¥–∞—Ü–∏—è URL
      if (!url || typeof url !== 'string') {
        console.error('[Enqueue] –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π URL:', url);
        return;
      }

      // –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ Spotify (–≤—Ä–µ–º–µ–Ω–Ω–æ)
      if (url.includes('spotify.com')) {
        await safeSendMessage(
          userId,
          'üõ† –ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ –∏–∑ Spotify –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ.'
        );
        return;
      }

      // 2Ô∏è‚É£ –°–±—Ä–æ—Å –¥–Ω–µ–≤–Ω–æ–≥–æ –ª–∏–º–∏—Ç–∞
      await db.resetDailyLimitIfNeeded(userId);

      // 3Ô∏è‚É£ –ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      const fullUser = await db.getUser(userId);
      const downloadsToday = Number(fullUser?.downloads_today || 0);
      const dailyLimit = Number(fullUser?.premium_limit || 0);

      // 4Ô∏è‚É£ –ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏–º–∏—Ç–∞
      if (downloadsToday >= dailyLimit) {
        const bonusAvailable = Boolean(CHANNEL_USERNAME && !fullUser?.subscribed_bonus_used);
        const cleanUsername = CHANNEL_USERNAME?.replace('@', '');
        const bonusText = bonusAvailable
          ? `\n\nüéÅ –î–æ—Å—Ç—É–ø–µ–Ω –±–æ–Ω—É—Å! –ü–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ <a href="https://t.me/${cleanUsername}">@${cleanUsername}</a> –∏ –ø–æ–ª—É—á–∏ <b>7 –¥–Ω–µ–π —Ç–∞—Ä–∏—Ñ–∞ Plus</b>.`
          : '';

        const text = `${T('limitReached')}${bonusText}`;
        const extra = {
          parse_mode: 'HTML',
          disable_web_page_preview: true
        };

        if (bonusAvailable) {
          extra.reply_markup = {
            inline_keyboard: [[
              Markup.button.callback('‚úÖ –Ø –ø–æ–¥–ø–∏—Å–∞–ª—Å—è, –∑–∞–±—Ä–∞—Ç—å –±–æ–Ω—É—Å', 'check_subscription')
            ]]
          };
        }

        await safeSendMessage(userId, text, extra);
        return;
      }

      // 5Ô∏è‚É£ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –Ω–∞—á–∞–ª–µ
      statusMessage = await safeSendMessage(userId, 'üîç –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é —Å—Å—ã–ª–∫—É...');

      // 6Ô∏è‚É£ –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ª–∏–º–∏—Ç–æ–≤ –ø–ª–µ–π–ª–∏—Å—Ç–∞
      const limits = {
        free: parseInt(getSetting('playlist_limit_free'), 10) || 10,
        plus: parseInt(getSetting('playlist_limit_plus'), 10) || 30,
        pro: parseInt(getSetting('playlist_limit_pro'), 10) || 100,
        unlim: parseInt(getSetting('playlist_limit_unlim'), 10) || 200,
      };

      let playlistLimit = limits.free;
      if (dailyLimit >= 10000) playlistLimit = limits.unlim;
      else if (dailyLimit >= 100) playlistLimit = limits.pro;
      else if (dailyLimit >= 30) playlistLimit = limits.plus;

      const remainingToday = Math.max(0, dailyLimit - downloadsToday);
      const maxTracksToProcess = Math.min(remainingToday, playlistLimit);

      // 7Ô∏è‚É£ üî• –ë–´–°–¢–†–û–ï –ø–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Ç—Ä–µ–∫–æ–≤ (–ë–ï–ó –ø–æ–ª–Ω—ã—Ö –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö!)
      let trackUrls = [];
      let isPlaylist = false;

      try {
        console.log('[Enqueue] üîç –ü–æ–ª—É—á–∞—é —Å–ø–∏—Å–æ–∫ —Ç—Ä–µ–∫–æ–≤ (flat-playlist)...');
        
        const info = await ytdl(url, {
          'flat-playlist': true, // üî• –ö–õ–Æ–ß–ï–í–ê–Ø –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø!
          'dump-single-json': true,
          'playlist-end': maxTracksToProcess,
          ...YTDL_COMMON
        });

        isPlaylist = Array.isArray(info?.entries) && info.entries.length > 1;

        if (isPlaylist) {
          trackUrls = info.entries
            .map(e => e.url || e.webpage_url || e.id)
            .filter(Boolean)
            .slice(0, maxTracksToProcess);
        } else {
          trackUrls = [url];
        }

        console.log(`[Enqueue] ‚úÖ –ù–∞–π–¥–µ–Ω–æ ${trackUrls.length} —Ç—Ä–µ–∫–æ–≤`);

      } catch (ytdlErr) {
        console.error('[Enqueue] –û—à–∏–±–∫–∞ youtube-dl:', ytdlErr.stderr || ytdlErr.message);
        throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å—Å—ã–ª–∫—É.');
      }

      if (trackUrls.length === 0) {
        throw new Error('–ù–µ –Ω–∞–π–¥–µ–Ω–æ —Ç—Ä–µ–∫–æ–≤ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏.');
      }

      // 8Ô∏è‚É£ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–∏ –ø–ª–µ–π–ª–∏—Å—Ç–∞
      if (isPlaylist && trackUrls.length >= maxTracksToProcess) {
        await safeSendMessage(
          userId,
          `‚ÑπÔ∏è –° —É—á—ë—Ç–æ–º –≤–∞—à–µ–≥–æ —Ç–∞—Ä–∏—Ñ–∞ –∏ –¥–Ω–µ–≤–Ω–æ–≥–æ –ª–∏–º–∏—Ç–∞ –±—É–¥–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ –¥–æ <b>${maxTracksToProcess}</b> —Ç—Ä–µ–∫–æ–≤.`,
          { parse_mode: 'HTML' }
        );
      }

      // 9Ô∏è‚É£ –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞
      if (statusMessage) {
        await bot.telegram.editMessageText(
          userId,
          statusMessage.message_id,
          undefined,
          `üîÑ –ü—Ä–æ–≤–µ—Ä—è—é –∫–µ—à –¥–ª—è ${trackUrls.length} —Ç—Ä–µ–∫–æ–≤...`
        ).catch(() => {});
      }

      // üîü üî• –ü–ê–†–ê–õ–õ–ï–õ–¨–ù–ê–Ø –ø—Ä–æ–≤–µ—Ä–∫–∞ –∫–µ—à–∞ –¥–ª—è –≤—Å–µ—Ö —Ç—Ä–µ–∫–æ–≤
      const cacheCheckResults = await pMap(
        trackUrls,
        async (trackUrl) => {
          // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω—ã–π cache key –∏–∑ URL
          const preliminaryCacheKey = `sc:${trackUrl}`;
          
          const cached = await db.findCachedTrack(preliminaryCacheKey) ||
                         await db.findCachedTrack(trackUrl);
          
          return {
            url: trackUrl,
            cached: cached?.fileId ? cached : null
          };
        },
        { concurrency: 10 } // –ë—ã—Å—Ç—Ä–∞—è –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞
      );

      // –†–∞–∑–¥–µ–ª—è–µ–º –Ω–∞ –∑–∞–∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∏ –Ω–æ–≤—ã–µ
      const cachedTracks = cacheCheckResults.filter(r => r.cached);
      const newTracks = cacheCheckResults.filter(r => !r.cached);

      console.log(`[Enqueue] üìä –ö–µ—à: ${cachedTracks.length}, –ù–æ–≤—ã–µ: ${newTracks.length}`);

      // 1Ô∏è‚É£1Ô∏è‚É£ –ú–≥–Ω–æ–≤–µ–Ω–Ω–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Ç—Ä–µ–∫–æ–≤
      if (cachedTracks.length > 0) {
        if (statusMessage) {
          await bot.telegram.editMessageText(
            userId,
            statusMessage.message_id,
            undefined,
            `‚ö° –û—Ç–ø—Ä–∞–≤–ª—è—é ${cachedTracks.length} –∑–∞–∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Ç—Ä–µ–∫–æ–≤...`
          ).catch(() => {});
        }

        await pMap(
          cachedTracks,
          async ({ cached }) => {
            try {
              await bot.telegram.sendAudio(userId, cached.fileId, {
                title: cached.trackName,
                performer: cached.artist,
                duration: cached.duration
              });
              
              await incrementDownload(userId, cached.trackName, cached.fileId, cached.url);
            } catch (sendErr) {
              console.error('[Enqueue] –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∏–∑ –∫–µ—à–∞:', sendErr.message);
            }
          },
          { concurrency: 3 } // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ 3 —Ç—Ä–µ–∫–∞ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ
        );
      }

      // 1Ô∏è‚É£2Ô∏è‚É£ –ü–æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–æ–≤—ã—Ö —Ç—Ä–µ–∫–æ–≤ –≤ –æ—á–µ—Ä–µ–¥—å
      if (newTracks.length > 0) {
        if (statusMessage) {
          const msg = cachedTracks.length > 0
            ? `üîÑ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é ${newTracks.length} –Ω–æ–≤—ã—Ö —Ç—Ä–µ–∫–æ–≤...`
            : `üîÑ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é ${newTracks.length} —Ç—Ä–µ–∫–æ–≤...`;
          
          await bot.telegram.editMessageText(
            userId,
            statusMessage.message_id,
            undefined,
            msg
          ).catch(() => {});
        }

        for (const { url: trackUrl } of newTracks) {
          await downloadQueue.enqueue({
            userId,
            url: trackUrl,
            originalUrl: trackUrl,
            source: 'soundcloud',
            // üî• –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –ø–æ–ª—É—á–∏–º –≤ –≤–æ—Ä–∫–µ—Ä–µ!
            metadata: null,
            cacheKey: null
          });
        }
      }

      // 1Ô∏è‚É£3Ô∏è‚É£ –£–¥–∞–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
      if (statusMessage) {
        setTimeout(() => {
          bot.telegram.deleteMessage(userId, statusMessage.message_id).catch(() => {});
        }, 3000);
      }

      const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
      console.log(`[Enqueue] ‚úÖ –ó–∞–≤–µ—Ä—à–µ–Ω–æ –∑–∞ ${elapsed}—Å (–∫–µ—à: ${cachedTracks.length}, –Ω–æ–≤—ã–µ: ${newTracks.length})`);

    } catch (err) {
      console.error('[Enqueue] ‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞:', err.message);
      
      let userMsg = '‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å—Å—ã–ª–∫–∏.';
      
      if (err.message.includes('–ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å—Å—ã–ª–∫—É')) {
        userMsg = '‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ç—Ä–µ–∫–∏. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å—Å—ã–ª–∫—É.';
      } else if (err.message.includes('–Ω–µ –Ω–∞–π–¥–µ–Ω–æ')) {
        userMsg = '‚ùå –¢—Ä–µ–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.';
      }

      if (statusMessage) {
        await bot.telegram.editMessageText(
          userId,
          statusMessage.message_id,
          undefined,
          userMsg
        ).catch(() => {});
      } else {
        await safeSendMessage(userId, userMsg);
      }
    }
  })();
}

// 