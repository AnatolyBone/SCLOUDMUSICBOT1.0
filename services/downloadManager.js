// services/downloadManager.js (yt-dlp, /tmp, no-reencode mp3, –±–∞—Ç—á-–∫—ç—à, sc:<id>)

import { STORAGE_CHANNEL_ID, CHANNEL_USERNAME, PROXY_URL } from '../config.js';
import { Markup } from 'telegraf';
import path from 'path';
import fs from 'fs';
import os from 'os';
import { fileURLToPath } from 'url';
import crypto from 'crypto';
import ytdl from 'yt-dlp-exec';
import ffmpegPath from 'ffmpeg-static';
import { bot } from '../bot.js';
import { T } from '../config/texts.js';
import { TaskQueue } from '../lib/TaskQueue.js';

// –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º db –∫–∞–∫ namespace, —á—Ç–æ–±—ã –±–µ–∑–æ–ø–∞—Å–Ω–æ –ø—Ä–æ–≤–µ—Ä—è—Ç—å –Ω–∞–ª–∏—á–∏–µ –Ω–æ–≤—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π
import * as db from '../db.js';

// –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø—É—Ç–µ–π
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(path.dirname(__filename));

// –•—Ä–∞–Ω–∏–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã –≤ /tmp (–Ω–∞ Render —ç—Ç–æ –±—ã—Å—Ç—Ä–µ–µ)
const cacheDir = path.join(os.tmpdir(), 'cache');
if (!fs.existsSync(cacheDir)) fs.mkdirSync(cacheDir, { recursive: true });

// –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã
const YTDL_TIMEOUT = 120; // —á—É—Ç—å –∫–æ—Ä–æ—á–µ, —á—Ç–æ–±—ã –±—ã—Å—Ç—Ä–µ–µ –æ—Ç–≤–∞–ª–∏–≤–∞—Ç—å—Å—è –ø—Ä–∏ –ø–ª–æ—Ö–æ–π —Å–µ—Ç–∏
const MAX_FILE_SIZE_BYTES = 49 * 1024 * 1024; // –ª–∏–º–∏—Ç —Ç–µ–ª–µ–≥—Ä–∞–º–∞ ~50 MB, –æ—Å—Ç–∞–≤–∏–º –∑–∞–ø–∞—Å
const UNLIMITED_PLAYLIST_LIMIT = 100;
const FAKE_USER_AGENT = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36';

// –û–±—â–∏–µ –æ–ø—Ü–∏–∏ yt-dlp
const YTDL_COMMON = {
  ffmpegLocation: ffmpegPath || undefined,
  userAgent: FAKE_USER_AGENT,
  proxy: PROXY_URL || undefined,
  retries: 3,
  socketTimeout: YTDL_TIMEOUT,
  noWarnings: true,
  // concurrentFragments: 4, // –º–æ–∂–Ω–æ –≤–∫–ª—é—á–∏—Ç—å –¥–ª—è HLS-—Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤ –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
};

function sanitizeFilename(name) {
  return (name || 'track').replace(/[<>:"/\\|?*]+/g, '').trim();
}

function getCacheKey(meta, fallbackUrl) {
  if (meta?.id) return `sc:${meta.id}`;
  return fallbackUrl || 'unknown';
}

async function safeSendMessage(userId, text, extra = {}) {
  try {
    return await bot.telegram.sendMessage(userId, text, extra);
  } catch (e) {
    if (e.response?.error_code === 403) {
      try { await db.updateUserField(userId, 'active', false); } catch {}
    }
    return null;
  }
}

function canCopyMp3(ext, acodec) {
  if (!ext && !acodec) return false;
  return ext === 'mp3' || /mp3/i.test(acodec || '');
}

async function mapLimit(items, limit, worker) {
  const queue = [...items];
  const running = new Set();
  const results = [];
  while (queue.length || running.size) {
    while (queue.length && running.size < limit) {
      const item = queue.shift();
      const p = Promise.resolve().then(() => worker(item));
      running.add(p);
      p.finally(() => running.delete(p));
      results.push(p);
    }
    if (running.size) await Promise.race(running);
  }
  return Promise.allSettled(results);
}

// –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—É—é —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–æ–Ω–Ω—É—é –∑–∞–ø–∏—Å—å, –µ—Å–ª–∏ –µ—Å—Ç—å; –∏–Ω–∞—á–µ ‚Äî —Å—Ç–∞—Ä—É—é
async function incrementDownload(userId, trackTitle, fileId, cacheKey) {
  if (typeof db.incrementDownloadsAndLogPg === 'function') {
    return await db.incrementDownloadsAndLogPg(userId, trackTitle, fileId, cacheKey);
  }
  return await db.incrementDownloadsAndSaveTrack(userId, trackTitle, fileId, cacheKey);
}

// –õ—ë–≥–∫–∞—è –≤—ã–±–æ—Ä–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–∞), –∏–Ω–∞—á–µ –ø–∞–¥–∞–µ–º –Ω–∞ getUser
async function getUserUsage(userId) {
  if (typeof db.getUserUsage === 'function') {
    return await db.getUserUsage(userId);
  }
  if (typeof db.getUserLite === 'function') {
    return await db.getUserLite(userId);
  }
  return await db.getUser(userId);
}

async function trackDownloadProcessor(task) {
  try {
    const { userId, source, url, originalUrl, metadata, cacheKey } = task;
    const { title, uploader, id: trackId, duration, thumbnail, ext, acodec, filesize } = metadata;
    const roundedDuration = duration ? Math.round(duration) : undefined;

    let tempFilePath = null;
    let statusMessage = null;

    try {
      statusMessage = await safeSendMessage(userId, `‚è≥ –ù–∞—á–∏–Ω–∞—é —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ —Ç—Ä–µ–∫–∞: "${title}"`);
      console.log(`[Worker] –ü–æ–ª—É—á–µ–Ω–∞ –∑–∞–¥–∞—á–∞ –¥–ª—è "${title}" (–∏—Å—Ç–æ—á–Ω–∏–∫: ${source}).`);

      // –†–∞–Ω–Ω–∏–π –æ—Ç–∫–∞–∑ –ø–æ –∏–∑–≤–µ—Å—Ç–Ω–æ–º—É —Ä–∞–∑–º–µ—Ä—É
      if (filesize && filesize > MAX_FILE_SIZE_BYTES) {
        throw new Error('FILE_TOO_LARGE');
      }

      const tempFileName = `${trackId || 'track'}-${crypto.randomUUID()}.mp3`;
      tempFilePath = path.join(cacheDir, tempFileName);

      const ytdlArgs = {
        output: tempFilePath,
        embedThumbnail: true,     // –≤—à–∏–≤–∫–∞ –æ–±–ª–æ–∂–∫–∏
        addMetadata: true,        // ID3
        convertThumbnails: true,  // –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç webp -> jpg –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–π –≤—à–∏–≤–∫–∏
        ...YTDL_COMMON,
      };

      if (canCopyMp3(ext, acodec)) {
        // –£–∂–µ mp3 ‚Äî —Å–∫–∞—á–∏–≤–∞–µ–º –∫–∞–∫ –µ—Å—Ç—å –∏ –≤—à–∏–≤–∞–µ–º –æ–±–ª–æ–∂–∫—É –±–µ–∑ –ø–µ—Ä–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è (ffmpeg copy)
        await ytdl(url, ytdlArgs);
      } else {
        // –ù–µ mp3 ‚Äî —Ç–æ–ª—å–∫–æ —Ç—É—Ç –ø–µ—Ä–µ–∫–æ–¥–∏—Ä—É–µ–º
        await ytdl(url, {
          ...ytdlArgs,
          extractAudio: true,
          audioFormat: 'mp3',
        });
      }

      if (!fs.existsSync(tempFilePath)) throw new Error(`–§–∞–π–ª –Ω–µ –±—ã–ª —Å–æ–∑–¥–∞–Ω.`);
      const stats = await fs.promises.stat(tempFilePath);
      if (stats.size > MAX_FILE_SIZE_BYTES) throw new Error(`FILE_TOO_LARGE`);

      if (statusMessage) {
        await bot.telegram.editMessageText(userId, statusMessage.message_id, undefined, `‚úÖ –°–∫–∞—á–∞–ª. –û—Ç–ø—Ä–∞–≤–ª—è—é...`).catch(() => {});
      }

      const sentToUserMessage = await bot.telegram.sendAudio(
        userId,
        { source: fs.createReadStream(tempFilePath) },
        {
          title,
          performer: uploader || 'Unknown Artist',
          duration: roundedDuration,
        }
      );

      if (statusMessage) {
        await bot.telegram.deleteMessage(userId, statusMessage.message_id).catch(() => {});
      }

      // –õ–æ–≥–∏—Ä—É–µ–º –∏ —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á—ë—Ç—á–∏–∫–∏
      if (sentToUserMessage?.audio?.file_id) {
        await incrementDownload(userId, title, sentToUserMessage.audio.file_id, cacheKey);

        // –ö—ç—à–∏—Ä—É–µ–º –≤ –∫–∞–Ω–∞–ª–µ –∏ –≤ –ë–î
        if (STORAGE_CHANNEL_ID) {
          try {
            const sentToStorage = await bot.telegram.sendAudio(STORAGE_CHANNEL_ID, sentToUserMessage.audio.file_id);
            await db.cacheTrack({
              url: cacheKey,
              fileId: sentToStorage.audio.file_id,
              title,
              artist: uploader,
              duration: roundedDuration,
              thumbnail,
            });
            console.log(`‚úÖ [Cache] –¢—Ä–µ–∫ "${title}" —É—Å–ø–µ—à–Ω–æ –∑–∞–∫—ç—à–∏—Ä–æ–≤–∞–Ω.`);
          } catch (e) {
            console.error(`‚ùå [Cache] –û—à–∏–±–∫–∞ –ø—Ä–∏ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–∏ —Ç—Ä–µ–∫–∞ "${title}":`, e.message);
          }
        }
      }
    } catch (err) {
      const errorDetails = err?.stderr || err?.message || String(err);
      let userErrorMessage = `‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å —Ç—Ä–µ–∫: "${title}"`;
      if (errorDetails.includes('FILE_TOO_LARGE')) userErrorMessage += '. –û–Ω —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π.';
      else if (errorDetails.includes('timed out')) userErrorMessage += '. –û—à–∏–±–∫–∞ —Å–µ—Ç–∏.';
      console.error(`‚ùå –û—à–∏–±–∫–∞ –≤–æ—Ä–∫–µ—Ä–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ "${title}":`, errorDetails);
      if (statusMessage) {
        await bot.telegram.editMessageText(userId, statusMessage.message_id, undefined, userErrorMessage).catch(() => {});
      } else {
        await safeSendMessage(userId, userErrorMessage);
      }
    } finally {
      if (tempFilePath && fs.existsSync(tempFilePath)) {
        fs.promises.unlink(tempFilePath).catch(e => console.error("–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞:", e));
      }
    }
  } catch (e) {
    console.error('üî¥ –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –ù–ï–ü–ï–†–ï–•–í–ê–ß–ï–ù–ù–ê–Ø –û–®–ò–ë–ö–ê –í –í–û–†–ö–ï–†–ï!', e);
  }
}

// –û—á–µ—Ä–µ–¥—å: maxConcurrent=1 (CPU-—ç–∫–æ–Ω–æ–º–Ω–æ –Ω–∞ Render free)
export const downloadQueue = new TaskQueue({
  maxConcurrent: 1,
  taskProcessor: trackDownloadProcessor,
});

// no-op –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å index.js (–µ—Å–ª–∏ –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è initializeDownloadManager(bot))
export function initializeDownloadManager() {
  // –∑–∞—Ä–µ–∑–µ—Ä–≤–∏—Ä–æ–≤–∞–Ω–æ –¥–ª—è –±—É–¥—É—â–∏—Ö —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–π
}

export function enqueue(ctx, userId, url) {
  (async () => {
    let statusMessage = null;
    try {
      // –û—Ç–∫–ª—é—á–∞–µ–º Spotify (–∑–∞—â–∏—Ç–∞)
      if (url.includes('spotify.com')) return;

      await db.resetDailyLimitIfNeeded(userId);

      // –õ—ë–≥–∫–∞—è –≤—ã–±–æ—Ä–∫–∞, –µ—Å–ª–∏ –µ—Å—Ç—å; –∏–Ω–∞—á–µ –ø–æ–ª–Ω–∞—è
      let user = await getUserUsage(userId);

      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏–º–∏—Ç–∞
      if ((user.downloads_today || 0) >= (user.premium_limit || 0)) {
        // –î–ª—è –±–æ–Ω—É—Å–Ω–æ–π –∫–Ω–æ–ø–∫–∏ –Ω–∞–º –Ω—É–∂–µ–Ω subscribed_bonus_used ‚Äî –¥–æ—Å—Ç–∞–Ω–µ–º –ø–æ–ª–Ω—ã–π –ø—Ä–æ—Ñ–∏–ª—å –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
        const fullUser = (user.subscribed_bonus_used === undefined) ? await db.getUser(userId) : user;
        let message = T('limitReached');
        let bonusMessageText = '';
        if (!fullUser.subscribed_bonus_used) {
          const cleanUsername = CHANNEL_USERNAME.replace('@', '');
          const channelLink = `[${CHANNEL_USERNAME}](https://t.me/${cleanUsername})`;
          bonusMessageText = `\n\nüéÅ –£ —Ç–µ–±—è –µ—Å—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã–π –±–æ–Ω—É—Å! –ü–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ ${channelLink} –∏ –ø–æ–ª—É—á–∏ *7 –¥–Ω–µ–π —Ç–∞—Ä–∏—Ñ–∞ Plus*.`;
        }
        message = message.replace('{bonus_message}', bonusMessageText);
        const extra = { parse_mode: 'Markdown' };
        if (!fullUser.subscribed_bonus_used) {
          extra.reply_markup = { inline_keyboard: [[Markup.button.callback('‚úÖ –Ø –ø–æ–¥–ø–∏—Å–∞–ª—Å—è, –∑–∞–±—Ä–∞—Ç—å –±–æ–Ω—É—Å', 'check_subscription')]] };
        }
        await safeSendMessage(userId, message, extra);
        return;
      }

      statusMessage = await safeSendMessage(userId, 'üîç –ü–æ–ª—É—á–∞—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç—Ä–µ–∫–µ...');

      // –û—Å—Ç–∞—Ç–æ–∫ –ª–∏–º–∏—Ç–∞ –Ω—É–∂–µ–Ω, —á—Ç–æ–±—ã –æ–≥—Ä–∞–Ω–∏—á–∏—Ç—å –ø–ª–µ–π–ª–∏—Å—Ç –ø—Ä—è–º–æ –≤ yt-dlp
      const remainingDailyLimit = Math.max(0, (user.premium_limit || 0) - (user.downloads_today || 0));
      const playlistLimit = (user.premium_limit || 0) <= 10 ? 5 : UNLIMITED_PLAYLIST_LIMIT;
      const playlistEnd = Math.max(1, Math.min(remainingDailyLimit || 1, playlistLimit));

      // –ü–æ–ª—É—á–∞–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
      const info = await ytdl(url, {
        dumpSingleJson: true,
        playlistEnd, // –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –ø–∞—Ä—Å–∏–Ω–≥ –ø–ª–µ–π–ª–∏—Å—Ç–∞ –Ω–∞ —Å—Ç–æ—Ä–æ–Ω–µ yt-dlp
        ...YTDL_COMMON,
      });

      if (!info) throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ');

      const isPlaylist = Array.isArray(info.entries);
      const entries = isPlaylist ? info.entries : [info];

      let tracksToProcess = entries
        .filter(e => e && (e.webpage_url || e.url))
        .map(e => {
          // –ò–Ω–æ–≥–¥–∞ ext/acodec/—Ñ–∞–π–ª—ã –Ω–∞ –≤–µ—Ä—Ö–Ω–µ–º —É—Ä–æ–≤–Ω–µ; fallback ‚Äî –ø–æ–ø—Ä–æ–±—É–µ–º requested_downloads[0]
          const ext = e.ext || e.requested_downloads?.[0]?.ext || null;
          const acodec = e.acodec || e.requested_downloads?.[0]?.acodec || null;
          const filesize = e.filesize || e.filesize_approx || e.requested_downloads?.[0]?.filesize || null;

          const md = {
            id: e.id,
            title: sanitizeFilename(e.title || 'Unknown Title'),
            uploader: e.uploader || 'Unknown Artist',
            duration: e.duration,
            thumbnail: e.thumbnail,
            ext,
            acodec,
            filesize,
          };
          const realUrl = e.webpage_url || e.url;
          const key = getCacheKey(md, realUrl);
          return {
            url: realUrl,
            originalUrl: realUrl,
            source: 'soundcloud',
            cacheKey: key,
            metadata: md,
          };
        });

      if (tracksToProcess.length === 0) {
        await safeSendMessage(userId, '–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —Ç—Ä–µ–∫–∏ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏.');
        return;
      }

      // –ï—Å–ª–∏ —ç—Ç–æ –ø–ª–µ–π–ª–∏—Å—Ç, —É–∫–∞–∂–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é, —Å–∫–æ–ª—å–∫–æ –º–∞–∫—Å–∏–º—É–º –±—É–¥–µ–º –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å (–±–µ–∑ —Ç–æ—á–Ω–æ–≥–æ –æ–±—â–µ–≥–æ —Ä–∞–∑–º–µ—Ä–∞)
      if (isPlaylist && (tracksToProcess.length > playlistEnd)) {
        await safeSendMessage(userId, `‚ÑπÔ∏è –° —É—á–µ—Ç–æ–º –≤–∞—à–µ–≥–æ —Ç–∞—Ä–∏—Ñ–∞ –∏ –¥–Ω–µ–≤–Ω–æ–≥–æ –ª–∏–º–∏—Ç–∞ –±—É–¥–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ –¥–æ ${playlistEnd} —Ç—Ä–µ–∫(–æ–≤).`);
        tracksToProcess = tracksToProcess.slice(0, playlistEnd);
      }

      if (statusMessage) {
        await bot.telegram
          .editMessageText(userId, statusMessage.message_id, undefined, 'üîÑ –ü—Ä–æ–≤–µ—Ä—è—é –∫—ç—à...')
          .catch(() => {});
      }

      // –ë–∞—Ç—á-–ø–æ–∏—Å–∫ –∫—ç—à–∞, –µ—Å–ª–∏ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞
      let cacheMap = new Map();
      const keys = tracksToProcess.map(t => t.cacheKey);
      if (typeof db.findCachedTracks === 'function') {
        cacheMap = await db.findCachedTracks(keys);
      } else {
        // –§–æ–ª–ª–±–µ–∫: –ø–æ—à—Ç—É—á–Ω—ã–π –ø–æ–∏—Å–∫
        for (const k of keys) {
          const c = await db.findCachedTrack(k);
          if (c) cacheMap.set(k, c);
        }
      }

      let tasksToDownload = [];
      let cachedToSend = [];

      // –õ–æ–∫–∞–ª—å–Ω—ã–π –æ—Å—Ç–∞—Ç–æ–∫ –ª–∏–º–∏—Ç–∞
      user = await getUserUsage(userId); // –æ–±–Ω–æ–≤–∏–º usage –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π
      let remaining = Math.max(0, (user.premium_limit || 0) - (user.downloads_today || 0));

      for (const track of tracksToProcess) {
        if (remaining <= 0) break;
        const cached = cacheMap.get(track.cacheKey);
        if (cached) {
          cachedToSend.push({ track, cached });
        } else {
          tasksToDownload.push(track);
        }
      }

      let sentFromCacheCount = 0;

      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∏–∑ –∫—ç—à–∞ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ (–¥–æ 3 –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ)
      await mapLimit(cachedToSend, 3, async ({ track, cached }) => {
        if (remaining <= 0) return;
        try {
          await bot.telegram.sendAudio(
            userId,
            cached.fileId,
            { title: cached.trackName, performer: track.metadata.uploader }
          );
          const ok = await incrementDownload(userId, cached.trackName, cached.fileId, track.cacheKey);
          if (ok !== null) {
            // ok –º–æ–∂–µ—Ç –±—ã—Ç—å true/–æ–±—ä–µ–∫—Ç; –¥–ª—è —Ñ–æ–ª–ª–±–µ–∫–∞ null –∑–Ω–∞—á–∏—Ç –Ω–µ –∏–Ω–∫—Ä–µ–º–µ–Ω—Ç–Ω—É–ª–∏
            remaining -= 1;
            sentFromCacheCount++;
          }
        } catch (err) {
          if (err?.description?.includes('FILE_REFERENCE_EXPIRED')) {
            tasksToDownload.push(track);
          } else {
            console.error(`‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∏–∑ –∫—ç—à–∞ –¥–ª—è ${userId}:`, err.message || err);
          }
        }
      });

      let finalMessage = '';
      if (sentFromCacheCount > 0) {
        finalMessage += `‚úÖ ${sentFromCacheCount} —Ç—Ä–µ–∫(–æ–≤) –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –∏–∑ –∫—ç—à–∞.\n`;
      }

      // –ü–æ–¥–≥–æ—Ç–æ–≤–∏–º –∫ —Å–∫–∞—á–∏–≤–∞–Ω–∏—é —Å —É—á–µ—Ç–æ–º –æ—Å—Ç–∞—Ç–∫–∞ –ª–∏–º–∏—Ç–∞
      if (remaining > 0 && tasksToDownload.length > 0) {
        const tasksToReallyDownload = tasksToDownload.slice(0, remaining);
        finalMessage += `‚è≥ ${tasksToReallyDownload.length} —Ç—Ä–µ–∫(–æ–≤) –¥–æ–±–∞–≤–ª–µ–Ω–æ –≤ –æ—á–µ—Ä–µ–¥—å.`;
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –∫–∞–∫ premium_limit (–∫–∞–∫ —É —Ç–µ–±—è –±—ã–ª–æ)
        const prio = user.premium_limit || 0;
        for (const task of tasksToReallyDownload) {
          downloadQueue.add({ userId, ...task, priority: prio });
        }
      } else if (sentFromCacheCount === 0) {
        finalMessage += `üö´ –í–∞—à –¥–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç –∏—Å—á–µ—Ä–ø–∞–Ω.`;
      }

      if (statusMessage) {
        await bot.telegram
          .editMessageText(userId, statusMessage.message_id, undefined, finalMessage || "–í—Å–µ —Ç—Ä–µ–∫–∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã.")
          .catch(() => {});
      } else if (finalMessage) {
        await safeSendMessage(userId, finalMessage);
      }
    } catch (err) {
      const errorMessage = err?.stderr || err?.message || String(err);
      let userMessage = `‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å—Å—ã–ª–∫–∏.`;
      if (errorMessage.includes('timed out')) userMessage = '‚ùå –û—à–∏–±–∫–∞ —Å–µ—Ç–∏ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ç—Ä–µ–∫–µ.';
      else if (errorMessage.includes('404')) userMessage = '‚ùå –¢—Ä–µ–∫ –ø–æ —ç—Ç–æ–π —Å—Å—ã–ª–∫–µ –Ω–µ –Ω–∞–π–¥–µ–Ω.';
      else console.error(`‚ùå –ì–ª–æ–±–∞–ª—å–Ω–∞—è –æ—à–∏–±–∫–∞ –≤ enqueue –¥–ª—è ${userId}:`, err);
      if (statusMessage) {
        await bot.telegram.editMessageText(userId, statusMessage.message_id, undefined, userMessage).catch(() => {});
      } else {
        await safeSendMessage(userId, userMessage);
      }
    }
  })();
}