// services/downloadManager.js (–§–ò–ù–ê–õ–¨–ù–ê–Ø –í–ï–†–°–ò–Ø –° –ï–î–ò–ù–û–ô –¢–û–ß–ö–û–ô –û–ë–†–ê–ë–û–¢–ö–ò)

import { STORAGE_CHANNEL_ID, PROXY_URL } from '../config.js';
import path from 'path';
import fs from 'fs';
import ytdl from 'youtube-dl-exec';
import { fileURLToPath } from 'url';
import crypto from 'crypto';
import PQueue from 'p-queue';
import {
    getUser,
    updateUserField,
    findCachedTrack,
    cacheTrack,
    incrementDownloadsAndSaveTrack
} from '../db.js';

// --- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ---
let botInstance;
export function initializeDownloadManager(bot) {
    botInstance = bot;
}

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(path.dirname(__filename));
const cacheDir = path.join(__dirname, 'cache');
if (!fs.existsSync(cacheDir)) fs.mkdirSync(cacheDir); // –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ –ø–∞–ø–∫–∞ –¥–ª—è –∫—ç—à–∞ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç

const YTDL_TIMEOUT = 180;
const MAX_FILE_SIZE_BYTES = 49 * 1024 * 1024;
const FAKE_USER_AGENT = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36';

// --- –ì–ª–∞–≤–Ω—ã–π –≤–æ—Ä–∫–µ—Ä –æ—á–µ—Ä–µ–¥–∏ ---

export async function trackDownloadProcessor(task) {
    // –í–Ω–µ—à–Ω–∏–π try...catch –¥–ª—è –∑–∞—â–∏—Ç—ã –æ—Ç "–∑–∞–º–µ—Ä–∑–∞–Ω–∏—è" –æ—á–µ—Ä–µ–¥–∏
    try {
        // --- 1. –ò–∑–≤–ª–µ–∫–∞–µ–º –í–°–ï –Ω—É–∂–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ –∑–∞–¥–∞—á–∏ –≤ —Å–∞–º–æ–º –Ω–∞—á–∞–ª–µ ---
        const { userId, source, url, originalUrl, metadata } = task;
        const { title, uploader, id: trackId, duration, thumbnail } = metadata;
        const roundedDuration = duration ? Math.round(duration) : undefined;
        
        // --- 2. –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à ---
        const cacheKey = originalUrl || url;
        const cached = await findCachedTrack(cacheKey);
        
        if (cached) {
            console.log(`[Worker/Cache] –û—Ç–ø—Ä–∞–≤–ª—è—é "${cached.title || title}" –∏–∑ –∫—ç—à–∞ –¥–ª—è ${userId}`);
            try {
                const user = await getUser(userId);
                if (user.downloads_today < user.premium_limit) {
                    await botInstance.telegram.sendAudio(userId, cached.fileId, { title: cached.title, performer: cached.artist });
                    await incrementDownloadsAndSaveTrack(userId, cached.title, cached.fileId, cacheKey);
                } else {
                    await botInstance.telegram.sendMessage(userId, `–¢—Ä–µ–∫ "${cached.title}" –Ω–∞–π–¥–µ–Ω –≤ –∫—ç—à–µ, –Ω–æ –≤–∞—à –¥–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç –∏—Å—á–µ—Ä–ø–∞–Ω.`);
                }
                return; // –£—Å–ø–µ—à–Ω–æ –≤—ã—Ö–æ–¥–∏–º, –µ—Å–ª–∏ –æ—Ç–ø—Ä–∞–≤–∏–ª–∏ –∏–∑ –∫—ç—à–∞
            } catch (e) {
                if (e.response?.error_code === 403) await updateUserField(userId, 'active', false);
                console.warn(`[Worker/Cache] –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∏–∑ –∫—ç—à–∞ –¥–ª—è "${title}" (–≤–æ–∑–º–æ–∂–Ω–æ, FILE_REFERENCE_EXPIRED), –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ...`);
            }
        }
        
        // --- 3. –ï—Å–ª–∏ –≤ –∫—ç—à–µ –Ω–µ—Ç - —Å–∫–∞—á–∏–≤–∞–µ–º ---
        let tempFilePath = null;
        let statusMessage = null;
        
        try {
            statusMessage = await botInstance.telegram.sendMessage(userId, `‚è≥ –ù–∞—á–∏–Ω–∞—é —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ —Ç—Ä–µ–∫–∞: "${title}"`).catch(() => null);
            console.log(`[Worker] –°–∫–∞—á–∏–≤–∞—é "${title}" –¥–ª—è ${userId}`);
            
            const tempFileName = `${trackId || 'track'}-${crypto.randomUUID()}.mp3`;
            tempFilePath = path.join(cacheDir, tempFileName);
            
            await ytdl(url, {
                output: tempFilePath,
                extractAudio: true,
                audioFormat: 'mp3',
                embedThumbnail: true,
                retries: 3,
                "socket-timeout": YTDL_TIMEOUT,
                'user-agent': FAKE_USER_AGENT,
                proxy: PROXY_URL || undefined,
            });
            
            if (!fs.existsSync(tempFilePath)) throw new Error(`–§–∞–π–ª –Ω–µ –±—ã–ª —Å–æ–∑–¥–∞–Ω.`);
            const stats = await fs.promises.stat(tempFilePath);
            if (stats.size > MAX_FILE_SIZE_BYTES) throw new Error(`FILE_TOO_LARGE`);
            
            if (statusMessage) await botInstance.telegram.editMessageText(userId, statusMessage.message_id, undefined, `‚úÖ –°–∫–∞—á–∞–ª. –û—Ç–ø—Ä–∞–≤–ª—è—é...`).catch(() => {});
            
            const sentToUserMessage = await botInstance.telegram.sendAudio(userId, { source: fs.createReadStream(tempFilePath) }, {
                title, performer: uploader || 'Unknown Artist', duration: roundedDuration
            });
            
            if (statusMessage) await botInstance.telegram.deleteMessage(userId, statusMessage.message_id).catch(() => {});
            
            if (sentToUserMessage?.audio?.file_id) {
                await incrementDownloadsAndSaveTrack(userId, title, sentToUserMessage.audio.file_id, cacheKey);
                if (STORAGE_CHANNEL_ID) {
                    try {
                        const sentToStorage = await botInstance.telegram.sendAudio(STORAGE_CHANNEL_ID, sentToUserMessage.audio.file_id);
                        await cacheTrack({ url: cacheKey, fileId: sentToStorage.audio.file_id, title, artist: uploader, duration: roundedDuration, thumbnail });
                        console.log(`‚úÖ [Cache] –¢—Ä–µ–∫ "${title}" —É—Å–ø–µ—à–Ω–æ –∑–∞–∫—ç—à–∏—Ä–æ–≤–∞–Ω.`);
                    } catch (e) { console.error(`‚ùå [Cache] –û—à–∏–±–∫–∞ –ø—Ä–∏ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–∏ —Ç—Ä–µ–∫–∞ "${title}":`, e.message); }
                }
            }
        } catch (err) {
            const errorDetails = err.stderr || err.message || '';
            let userErrorMessage = `‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å —Ç—Ä–µ–∫: "${title}"`;
            if (errorDetails.includes('FILE_TOO_LARGE')) userErrorMessage += '. –û–Ω —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π.';
            else if (errorDetails.includes('timed out')) userErrorMessage += '. –û—à–∏–±–∫–∞ —Å–µ—Ç–∏.';
            else if (errorDetails.includes('geo restriction')) userErrorMessage += '. –¢—Ä–µ–∫ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω –≤ –≤–∞—à–µ–º —Ä–µ–≥–∏–æ–Ω–µ.';
            console.error(`‚ùå –û—à–∏–±–∫–∞ –≤–æ—Ä–∫–µ—Ä–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ "${title}":`, errorDetails);
            if (statusMessage) await botInstance.telegram.editMessageText(userId, statusMessage.message_id, undefined, userErrorMessage).catch(() => {});
            else await botInstance.telegram.sendMessage(userId, userErrorMessage).catch(() => {});
        } finally {
            if (tempFilePath && fs.existsSync(tempFilePath)) {
                fs.promises.unlink(tempFilePath).catch(e => console.error("–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞:", e));
            }
        }
    } catch (e) {
        console.error('üî¥ –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –ù–ï–ü–ï–†–ï–•–í–ê–ß–ï–ù–ù–ê–Ø –û–®–ò–ë–ö–ê –í –í–û–†–ö–ï–†–ï!', e);
    }
}

// --- –≠–∫—Å–ø–æ—Ä—Ç –æ—á–µ—Ä–µ–¥–∏ ---
export const downloadQueue = new PQueue({ concurrency: 1 });