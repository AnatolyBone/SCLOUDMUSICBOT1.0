// bot.js (–æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª–∞)

import { Telegraf, Markup } from 'telegraf';
import { HttpsProxyAgent } from 'https-proxy-agent';
import { 
  ADMIN_ID, BOT_TOKEN, WEBHOOK_URL, CHANNEL_USERNAME, 
  STORAGE_CHANNEL_ID, PROXY_URL 
} from './config.js';
import * as db from './db.js';
import { T, allTextsSync } from './config/texts.js';
import { enqueue, downloadQueue } from './services/downloadManager.js';
import { performInlineSearch } from './services/searchManager.js';
import { handleReferralCommand, processNewUserReferral } from './services/referralManager.js';
import { isMaintenanceMode, setMaintenanceMode } from './services/appState.js';
import execYoutubeDl from 'youtube-dl-exec';

// ========================= –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø =========================

const telegrafOptions = { handlerTimeout: 300_000 };
if (PROXY_URL) {
  telegrafOptions.telegram = { agent: new HttpsProxyAgent(PROXY_URL) };
  console.log('[Bot] –ò—Å–ø–æ–ª—å–∑—É—é –ø—Ä–æ–∫—Å–∏');
}

export const bot = new Telegraf(BOT_TOKEN, telegrafOptions);

// ========================= –•–†–ê–ù–ò–õ–ò–©–ï –°–ï–°–°–ò–ô =========================
const playlistSessions = new Map();
const TRACKS_PER_PAGE = 5;

// ========================= –£–¢–ò–õ–ò–¢–´ =========================

function escapeHtml(text) {
  if (!text) return '';
  return text.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/&/g, '&amp;');
}

function getTariffName(limit) {
  if (limit >= 10000) return 'Unlimited üíé';
  if (limit >= 100) return 'Pro üí™';
  if (limit >= 30) return 'Plus üéØ';
  return 'Free üÜì';
}

function getDaysLeft(premiumUntil) {
  if (!premiumUntil) return 0;
  const diff = new Date(premiumUntil) - new Date();
  return Math.max(Math.ceil(diff / 86400000), 0);
}

async function isSubscribed(userId) {
  if (!CHANNEL_USERNAME) return false;
  try {
    const member = await bot.telegram.getChatMember(CHANNEL_USERNAME, userId);
    return ['creator', 'administrator', 'member'].includes(member.status);
  } catch {
    return false;
  }
}

function getYoutubeDl() {
  const options = PROXY_URL ? { proxy: PROXY_URL } : {};
  return (url, flags) => execYoutubeDl(url, flags, options);
}

// ========================= MIDDLEWARE =========================

bot.use(async (ctx, next) => {
  if (!ctx.from) return next();
  
  // –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã
  const payload = ctx.startPayload || 
    (ctx.message?.text?.startsWith('/start ') ? ctx.message.text.split(' ')[1] : null);
  
  const user = await db.getUser(ctx.from.id, ctx.from.first_name, ctx.from.username, payload);
  ctx.state.user = user;
  
  if (user?.active === false) return;
  
  await db.resetDailyLimitIfNeeded(ctx.from.id);
  await db.resetExpiredPremiumIfNeeded(ctx.from.id);
  
  return next();
});

// ========================= –ö–û–ú–ê–ù–î–´ =========================

bot.start(async (ctx) => {
  const user = ctx.state.user;
  const isNew = (Date.now() - new Date(user.created_at).getTime()) < 5000;
  
  // –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã
  if (isNew) {
    await db.logUserAction(ctx.from.id, 'registration');
    await processNewUserReferral(user, ctx);
  }
  
  await ctx.reply(
    isNew ? T('start_new_user') : T('start'),
    {
      parse_mode: 'HTML',
      disable_web_page_preview: true,
      ...Markup.keyboard([
        [T('menu'), T('upgrade')],
        [T('mytracks'), T('help')]
      ]).resize()
    }
  );
});

bot.hears(T('menu'), async (ctx) => {
  const user = ctx.state.user;
  const tariff = getTariffName(user.premium_limit);
  const daysLeft = getDaysLeft(user.premium_until);
  const referralLink = `https://t.me/${ctx.botInfo.username}?start=ref_${user.id}`;
  
  let message = `
üë§ <b>${escapeHtml(user.first_name)}</b>

üíº –¢–∞—Ä–∏—Ñ: <b>${tariff}</b>
‚è≥ –û—Å—Ç–∞–ª–æ—Å—å –¥–Ω–µ–π: <b>${daysLeft}</b>
üìä –°–∫–∞—á–∞–Ω–æ —Å–µ–≥–æ–¥–Ω—è: <b>${user.downloads_today || 0}/${user.premium_limit}</b>

üë• –ü—Ä–∏–≥–ª–∞—à–µ–Ω–æ –¥—Ä—É–∑–µ–π: <b>${user.referral_count || 0}</b>
üîó –í–∞—à–∞ —Ä–µ—Ñ. —Å—Å—ã–ª–∫–∞:
<code>${referralLink}</code>
  `.trim();
  
  const extra = { parse_mode: 'HTML', disable_web_page_preview: true };
  
  if (!user.subscribed_bonus_used && CHANNEL_USERNAME) {
    extra.reply_markup = {
      inline_keyboard: [[
        Markup.button.callback('üéÅ –ü–æ–ª—É—á–∏—Ç—å –±–æ–Ω—É—Å –∑–∞ –ø–æ–¥–ø–∏—Å–∫—É', 'check_subscription')
      ]]
    };
  }
  
  await ctx.reply(message, extra);
});

bot.hears(T('mytracks'), async (ctx) => {
  try {
    const user = ctx.state.user;
    if (!user.tracks_today || user.tracks_today.length === 0) {
      return await ctx.reply(T('noTracks'));
    }
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç—Ä–µ–∫–∏ –≥—Ä—É–ø–ø–∞–º–∏ –ø–æ 10
    for (let i = 0; i < user.tracks_today.length; i += 10) {
      const chunk = user.tracks_today
        .slice(i, i + 10)
        .filter(t => t && t.fileId)
        .map(t => ({ type: 'audio', media: t.fileId }));
      
      if (chunk.length > 0) {
        await ctx.replyWithMediaGroup(chunk);
      }
    }
  } catch (err) {
    console.error('MyTracks error:', err);
    await ctx.reply('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ç—Ä–µ–∫–æ–≤');
  }
});

bot.hears(T('upgrade'), async (ctx) => {
  await ctx.reply(T('upgradeInfo'), { parse_mode: 'HTML', disable_web_page_preview: true });
});

bot.hears(T('help'), async (ctx) => {
  await ctx.reply(T('helpInfo'), { parse_mode: 'HTML', disable_web_page_preview: true });
});

bot.command('referral', handleReferralCommand);

// ========================= INLINE SEARCH =========================

bot.on('inline_query', async (ctx) => {
  const query = ctx.inlineQuery.query;
  
  if (!query || query.trim().length < 2) {
    return await ctx.answerInlineQuery([], {
      switch_pm_text: '–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç—Ä–µ–∫–∞...',
      switch_pm_parameter: 'start'
    });
  }
  
  try {
    const results = await performInlineSearch(query, ctx.from.id);
    await ctx.answerInlineQuery(results, { cache_time: 60 });
  } catch (err) {
    console.error('Inline search error:', err);
    await ctx.answerInlineQuery([]);
  }
});

// ========================= –ê–î–ú–ò–ù –ö–û–ú–ê–ù–î–´ =========================

bot.command('admin', async (ctx) => {
  if (ctx.from.id !== ADMIN_ID) return;
  
  try {
    const [users, cachedCount, newToday, newWeek] = await Promise.all([
      db.getAllUsers(true),
      db.getCachedTracksCount(),
      db.getNewUsersCount(1),
      db.getNewUsersCount(7)
    ]);
    
    const totalUsers = users.length;
    const activeToday = users.filter(u => {
      return u.last_active && 
        new Date(u.last_active).toDateString() === new Date().toDateString();
    }).length;
    const totalDownloads = users.reduce((sum, u) => sum + (u.total_downloads || 0), 0);
    
    const message = `
üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–æ—Ç–∞</b>

üë• –í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: ${totalUsers}
üìà –ê–∫—Ç–∏–≤–Ω—ã—Ö —Å–µ–≥–æ–¥–Ω—è: ${activeToday}
üÜï –ù–æ–≤—ã—Ö –∑–∞ 24—á: ${newToday}
üÜï –ù–æ–≤—ã—Ö –∑–∞ –Ω–µ–¥–µ–ª—é: ${newWeek}

üíæ –¢—Ä–µ–∫–æ–≤ –≤ –∫—ç—à–µ: ${cachedCount}
üì• –í—Å–µ–≥–æ –∑–∞–≥—Ä—É–∑–æ–∫: ${totalDownloads}
‚è≥ –í –æ—á–µ—Ä–µ–¥–∏: ${downloadQueue.size}

üîß –û–±—Å–ª—É–∂–∏–≤–∞–Ω–∏–µ: ${isMaintenanceMode() ? '–í–ö–õ' : '–í–´–ö–õ'}
üîó <a href="${WEBHOOK_URL}/dashboard">–î–∞—à–±–æ—Ä–¥</a>
    `.trim();
    
    await ctx.reply(message, { parse_mode: 'HTML', disable_web_page_preview: true });
  } catch (err) {
    console.error('Admin error:', err);
    await ctx.reply('‚ùå –û—à–∏–±–∫–∞');
  }
});

bot.command('maintenance', async (ctx) => {
  if (ctx.from.id !== ADMIN_ID) return;
  
  const arg = ctx.message.text.split(' ')[1];
  
  if (arg === 'on') {
    setMaintenanceMode(true);
    await ctx.reply('‚úÖ –†–µ–∂–∏–º –æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏—è –≤–∫–ª—é—á–µ–Ω');
  } else if (arg === 'off') {
    setMaintenanceMode(false);
    await ctx.reply('‚úÖ –†–µ–∂–∏–º –æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏—è –≤—ã–∫–ª—é—á–µ–Ω');
  } else {
    await ctx.reply(`–°—Ç–∞—Ç—É—Å: ${isMaintenanceMode() ? '–í–ö–õ' : '–í–´–ö–õ'}\n/maintenance on –∏–ª–∏ off`);
  }
});

// ========================= –ü–õ–ï–ô–õ–ò–°–¢–´ =========================

// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –º–µ–Ω—é –¥–ª—è –ø–ª–µ–π–ª–∏—Å—Ç–æ–≤
function generatePlaylistMenu(session) {
  const { tracks, selected, currentPage, playlistId, title } = session;
  const totalPages = Math.ceil(tracks.length / TRACKS_PER_PAGE);
  const start = currentPage * TRACKS_PER_PAGE;
  const tracksOnPage = tracks.slice(start, start + TRACKS_PER_PAGE);
  
  // –ö–Ω–æ–ø–∫–∏ —Ç—Ä–µ–∫–æ–≤
  const trackButtons = tracksOnPage.map((track, i) => {
    const index = start + i;
    const icon = selected.has(index) ? '‚úÖ' : '‚¨úÔ∏è';
    const name = (track.title || 'Track').slice(0, 40);
    return [Markup.button.callback(`${icon} ${name}`, `pl_toggle:${playlistId}:${index}`)];
  });
  
  // –ù–∞–≤–∏–≥–∞—Ü–∏—è
  const navRow = [];
  if (currentPage > 0) {
    navRow.push(Markup.button.callback('‚¨ÖÔ∏è', `pl_page:${playlistId}:${currentPage - 1}`));
  }
  navRow.push(Markup.button.callback(`${currentPage + 1}/${totalPages}`, 'pl_noop'));
  if (currentPage < totalPages - 1) {
    navRow.push(Markup.button.callback('‚û°Ô∏è', `pl_page:${playlistId}:${currentPage + 1}`));
  }
  
  // –î–µ–π—Å—Ç–≤–∏—è
  const actionRow = [
    Markup.button.callback(`‚úÖ –°–∫–∞—á–∞—Ç—å (${selected.size})`, `pl_done:${playlistId}`),
    Markup.button.callback('‚ùå –û—Ç–º–µ–Ω–∞', `pl_cancel:${playlistId}`)
  ];
  
  return {
    text: `üé∂ <b>${escapeHtml(title)}</b>\n–í—ã–±–µ—Ä–∏—Ç–µ —Ç—Ä–µ–∫–∏:`,
    keyboard: [...trackButtons, navRow, actionRow]
  };
}

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–Ω–æ–ø–æ–∫ –ø–ª–µ–π–ª–∏—Å—Ç–æ–≤
bot.action('pl_noop', ctx => ctx.answerCbQuery());

bot.action(/pl_toggle:(.+):(\d+)/, async (ctx) => {
  const [playlistId, indexStr] = ctx.match.slice(1);
  const session = playlistSessions.get(ctx.from.id);
  
  if (!session || session.playlistId !== playlistId) {
    return await ctx.answerCbQuery('–°–µ—Å—Å–∏—è –∏—Å—Ç–µ–∫–ª–∞', { show_alert: true });
  }
  
  const index = parseInt(indexStr);
  if (session.selected.has(index)) {
    session.selected.delete(index);
  } else {
    session.selected.add(index);
  }
  
  const menu = generatePlaylistMenu(session);
  await ctx.editMessageText(menu.text, {
    parse_mode: 'HTML',
    ...Markup.inlineKeyboard(menu.keyboard)
  });
  await ctx.answerCbQuery();
});

bot.action(/pl_page:(.+):(\d+)/, async (ctx) => {
  const [playlistId, pageStr] = ctx.match.slice(1);
  const session = playlistSessions.get(ctx.from.id);
  
  if (!session || session.playlistId !== playlistId) {
    return await ctx.answerCbQuery('–°–µ—Å—Å–∏—è –∏—Å—Ç–µ–∫–ª–∞', { show_alert: true });
  }
  
  session.currentPage = parseInt(pageStr);
  const menu = generatePlaylistMenu(session);
  await ctx.editMessageText(menu.text, {
    parse_mode: 'HTML',
    ...Markup.inlineKeyboard(menu.keyboard)
  });
  await ctx.answerCbQuery();
});

bot.action(/pl_done:(.+)/, async (ctx) => {
  const playlistId = ctx.match[1];
  const session = playlistSessions.get(ctx.from.id);
  
  if (!session || session.playlistId !== playlistId) {
    return await ctx.answerCbQuery('–°–µ—Å—Å–∏—è –∏—Å—Ç–µ–∫–ª–∞', { show_alert: true });
  }
  
  if (session.selected.size === 0) {
    return await ctx.answerCbQuery('–í—ã–±–µ—Ä–∏—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω —Ç—Ä–µ–∫', { show_alert: true });
  }
  
  const user = ctx.state.user;
  const remaining = user.premium_limit - user.downloads_today;
  
  if (remaining <= 0) {
    await ctx.editMessageText(T('limitReached'), { parse_mode: 'HTML' });
    playlistSessions.delete(ctx.from.id);
    return;
  }
  
  const selectedTracks = Array.from(session.selected)
    .slice(0, remaining)
    .map(i => session.tracks[i]);
  
  await ctx.editMessageText(`‚úÖ –î–æ–±–∞–≤–ª—è—é ${selectedTracks.length} —Ç—Ä–µ–∫–æ–≤ –≤ –æ—á–µ—Ä–µ–¥—å...`);
  
  // –î–æ–±–∞–≤–ª—è–µ–º —Ç—Ä–µ–∫–∏ –≤ –æ—á–µ—Ä–µ–¥—å
  for (const track of selectedTracks) {
    enqueue(ctx, ctx.from.id, track.webpage_url || track.url);
  }
  
  playlistSessions.delete(ctx.from.id);
});

bot.action(/pl_cancel:(.+)/, async (ctx) => {
  playlistSessions.delete(ctx.from.id);
  await ctx.deleteMessage().catch(() => {});
  await ctx.answerCbQuery('–û—Ç–º–µ–Ω–µ–Ω–æ');
});

// ========================= CALLBACK ACTIONS =========================

bot.action('check_subscription', async (ctx) => {
  try {
    const user = ctx.state.user;
    
    if (user.subscribed_bonus_used) {
      return await ctx.answerCbQuery('–í—ã —É–∂–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –±–æ–Ω—É—Å', { show_alert: true });
    }
    
    const subscribed = await isSubscribed(ctx.from.id);
    
    if (subscribed) {
      await db.setPremium(ctx.from.id, 30, 7);
      await db.updateUserField(ctx.from.id, 'subscribed_bonus_used', true);
      await db.logUserAction(ctx.from.id, 'bonus_received');
      
      await ctx.answerCbQuery('‚úÖ –ë–æ–Ω—É—Å –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω!');
      await ctx.editMessageText('üéâ –í–∞–º –Ω–∞—á–∏—Å–ª–µ–Ω–æ 7 –¥–Ω–µ–π —Ç–∞—Ä–∏—Ñ–∞ Plus!');
    } else {
      await ctx.answerCbQuery('–°–Ω–∞—á–∞–ª–∞ –ø–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –∫–∞–Ω–∞–ª!', { show_alert: true });
    }
  } catch (err) {
    console.error('Bonus error:', err);
    await ctx.answerCbQuery('–û—à–∏–±–∫–∞', { show_alert: true });
  }
});

// ========================= –û–ë–†–ê–ë–û–¢–ö–ê –°–°–´–õ–û–ö =========================

async function handleSoundCloudUrl(ctx, url) {
  try {
    const youtubeDl = getYoutubeDl();
    const data = await youtubeDl(url, { dumpSingleJson: true, flatPlaylist: true });
    
    if (!data) throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ');
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —ç—Ç–æ –ø–ª–µ–π–ª–∏—Å—Ç –∏–ª–∏ —Ç—Ä–µ–∫
    if (data.entries && data.entries.length > 1) {
      // –ü–ª–µ–π–ª–∏—Å—Ç - —Å–æ–∑–¥–∞–µ–º —Å–µ—Å—Å–∏—é –¥–ª—è –≤—ã–±–æ—Ä–∞
      const playlistId = `pl_${Date.now()}`;
      playlistSessions.set(ctx.from.id, {
        playlistId,
        title: data.title || '–ü–ª–µ–π–ª–∏—Å—Ç',
        tracks: data.entries,
        originalUrl: url,
        selected: new Set(),
        currentPage: 0
      });
      
      await ctx.reply(
        `üé∂ –ù–∞–π–¥–µ–Ω –ø–ª–µ–π–ª–∏—Å—Ç: <b>${escapeHtml(data.title)}</b>\n` +
        `–¢—Ä–µ–∫–æ–≤: <b>${data.entries.length}</b>\n\n–ß—Ç–æ –¥–µ–ª–∞–µ–º?`,
        {
          parse_mode: 'HTML',
          ...Markup.inlineKeyboard([
            [Markup.button.callback(`üì• –°–∫–∞—á–∞—Ç—å –≤—Å–µ`, `pl_done:${playlistId}`)],
            [Markup.button.callback('‚úèÔ∏è –í—ã–±—Ä–∞—Ç—å —Ç—Ä–µ–∫–∏', `pl_select:${playlistId}`)],
            [Markup.button.callback('‚ùå –û—Ç–º–µ–Ω–∞', `pl_cancel:${playlistId}`)]
          ])
        }
      );
    } else {
      // –û–¥–∏–Ω–æ—á–Ω—ã–π —Ç—Ä–µ–∫ - —Å—Ä–∞–∑—É –≤ –æ—á–µ—Ä–µ–¥—å
      enqueue(ctx, ctx.from.id, url);
    }
  } catch (err) {
    console.error('SoundCloud URL error:', err);
    await ctx.reply('‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å —Å—Å—ã–ª–∫—É');
  }
}

bot.action(/pl_select:(.+)/, async (ctx) => {
  const playlistId = ctx.match[1];
  const session = playlistSessions.get(ctx.from.id);
  
  if (!session || session.playlistId !== playlistId) {
    return await ctx.answerCbQuery('–°–µ—Å—Å–∏—è –∏—Å—Ç–µ–∫–ª–∞', { show_alert: true });
  }
  
  const menu = generatePlaylistMenu(session);
  await ctx.editMessageText(menu.text, {
    parse_mode: 'HTML',
    ...Markup.inlineKeyboard(menu.keyboard)
  });
  await ctx.answerCbQuery();
});

bot.on('text', async (ctx) => {
  if (ctx.chat.type !== 'private') return;
  
  const text = ctx.message.text;
  if (text.startsWith('/')) return;
  if (Object.values(allTextsSync()).includes(text)) return;
  
  if (isMaintenanceMode() && ctx.from.id !== ADMIN_ID) {
    return await ctx.reply('‚è≥ –ë–æ—Ç –Ω–∞ –æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —á–µ—Ä–µ–∑ 5 –º–∏–Ω—É—Ç.');
  }
  
  const urlMatch = text.match(/(https?:\/\/[^\s]+)/);
  if (!urlMatch) {
    return await ctx.reply('–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å—Å—ã–ª–∫—É –Ω–∞ —Ç—Ä–µ–∫ SoundCloud');
  }
  
  const url = urlMatch[0];
  
  if (!url.includes('soundcloud.com')) {
    return await ctx.reply('–Ø —Ä–∞–±–æ—Ç–∞—é —Ç–æ–ª—å–∫–æ —Å SoundCloud');
  }
  
  const user = ctx.state.user;
  if (user.downloads_today >= user.premium_limit) {
    let message = T('limitReached');
    const extra = { parse_mode: 'HTML' };
    
    if (!user.subscribed_bonus_used && CHANNEL_USERNAME) {
      message += '\n\nüéÅ –ò–ª–∏ –ø–æ–ª—É—á–∏—Ç–µ 7 –¥–Ω–µ–π Plus –∑–∞ –ø–æ–¥–ø–∏—Å–∫—É!';
      extra.reply_markup = {
        inline_keyboard: [[
          Markup.button.callback('üéÅ –ü–æ–ª—É—á–∏—Ç—å –±–æ–Ω—É—Å', 'check_subscription')
        ]]
      };
    }
    
    return await ctx.reply(message, extra);
  }
  
  handleSoundCloudUrl(ctx, url);
});

// ========================= –û–ë–†–ê–ë–û–¢–ö–ê –û–®–ò–ë–û–ö =========================

bot.catch((err, ctx) => {
  console.error(`Error for ${ctx.updateType}:`, err);
  
  if (ADMIN_ID) {
    bot.telegram.sendMessage(
      ADMIN_ID, 
      `‚ö†Ô∏è –û—à–∏–±–∫–∞:\n${err.message || err}\nUpdate: ${ctx.updateType}`
    ).catch(() => {});
  }
});