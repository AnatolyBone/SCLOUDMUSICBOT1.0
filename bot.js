// ======================= –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–ê–Ø –í–ï–†–°–ò–Ø BOT.JS =======================

// ======================= –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–ê–Ø –í–ï–†–°–ò–Ø BOT.JS =======================

import { Telegraf, Markup, TelegramError } from 'telegraf';
import { HttpsProxyAgent } from 'https-proxy-agent';
import scdl from 'soundcloud-downloader'; // üî• –î–û–ë–ê–í–õ–ï–ù–û
import { ADMIN_ID, BOT_TOKEN, WEBHOOK_URL, CHANNEL_USERNAME, STORAGE_CHANNEL_ID, PROXY_URL } from './config.js';
import { 
    updateUserField, getUser, createUser, setPremium, getAllUsers, 
    resetDailyLimitIfNeeded, getCachedTracksCount, logUserAction, 
    getTopFailedSearches, getTopRecentSearches, getNewUsersCount,
    findCachedTrack, incrementDownloadsAndSaveTrack, getReferrerInfo, 
    getReferredUsers, resetExpiredPremiumIfNeeded, getReferralStats
} from './db.js';
import { T, allTextsSync } from './config/texts.js';
import { performInlineSearch } from './services/searchManager.js';
import { spotifyEnqueue } from './services/spotifyManager.js';
import { downloadQueue, enqueue as soundcloudEnqueue } from './services/downloadManager.js';
import { handleReferralCommand, processNewUserReferral } from './services/referralManager.js';
import { isShuttingDown, isMaintenanceMode, setMaintenanceMode } from './services/appState.js';

function escapeHtml(text) {
    if (typeof text !== 'string') return '';
    return text.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/&/g, '&amp;');
}

async function isSubscribed(userId) {
    if (!CHANNEL_USERNAME) return false;
    try {
        const member = await bot.telegram.getChatMember(CHANNEL_USERNAME, userId);
        return ['creator', 'administrator', 'member'].includes(member.status);
    } catch (e) {
        console.error(`–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–¥–ø–∏—Å–∫–∏ –¥–ª—è ${userId}:`, e.message);
        return false;
    }
}

function getTariffName(limit) {
    if (limit >= 10000) return 'Unlimited ‚Äî üíé';
    if (limit >= 100) return 'Pro ‚Äî 100 üí™';
    if (limit >= 30) return 'Plus ‚Äî 30 üéØ';
    return 'üÜì Free ‚Äî 5 üü¢';
}

function getDaysLeft(premiumUntil) {
    if (!premiumUntil) return 0;
    const diff = new Date(premiumUntil) - new Date();
    return Math.max(Math.ceil(diff / 86400000), 0);
}

function formatMenuMessage(user, botUsername) {
    const tariffLabel = getTariffName(user.premium_limit);
    const downloadsToday = user.downloads_today || 0;
    const daysLeft = getDaysLeft(user.premium_until);
    const referralCount = user.referral_count || 0;
    const referralLink = `https://t.me/${botUsername}?start=ref_${user.id}`;
    
    const statsBlock = [
        `üíº <b>–¢–∞—Ä–∏—Ñ:</b> <i>${tariffLabel}</i>`,
        `‚è≥ <b>–û—Å—Ç–∞–ª–æ—Å—å –¥–Ω–µ–π –ø–æ–¥–ø–∏—Å–∫–∏:</b> <i>${daysLeft}</i>`,
        `üéß <b>–°–µ–≥–æ–¥–Ω—è —Å–∫–∞—á–∞–Ω–æ:</b> <i>${downloadsToday}</i> –∏–∑ <i>${user.premium_limit}</i>`
    ].join('\n');
    
    const header = T('menu_header').replace('{first_name}', escapeHtml(user.first_name) || '–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å');
    
    const referralBlock = T('menu_referral_block')
        .replace('{referral_count}', referralCount)
        .replace('{referral_link}', referralLink);
    
    let bonusBlock = '';
    if (!user.subscribed_bonus_used && CHANNEL_USERNAME) {
        const cleanUsername = CHANNEL_USERNAME.replace('@', '');
        const channelLink = `<a href="https://t.me/${cleanUsername}">–Ω–∞—à –∫–∞–Ω–∞–ª</a>`;
        bonusBlock = T('menu_bonus_block').replace('{channel_link}', channelLink);
    }
    
    const footer = T('menu_footer');
    
    const messageParts = [header, statsBlock, '\n- - - - - - - - - - - - - - -', referralBlock, bonusBlock, footer];
    return messageParts.filter(Boolean).join('\n\n');
}

// ========================= PLAYLIST SESSIONS =========================

const playlistSessions = new Map();
const TRACKS_PER_PAGE = 5;

function generateInitialPlaylistMenu(playlistId, trackCount) {
    return Markup.inlineKeyboard([
        [Markup.button.callback(`üì• –°–∫–∞—á–∞—Ç—å –≤—Å–µ (${trackCount})`, `pl_download_all:${playlistId}`)],
        [Markup.button.callback('üì• –°–∫–∞—á–∞—Ç—å –ø–µ—Ä–≤—ã–µ 10', `pl_download_10:${playlistId}`)],
        [Markup.button.callback('üìù –í—ã–±—Ä–∞—Ç—å —Ç—Ä–µ–∫–∏ –≤—Ä—É—á–Ω—É—é', `pl_select_manual:${playlistId}`)],
        [Markup.button.callback('‚ùå –û—Ç–º–µ–Ω–∞', `pl_cancel:${playlistId}`)]
    ]);
}

function generateSelectionMenu(userId) {
    const session = playlistSessions.get(userId);
    if (!session) return null;
    
    const { tracks, selected, currentPage, playlistId, title } = session;
    const totalPages = Math.ceil(tracks.length / TRACKS_PER_PAGE);
    const startIndex = currentPage * TRACKS_PER_PAGE;
    const tracksOnPage = tracks.slice(startIndex, startIndex + TRACKS_PER_PAGE);
    
    const trackRows = tracksOnPage.map((track, index) => {
        const absoluteIndex = startIndex + index;
        const isSelected = selected.has(absoluteIndex);
        const icon = isSelected ? '‚úÖ' : '‚¨úÔ∏è';
        const trackTitleText = track.title || '–¢—Ä–µ–∫ –±–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è';
        const trackTitle = trackTitleText.length > 50 ? trackTitleText.slice(0, 47) + '...' : trackTitleText;
        return [Markup.button.callback(`${icon} ${trackTitle}`, `pl_toggle:${playlistId}:${absoluteIndex}`)];
    });
    
    const navRow = [];
    if (currentPage > 0) navRow.push(Markup.button.callback('‚¨ÖÔ∏è –ù–∞–∑–∞–¥', `pl_page:${playlistId}:${currentPage - 1}`));
    navRow.push(Markup.button.callback(`${currentPage + 1}/${totalPages}`, 'pl_nop'));
    if (currentPage < totalPages - 1) navRow.push(Markup.button.callback('–í–ø–µ—Ä–µ–¥ ‚û°Ô∏è', `pl_page:${playlistId}:${currentPage + 1}`));
    
    const actionRow = [
        Markup.button.callback(`‚úÖ –ì–æ—Ç–æ–≤–æ (${selected.size})`, `pl_finish:${playlistId}`),
        Markup.button.callback(`‚ùå –û—Ç–º–µ–Ω–∞`, `pl_cancel:${playlistId}`)
    ];
    
    const messageText = `üé∂ <b>${title}</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ —Ç—Ä–µ–∫–∏ (–°—Ç—Ä. ${currentPage + 1}/${totalPages}):`;
    
    return {
        text: messageText,
        options: { parse_mode: 'HTML', ...Markup.inlineKeyboard([...trackRows, navRow, actionRow]) }
    };
}

// ========================= TELEGRAF INIT =========================

const telegrafOptions = { handlerTimeout: 300_000 };
if (PROXY_URL) {
    const agent = new HttpsProxyAgent(PROXY_URL);
    telegrafOptions.telegram = { agent };
    console.log('[App] –ò—Å–ø–æ–ª—å–∑—É—é –ø—Ä–æ–∫—Å–∏ –¥–ª—è Telegram API.');
}

export const bot = new Telegraf(BOT_TOKEN, telegrafOptions);

// ========================= MIDDLEWARE =========================

bot.catch(async (err, ctx) => {
    console.error(`üî¥ [Telegraf Catch] –ì–ª–æ–±–∞–ª—å–Ω–∞—è –æ—à–∏–±–∫–∞ –¥–ª—è update ${ctx.update.update_id}:`, err);
    
    const updateInfo = ctx.update ? JSON.stringify(ctx.update, null, 2) : 'N/A';
    const errorMessage = `
üî¥ <b>–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ –±–æ—Ç–µ!</b>

<b>–¢–∏–ø –æ—à–∏–±–∫–∏:</b>
<code>${err.name || 'UnknownError'}</code>

<b>–°–æ–æ–±—â–µ–Ω–∏–µ:</b>
<code>${err.message || 'No message'}</code>

<b>–ì–¥–µ –ø—Ä–æ–∏–∑–æ—à–ª–∞:</b>
<code>${err.stack ? err.stack.split('\n')[1].trim() : 'Stack trace unavailable'}</code>

<b>Update:</b>
<pre><code class="language-json">${updateInfo.slice(0, 3500)}</code></pre>
    `;
    
    try {
        await bot.telegram.sendMessage(ADMIN_ID, errorMessage, { parse_mode: 'HTML' });
    } catch (sendError) {
        console.error('üî• –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∞–¥–º–∏–Ω—É!', sendError);
    }
    
    if (err instanceof TelegramError && err.response?.error_code === 403) {
        if (ctx.from?.id) {
            await updateUserField(ctx.from.id, 'active', false);
        }
    }
});

bot.use(async (ctx, next) => {
    if (!ctx.from) return next();
    
    const payload =
        (typeof ctx.startPayload === 'string' && ctx.startPayload) ||
        (ctx.message?.text?.startsWith('/start ') ? ctx.message.text.split(' ')[1] : null) ||
        null;
    
    const user = await getUser(ctx.from.id, ctx.from.first_name, ctx.from.username, payload);
    ctx.state.user = user;
    
    if (user && user.active === false) return;
    
    if (user && user.can_receive_broadcasts === false) {
        try { 
            await updateUserField(user.id, { can_receive_broadcasts: true }); 
        } catch (e) {
            console.error('[Broadcast flag] update error:', e.message);
        }
    }
    
    await resetDailyLimitIfNeeded(ctx.from.id);
    await resetExpiredPremiumIfNeeded(ctx.from.id);
    return next();
});

// ========================= COMMANDS =========================

bot.start(async (ctx) => {
    console.log('[START] got start for', ctx.from.id, 'payload=', ctx.startPayload);
    
    const user = await getUser(ctx.from.id, ctx.from.first_name, ctx.from.username, ctx.startPayload || null);
    const isNewRegistration = (Date.now() - new Date(user.created_at).getTime()) < 5000;
    
    if (isNewRegistration) {
        await logUserAction(ctx.from.id, 'registration');
        await processNewUserReferral(user, ctx);
    }
    
    const startMessage = isNewRegistration ? T('start_new_user') : T('start');
    
    await ctx.reply(startMessage, {
        parse_mode: 'HTML',
        disable_web_page_preview: true,
        ...Markup.keyboard([
            [T('menu'), T('upgrade')],
            [T('mytracks'), T('help')]
        ]).resize()
    });
});

bot.command('admin', async (ctx) => {
    if (ctx.from.id !== ADMIN_ID) return;
    
    try {
        await ctx.reply('‚è≥ –°–æ–±–∏—Ä–∞—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É...');
        
        const [users, cachedTracksCount, topFailed, topRecent, newUsersToday, newUsersWeek] = await Promise.all([
            getAllUsers(true),
            getCachedTracksCount(),
            getTopFailedSearches(5),
            getTopRecentSearches(5),
            getNewUsersCount(1),
            getNewUsersCount(7)
        ]);
        
        const totalUsers = users.length;
        const activeUsers = users.filter(u => u.active).length;
        const activeToday = users.filter(u => u.last_active && new Date(u.last_active).toDateString() === new Date().toDateString()).length;
        const totalDownloads = users.reduce((sum, u) => sum + (u.total_downloads || 0), 0);
        let storageStatusText = STORAGE_CHANNEL_ID ? '‚úÖ –î–æ—Å—Ç—É–ø–µ–Ω' : '‚ö†Ô∏è –ù–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω';
        
        let statsMessage = `<b>üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ë–æ—Ç–∞</b>\n\n` +
            `<b>üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏:</b>\n` +
            `   - –í—Å–µ–≥–æ: <i>${totalUsers}</i>\n` +
            `   - –ê–∫—Ç–∏–≤–Ω—ã—Ö: <i>${activeUsers}</i>\n` +
            `   - <b>–ù–æ–≤—ã—Ö –∑–∞ 24—á: <i>${newUsersToday}</i></b>\n` +
            `   - <b>–ù–æ–≤—ã—Ö –∑–∞ 7 –¥–Ω–µ–π: <i>${newUsersWeek}</i></b>\n` +
            `   - –ê–∫—Ç–∏–≤–Ω—ã—Ö —Å–µ–≥–æ–¥–Ω—è: <i>${activeToday}</i>\n\n` +
            `<b>üì• –ó–∞–≥—Ä—É–∑–∫–∏:</b>\n   - –í—Å–µ–≥–æ –∑–∞ –≤—Å–µ –≤—Ä–µ–º—è: <i>${totalDownloads}</i>\n\n`;
        
                if (topFailed.length > 0) {
            statsMessage += `---\n\n<b>üî• –¢–æ–ø-5 –Ω–µ—É–¥–∞—á–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ (–≤—Å–µ–≥–æ):</b>\n`;
            topFailed.forEach((item, index) => {
                statsMessage += `${index + 1}. <code>${item.query.slice(0, 30)}</code> (–∏—Å–∫–∞–ª–∏ <i>${item.search_count}</i> —Ä–∞–∑)\n`;
            });
            statsMessage += `\n`;
        }
        
        if (topRecent.length > 0) {
            statsMessage += `<b>üìà –¢–æ–ø-5 –∑–∞–ø—Ä–æ—Å–æ–≤ (–∑–∞ 24 —á–∞—Å–∞):</b>\n`;
            topRecent.forEach((item, index) => {
                statsMessage += `${index + 1}. <code>${item.query.slice(0, 30)}</code> (–∏—Å–∫–∞–ª–∏ <i>${item.total}</i> —Ä–∞–∑)\n`;
            });
            statsMessage += `\n`;
        }
        
        statsMessage += `---\n\n<b>‚öôÔ∏è –°–∏—Å—Ç–µ–º–∞:</b>\n` +
            `   - –û—á–µ—Ä–µ–¥—å: <i>${downloadQueue.size}</i> –≤ –æ–∂. / <i>${downloadQueue.pending}</i> –≤ —Ä–∞–±.\n` +
            `   - –ö–∞–Ω–∞–ª-—Ö—Ä–∞–Ω–∏–ª–∏—â–µ: <i>${storageStatusText}</i>\n   - –¢—Ä–µ–∫–æ–≤ –≤ –∫—ç—à–µ: <i>${cachedTracksCount}</i>\n\n` +
            `<b>üîó –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å:</b>\n<a href="${WEBHOOK_URL.replace(/\/$/, '')}/dashboard">–û—Ç–∫—Ä—ã—Ç—å –¥–∞—à–±–æ—Ä–¥</a>`;
        
        await ctx.reply(statsMessage, { parse_mode: 'HTML', disable_web_page_preview: true });
    } catch (e) {
        console.error('‚ùå –û—à–∏–±–∫–∞ –≤ –∫–æ–º–∞–Ω–¥–µ /admin:', e);
        await ctx.reply('‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–±—Ä–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É.');
    }
});

bot.command('referral', handleReferralCommand);

bot.command('maintenance', (ctx) => {
    if (ctx.from.id !== ADMIN_ID) return;
    
    const command = ctx.message.text.split(' ')[1]?.toLowerCase();
    
    if (command === 'on') {
        setMaintenanceMode(true);
        ctx.reply('‚úÖ –†–µ–∂–∏–º –æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏—è –í–ö–õ–Æ–ß–ï–ù.');
    } else if (command === 'off') {
        setMaintenanceMode(false);
        ctx.reply('‚òëÔ∏è –†–µ–∂–∏–º –æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏—è –í–´–ö–õ–Æ–ß–ï–ù.');
    } else {
        ctx.reply('‚ÑπÔ∏è –°—Ç–∞—Ç—É—Å: ' + (isMaintenanceMode() ? '–í–ö–õ–Æ–ß–ï–ù' : '–í–´–ö–õ–Æ–ß–ï–ù') + '\n\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: `/maintenance on` –∏–ª–∏ `/maintenance off`');
    }
});

bot.command('premium', (ctx) => ctx.reply(T('upgradeInfo'), { parse_mode: 'HTML', disable_web_page_preview: true }));

// ========================= ACTIONS =========================

bot.action('check_subscription', async (ctx) => {
    try {
        console.log(`[Bonus] User ${ctx.from.id} –ø—ã—Ç–∞–µ—Ç—Å—è –ø–æ–ª—É—á–∏—Ç—å –±–æ–Ω—É—Å.`);

        const user = await getUser(ctx.from.id);
        if (user.subscribed_bonus_used) {
            console.log(`[Bonus] User ${ctx.from.id} —É–∂–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª –±–æ–Ω—É—Å.`);
            return await ctx.answerCbQuery('–í—ã —É–∂–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ —ç—Ç–æ—Ç –±–æ–Ω—É—Å.', { show_alert: true });
        }

        console.log(`[Bonus] –ü—Ä–æ–≤–µ—Ä—è—é –ø–æ–¥–ø–∏—Å–∫—É –¥–ª—è ${ctx.from.id} –Ω–∞ –∫–∞–Ω–∞–ª ${CHANNEL_USERNAME}`);
        const subscribed = await isSubscribed(ctx.from.id);

        if (subscribed) {
            console.log(`[Bonus] User ${ctx.from.id} –ø–æ–¥–ø–∏—Å–∞–Ω. –ù–∞—á–∏—Å–ª—è—é –±–æ–Ω—É—Å.`);
            await setPremium(ctx.from.id, 30, 7);
            await updateUserField(ctx.from.id, 'subscribed_bonus_used', true);
            await logUserAction(ctx.from.id, 'bonus_received');
            
            await ctx.answerCbQuery('–ë–æ–Ω—É—Å –Ω–∞—á–∏—Å–ª–µ–Ω!');
            await ctx.editMessageText('üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í–∞–º –Ω–∞—á–∏—Å–ª–µ–Ω–æ 7 –¥–Ω–µ–π —Ç–∞—Ä–∏—Ñ–∞ Plus. –°–ø–∞—Å–∏–±–æ –∑–∞ –ø–æ–¥–ø–∏—Å–∫—É!');

        } else {
            console.log(`[Bonus] User ${ctx.from.id} –ù–ï –ø–æ–¥–ø–∏—Å–∞–Ω.`);
            return await ctx.answerCbQuery(`–í—ã –µ—â–µ –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ –∫–∞–Ω–∞–ª ${CHANNEL_USERNAME}. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –∏ –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É —Å–Ω–æ–≤–∞.`, { show_alert: true });
        }
    } catch (e) {
        console.error(`üî¥ –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê –≤ check_subscription –¥–ª—è user ${ctx.from.id}:`, e);
        await ctx.answerCbQuery('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.', { show_alert: true });
    }
});

// ========================= KEYBOARD HANDLERS =========================

bot.hears(T('menu'), async (ctx) => {
    const user = await getUser(ctx.from.id);
    const message = formatMenuMessage(user, ctx.botInfo.username);

    const extraOptions = { 
        parse_mode: 'HTML',
        disable_web_page_preview: true
    };
    
    if (!user.subscribed_bonus_used && CHANNEL_USERNAME) {
        extraOptions.reply_markup = { 
            inline_keyboard: [[ Markup.button.callback('‚úÖ –Ø –ø–æ–¥–ø–∏—Å–∞–ª—Å—è –∏ —Ö–æ—á—É –±–æ–Ω—É—Å!', 'check_subscription') ]] 
        };
    }
    
    await ctx.reply(message, extraOptions);
});

bot.hears(T('mytracks'), async (ctx) => {
    try {
        const user = await getUser(ctx.from.id);
        if (!user.tracks_today || user.tracks_today.length === 0) {
            return await ctx.reply(T('noTracks'));
        }
        
        for (let i = 0; i < user.tracks_today.length; i += 10) {
            const chunk = user.tracks_today.slice(i, i + 10).filter(t => t && t.fileId);
            if (chunk.length > 0) {
                await ctx.replyWithMediaGroup(chunk.map(t => ({ type: 'audio', media: t.fileId })));
            }
        }
    } catch (e) {
        console.error(`üî¥ –û—à–∏–±–∫–∞ –≤ mytracks –¥–ª—è ${ctx.from.id}:`, e.message);
    }
});

bot.hears(T('help'), (ctx) => ctx.reply(T('helpInfo'), { parse_mode: 'HTML', disable_web_page_preview: true }));
bot.hears(T('upgrade'), (ctx) => ctx.reply(T('upgradeInfo'), { parse_mode: 'HTML', disable_web_page_preview: true }));

// ========================= INLINE QUERY =========================

bot.on('inline_query', async (ctx) => {
    const query = ctx.inlineQuery.query;
    if (!query || query.trim().length < 2) {
        return await ctx.answerInlineQuery([], { 
            switch_pm_text: '–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç—Ä–µ–∫–∞ –¥–ª—è –ø–æ–∏—Å–∫–∞...', 
            switch_pm_parameter: 'start' 
        });
    }
    
    try {
        const results = await performInlineSearch(query, ctx.from.id);
        await ctx.answerInlineQuery(results, { cache_time: 60 });
    } catch (error) {
        console.error('[Inline Query] –ì–ª–æ–±–∞–ª—å–Ω–∞—è –æ—à–∏–±–∫–∞:', error);
        await ctx.answerInlineQuery([]);
    }
});

// ========================= PLAYLIST ACTIONS =========================

bot.action('pl_nop', (ctx) => ctx.answerCbQuery());

bot.action(/pl_download_all:|pl_download_10:/, async (ctx) => {
    const isAll = ctx.callbackQuery.data.includes('pl_download_all');
    const playlistId = ctx.callbackQuery.data.split(':')[1];
    const userId = ctx.from.id;
    const session = playlistSessions.get(userId);
    
    if (!session) {
        return await ctx.answerCbQuery('‚ùóÔ∏è –°–µ—Å—Å–∏—è –≤—ã–±–æ—Ä–∞ –∏—Å—Ç–µ–∫–ª–∞.', { show_alert: true });
    }
    
    // –î–æ–∑–∞–≥—Ä—É–∑–∫–∞ –ø–æ–ª–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
    if (!session.fullTracks) {
        await ctx.answerCbQuery('‚è≥ –ü–æ–ª—É—á–∞—é –ø–æ–ª–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–ª–µ–π–ª–∏—Å—Ç–∞...');
        await ctx.editMessageText('‚è≥ –ü–æ–ª—É—á–∞—é –ø–æ–ª–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–ª–µ–π–ª–∏—Å—Ç–∞... –≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–µ–∫—É–Ω–¥.');
        
        try {
            const fullData = await ytdl(session.originalUrl, { 
                'dump-single-json': true,
                ...YTDL_COMMON 
            });
            session.tracks = fullData.entries.filter(track => track && track.url);
            session.fullTracks = true;
        } catch (e) {
            console.error('[Playlist] –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–∑–∞–≥—Ä—É–∑–∫–µ –Ω–∞–∑–≤–∞–Ω–∏–π:', e);
            await ctx.editMessageText('‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–µ—Ç–∞–ª–∏ –ø–ª–µ–π–ª–∏—Å—Ç–∞.');
            return await ctx.answerCbQuery('–û—à–∏–±–∫–∞!', { show_alert: true });
        }
    }
    
    const user = await getUser(userId);
    const remainingLimit = user.premium_limit - (user.downloads_today || 0);
    
    if (remainingLimit <= 0) {
        const bonusAvailable = Boolean(CHANNEL_USERNAME && !user.subscribed_bonus_used);
        const cleanUsername = CHANNEL_USERNAME?.replace('@', '');
        const bonusText = bonusAvailable
            ? `\n\nüéÅ –î–æ—Å—Ç—É–ø–µ–Ω –±–æ–Ω—É—Å! –ü–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ <a href="https://t.me/${cleanUsername}">@${cleanUsername}</a> –∏ –ø–æ–ª—É—á–∏ <b>7 –¥–Ω–µ–π —Ç–∞—Ä–∏—Ñ–∞ Plus</b>.`
            : '';
        
        const extra = { parse_mode: 'HTML', disable_web_page_preview: true };
        if (bonusAvailable) {
            extra.reply_markup = {
                inline_keyboard: [[ { text: '‚úÖ –Ø –ø–æ–¥–ø–∏—Å–∞–ª—Å—è, –∑–∞–±—Ä–∞—Ç—å –±–æ–Ω—É—Å', callback_data: 'check_subscription' } ]]
            };
        }
        
        await ctx.editMessageText(`${T('limitReached')}${bonusText}`, extra);
        playlistSessions.delete(userId);
        return;
    }
    
    await ctx.editMessageText(`‚úÖ –û—Ç–ª–∏—á–Ω–æ! –î–æ–±–∞–≤–ª—è—é —Ç—Ä–µ–∫–∏ –≤ –æ—á–µ—Ä–µ–¥—å...`);
    
    const tracksToTake = isAll ? session.tracks.length : 10;
    const numberOfTracksToQueue = Math.min(tracksToTake, remainingLimit);
    const tracksToProcess = session.tracks.slice(0, numberOfTracksToQueue);
    
    // üî• –ò–°–ü–û–õ–¨–ó–£–ï–ú –ù–û–í–£–Æ –°–ò–°–¢–ï–ú–£ (–ø—Ä–æ—Å—Ç–æ –ø–µ—Ä–µ–¥–∞–µ–º URL –≤ enqueue)
    for (const track of tracksToProcess) {
        const trackUrl = track.webpage_url || track.url;
        soundcloudEnqueue(ctx, userId, trackUrl);
    }
    
    let reportMessage = `‚è≥ ${tracksToProcess.length} —Ç—Ä–µ–∫(–æ–≤) –¥–æ–±–∞–≤–ª–µ–Ω–æ –≤ –æ—á–µ—Ä–µ–¥—å.`;
    
    if (numberOfTracksToQueue < tracksToTake) {
        reportMessage += `\n\n‚ÑπÔ∏è –í–∞—à –¥–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç –±—É–¥–µ—Ç –∏—Å—á–µ—Ä–ø–∞–Ω. –û—Å—Ç–∞–ª—å–Ω—ã–µ —Ç—Ä–µ–∫–∏ –∏–∑ –ø–ª–µ–π–ª–∏—Å—Ç–∞ –Ω–µ –±—ã–ª–∏ –¥–æ–±–∞–≤–ª–µ–Ω—ã.`;
    }
    
    await ctx.reply(reportMessage);
    playlistSessions.delete(userId);
});

bot.action(/pl_select_manual:(.+)/, async (ctx) => {
    const userId = ctx.from.id;
    const playlistId = ctx.match[1];
    const session = playlistSessions.get(userId);
    
    if (!session || session.playlistId !== playlistId) {
        return await ctx.answerCbQuery('‚ùóÔ∏è –°–µ—Å—Å–∏—è –≤—ã–±–æ—Ä–∞ –∏—Å—Ç–µ–∫–ª–∞.', { show_alert: true });
    }
    
    if (!session.fullTracks) {
        await ctx.answerCbQuery('‚è≥ –ó–∞–≥—Ä—É–∂–∞—é –Ω–∞–∑–≤–∞–Ω–∏—è —Ç—Ä–µ–∫–æ–≤...');
        await ctx.editMessageText('‚è≥ –ü–æ–ª—É—á–∞—é –ø–æ–ª–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–ª–µ–π–ª–∏—Å—Ç–∞... –≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–µ–∫—É–Ω–¥.');
        
        try {
            const fullData = await ytdl(session.originalUrl, { 
                'dump-single-json': true,
                ...YTDL_COMMON 
            });
            
            session.tracks = fullData.entries.filter(track => track && track.url);
            session.fullTracks = true;
            
        } catch (e) {
            console.error('[Playlist] –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–∑–∞–≥—Ä—É–∑–∫–µ –Ω–∞–∑–≤–∞–Ω–∏–π:', e);
            await ctx.editMessageText('‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–µ—Ç–∞–ª–∏ –ø–ª–µ–π–ª–∏—Å—Ç–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –∏–ª–∏ –≤—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥–æ–π –≤–∞—Ä–∏–∞–Ω—Ç.');
            return await ctx.answerCbQuery('–û—à–∏–±–∫–∞!', { show_alert: true });
        }
    }
    
    session.currentPage = 0;
    session.selected = new Set();
    const menu = generateSelectionMenu(userId);
    if (menu) {
        try {
            await ctx.editMessageText(menu.text, menu.options);
        } catch (e) { /* –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º */ }
    }
});

bot.action(/pl_page:(.+):(\d+)/, async (ctx) => {
    const [playlistId, pageStr] = ctx.match.slice(1);
    const userId = ctx.from.id;
    const session = playlistSessions.get(userId);
    
    if (!session || session.playlistId !== playlistId) {
        return await ctx.answerCbQuery('–°–µ—Å—Å–∏—è –∏—Å—Ç–µ–∫–ª–∞.');
    }
    
    session.currentPage = parseInt(pageStr, 10);
    const menu = generateSelectionMenu(userId);
    if (menu) {
        try { 
            await ctx.editMessageText(menu.text, menu.options); 
        } catch (e) {}
    }
    await ctx.answerCbQuery();
});

bot.action(/pl_toggle:(.+):(\d+)/, async (ctx) => {
    const [playlistId, indexStr] = ctx.match.slice(1);
    const userId = ctx.from.id;
    const session = playlistSessions.get(userId);
    
    if (!session || session.playlistId !== playlistId) {
        return await ctx.answerCbQuery('–°–µ—Å—Å–∏—è –∏—Å—Ç–µ–∫–ª–∞.');
    }
    
    const trackIndex = parseInt(indexStr, 10);
    if (session.selected.has(trackIndex)) {
        session.selected.delete(trackIndex);
    } else {
        session.selected.add(trackIndex);
    }
    
    const menu = generateSelectionMenu(userId);
    if (menu) {
        try { 
            await ctx.editMessageText(menu.text, menu.options); 
        } catch (e) {}
    }
    await ctx.answerCbQuery();
});

bot.action(/pl_finish:(.+)/, async (ctx) => {
    const playlistId = ctx.match[1];
    const userId = ctx.from.id;
    const session = playlistSessions.get(userId);
    
    if (!session) {
        return await ctx.answerCbQuery('‚ùóÔ∏è –°–µ—Å—Å–∏—è –≤—ã–±–æ—Ä–∞ –∏—Å—Ç–µ–∫–ª–∞.', { show_alert: true });
    }
    if (session.selected.size === 0) {
        return await ctx.answerCbQuery('–í—ã –Ω–µ –≤—ã–±—Ä–∞–ª–∏ –Ω–∏ –æ–¥–Ω–æ–≥–æ —Ç—Ä–µ–∫–∞.', { show_alert: true });
    }
    if (!session.fullTracks) {
        return await ctx.answerCbQuery('‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: –¥–∞–Ω–Ω—ã–µ –ø–ª–µ–π–ª–∏—Å—Ç–∞ –Ω–µ –±—ã–ª–∏ –∑–∞–≥—Ä—É–∂–µ–Ω—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–Ω–æ–≤–æ.', { show_alert: true });
    }
    
    const user = await getUser(userId);
    const remainingLimit = user.premium_limit - (user.downloads_today || 0);
    
    if (remainingLimit <= 0) {
        const bonusAvailable = Boolean(CHANNEL_USERNAME && !user.subscribed_bonus_used);
        const cleanUsername = CHANNEL_USERNAME?.replace('@', '');
        const bonusText = bonusAvailable
            ? `\n\nüéÅ –î–æ—Å—Ç—É–ø–µ–Ω –±–æ–Ω—É—Å! –ü–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ <a href="https://t.me/${cleanUsername}">@${cleanUsername}</a> –∏ –ø–æ–ª—É—á–∏ <b>7 –¥–Ω–µ–π —Ç–∞—Ä–∏—Ñ–∞ Plus</b>.`
            : '';
        
        const extra = { parse_mode: 'HTML', disable_web_page_preview: true };
        if (bonusAvailable) {
            extra.reply_markup = {
                inline_keyboard: [[ { text: '‚úÖ –Ø –ø–æ–¥–ø–∏—Å–∞–ª—Å—è, –∑–∞–±—Ä–∞—Ç—å –±–æ–Ω—É—Å', callback_data: 'check_subscription' } ]]
            };
        }
        
        await ctx.editMessageText(`${T('limitReached')}${bonusText}`, extra);
        playlistSessions.delete(userId);
        return;
    }
    
    await ctx.editMessageText(`‚úÖ –ì–æ—Ç–æ–≤–æ! –î–æ–±–∞–≤–ª—è—é ${session.selected.size} –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö —Ç—Ä–µ–∫–æ–≤ –≤ –æ—á–µ—Ä–µ–¥—å...`);
    
    const selectedIndexes = Array.from(session.selected);
    const numberOfTracksToQueue = Math.min(selectedIndexes.length, remainingLimit);
    const tracksToProcess = selectedIndexes.slice(0, numberOfTracksToQueue).map(index => session.tracks[index]);
    
    // üî• –ò–°–ü–û–õ–¨–ó–£–ï–ú –ù–û–í–£–Æ –°–ò–°–¢–ï–ú–£
    for (const track of tracksToProcess) {
        const trackUrl = track.webpage_url || track.url;
        soundcloudEnqueue(ctx, userId, trackUrl);
    }
    
    let reportMessage = `‚è≥ ${tracksToProcess.length} —Ç—Ä–µ–∫(–æ–≤) –¥–æ–±–∞–≤–ª–µ–Ω–æ –≤ –æ—á–µ—Ä–µ–¥—å.`;
    if (numberOfTracksToQueue < selectedIndexes.length) {
        reportMessage += `\n\n‚ÑπÔ∏è –í–∞—à –¥–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç –±—É–¥–µ—Ç –∏—Å—á–µ—Ä–ø–∞–Ω. –û—Å—Ç–∞–ª—å–Ω—ã–µ –≤—ã–±—Ä–∞–Ω–Ω—ã–µ —Ç—Ä–µ–∫–∏ –Ω–µ –±—ã–ª–∏ –¥–æ–±–∞–≤–ª–µ–Ω—ã.`;
    }
    
    await ctx.reply(reportMessage);
    playlistSessions.delete(userId);
});

bot.action(/pl_cancel:(.+)/, async (ctx) => {
    const userId = ctx.from.id;
    const session = playlistSessions.get(userId);
    
    if (!session) {
        await ctx.deleteMessage().catch(() => {});
        return await ctx.answerCbQuery();
    }
    
    const message = `üé∂ –í –ø–ª–µ–π–ª–∏—Å—Ç–µ <b>"${session.title}"</b> –Ω–∞–π–¥–µ–Ω–æ <b>${session.tracks.length}</b> —Ç—Ä–µ–∫–æ–≤.\n\n–ß—Ç–æ –¥–µ–ª–∞–µ–º?`;
    const initialMenu = generateInitialPlaylistMenu(session.playlistId, session.tracks.length);
    
    try {
        await ctx.editMessageText(message, {
            parse_mode: 'HTML',
            ...initialMenu
        });
        await ctx.answerCbQuery('–í–æ–∑–≤—Ä–∞—â–∞—é...');
    } catch (e) {
        await ctx.answerCbQuery();
    }
});

// bot.js

// ========================= URL HANDLER (–ú–û–î–ï–†–ù–ò–ó–ò–†–û–í–ê–ù–ù–ê–Ø –í–ï–†–°–ò–Ø) =========================
// bot.js (processUrlInBackground)

async function processUrlInBackground(ctx, url) {
    let loadingMessage;
    try {
        loadingMessage = await ctx.reply('üîç –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é —Å—Å—ã–ª–∫—É...');
        
        let data;
        try {
            // üî• –ü–†–ê–í–ò–õ–¨–ù–´–ô API
            if (url.includes('/sets/')) {
                // –≠—Ç–æ –ø–ª–µ–π–ª–∏—Å—Ç
                const playlistInfo = await scdl.getSetInfo(url);
                
                data = {
                    title: playlistInfo.title,
                    entries: playlistInfo.tracks.map(track => ({
                        title: track.title,
                        url: track.permalink_url,
                        webpage_url: track.permalink_url,
                        id: track.id
                    }))
                };
            } else {
                // –≠—Ç–æ –æ–¥–∏–Ω–æ—á–Ω—ã–π —Ç—Ä–µ–∫
                const trackInfo = await scdl.getInfo(url);
                
                data = {
                    title: trackInfo.title,
                    webpage_url: trackInfo.permalink_url,
                    entries: null
                };
            }
        } catch (scdlError) {
            console.error(`[scdl] –û—à–∏–±–∫–∞ –¥–ª—è ${url}:`, scdlError.message);
            throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å—Å—ã–ª–∫—É.');
        }
        
        // ===== –ï–°–õ–ò –≠–¢–û –ü–õ–ï–ô–õ–ò–°–¢ =====
        if (data.entries && data.entries.length > 1) {
            await ctx.deleteMessage(loadingMessage.message_id).catch(() => {});
            
            const playlistId = `pl_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
            playlistSessions.set(ctx.from.id, {
                playlistId,
                title: data.title,
                tracks: data.entries,
                originalUrl: url,
                selected: new Set(),
                currentPage: 0,
                fullTracks: true // üî• –£–∂–µ –µ—Å—Ç—å –ø–æ–ª–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è!
            });
            
            const message = `üé∂ –í –ø–ª–µ–π–ª–∏—Å—Ç–µ <b>"${escapeHtml(data.title)}"</b> –Ω–∞–π–¥–µ–Ω–æ <b>${data.entries.length}</b> —Ç—Ä–µ–∫–æ–≤.\n\n–ß—Ç–æ –¥–µ–ª–∞–µ–º?`;
            await ctx.reply(message, {
                parse_mode: 'HTML',
                ...generateInitialPlaylistMenu(playlistId, data.entries.length)
            });
            
            // ===== –ï–°–õ–ò –≠–¢–û –û–î–ò–ù–û–ß–ù–´–ô –¢–†–ï–ö =====
        } else {
            // –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ "–ê–Ω–∞–ª–∏–∑–∏—Ä—É—é..."
            await ctx.deleteMessage(loadingMessage.message_id).catch(() => {});
            
            // üî• –ü–ï–†–ï–î–ê–Å–ú –£–ü–†–ê–í–õ–ï–ù–ò–ï downloadManager
            // –û–Ω —Å–∞–º –≤—Å—ë —Å–¥–µ–ª–∞–µ—Ç: –ø—Ä–æ–≤–µ—Ä–∏—Ç –∫–µ—à, —Å–∫–∞—á–∞–µ—Ç, –æ—Ç–ø—Ä–∞–≤–∏—Ç
            soundcloudEnqueue(ctx, ctx.from.id, url);
        }
    } catch (error) {
        console.error('[processUrlInBackground] –û—à–∏–±–∫–∞:', error.message);
        
        const userMessage = '‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å —Å—Å—ã–ª–∫—É. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –æ–Ω–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞ –∏ –¥–æ—Å—Ç—É–ø–Ω–∞.';
        
        if (loadingMessage) {
            await ctx.telegram.editMessageText(
                ctx.chat.id,
                loadingMessage.message_id,
                undefined,
                userMessage
            ).catch(() => {});
        } else {
            await ctx.reply(userMessage);
        }
    }
}

async function handleSoundCloudUrl(ctx, url) {
    // –ü—Ä–æ—Å—Ç–æ –∑–∞–ø—É—Å–∫–∞–µ–º —Ñ–æ–Ω–æ–≤—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É
    processUrlInBackground(ctx, url);
}
// ========================= URL HANDLER (–£–ü–†–û–©–Å–ù–ù–ê–Ø –í–ï–†–°–ò–Ø) =========================

bot.on('text', async (ctx) => {
    if (isShuttingDown()) {
        console.log('[Shutdown] –û—Ç–∫–ª–æ–Ω–µ–Ω –Ω–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å.');
        return;
    }
    
    if (isMaintenanceMode() && ctx.from.id !== ADMIN_ID) {
        return await ctx.reply('‚è≥ –ë–æ—Ç –Ω–∞ –æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —á–µ—Ä–µ–∑ 5-10 –º–∏–Ω—É—Ç.');
    }
    
    if (ctx.chat.type !== 'private') {
        console.log(`[Ignore] –°–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ –Ω–µ-–ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ —á–∞—Ç–∞.`);
        return;
    }
    
    const text = ctx.message.text;
    if (text.startsWith('/')) return;
    if (Object.values(allTextsSync()).includes(text)) return;
    
    const urlMatch = text.match(/(https?:\/\/[^\s]+)/g);
    if (!urlMatch) {
        return await ctx.reply('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –º–Ω–µ —Å—Å—ã–ª–∫—É.');
    }
    
    const url = urlMatch[0];
    
    if (url.includes('soundcloud.com')) {
        // üî• –ü–†–û–°–¢–û –ü–ï–†–ï–î–ê–Å–ú –í downloadManager (–æ–Ω –≤—Å—ë —Å–¥–µ–ª–∞–µ—Ç —Å–∞–º!)
        soundcloudEnqueue(ctx, ctx.from.id, url);
    } else if (url.includes('open.spotify.com')) {
        await ctx.reply('üõ† –°–∫–∞—á–∏–≤–∞–Ω–∏–µ –∏–∑ Spotify –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ.');
    } else {
        await ctx.reply('–Ø —É–º–µ—é —Å–∫–∞—á–∏–≤–∞—Ç—å —Ç—Ä–µ–∫–∏ –∏–∑ SoundCloud.');
    }
});

// ========================= EXPORTS =========================

export default bot;