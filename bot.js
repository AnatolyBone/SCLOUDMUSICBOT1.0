import { Telegraf, Markup, TelegramError } from 'telegraf';
import { ADMIN_ID, BOT_TOKEN, WEBHOOK_URL, CHANNEL_USERNAME, STORAGE_CHANNEL_ID, PROXY_URL } from './config.js'; // –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ PROXY_URL –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω
import { updateUserField, getUser, createUser, setPremium, getAllUsers, resetDailyLimitIfNeeded, getCachedTracksCount, logUserAction, getTopFailedSearches, getTopRecentSearches, getNewUsersCount } from './db.js';
import { T, allTextsSync } from './config/texts.js';
import { performInlineSearch } from './services/searchManager.js';
import { spotifyEnqueue } from './services/spotifyManager.js';
import { enqueue, downloadQueue } from './services/downloadManager.js';
// ======================= –ù–û–í–´–ô –ò–ú–ü–û–†–¢ =======================
import execYoutubeDl from 'youtube-dl-exec';

// ======================= –ù–û–í–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï –ò –§–£–ù–ö–¶–ò–ò =======================

// –ü—Ä–æ—Å—Ç–æ–µ in-memory —Ö—Ä–∞–Ω–∏–ª–∏—â–µ –¥–ª—è —Å–µ—Å—Å–∏–π –≤—ã–±–æ—Ä–∞ –ø–ª–µ–π–ª–∏—Å—Ç–æ–≤
// –ö–ª—é—á - userId, –ó–Ω–∞—á–µ–Ω–∏–µ - –æ–±—ä–µ–∫—Ç —Å–µ—Å—Å–∏–∏
const playlistSessions = new Map();

// –†–µ–≥—É–ª—è—Ä–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –ø–ª–µ–π–ª–∏—Å—Ç–æ–≤ SoundCloud
const SOUNDCLOUD_PLAYLIST_REGEX = /soundcloud\.com\/([\w-]+)\/sets\/([\w-]+)/i;

// –•–µ–ª–ø–µ—Ä –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Å—Ç–∞–Ω—Å–∞ youtube-dl-exec —Å –ø—Ä–æ–∫—Å–∏
function getYoutubeDl() {
    const options = {};
    if (PROXY_URL) {
        options.proxy = PROXY_URL;
    }
    return (url, flags) => execYoutubeDl(url, flags, options);
}

// ======================= –ö–û–ù–ï–¶ –ù–û–í–´–• –ü–ï–†–ï–ú–ï–ù–ù–´–• =======================


async function isSubscribed(userId) {
    if (!CHANNEL_USERNAME) return false;
    try {
        const member = await bot.telegram.getChatMember(CHANNEL_USERNAME, userId);
        return ['creator', 'administrator', 'member'].includes(member.status);
    } catch (e) {
        console.error(`–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–¥–ø–∏—Å–∫–∏ –¥–ª—è ${userId} –Ω–∞ ${CHANNEL_USERNAME}:`, e.message);
        return false;
    }
}

function getTariffName(limit) {
    if (limit >= 10000) return 'Unlimited ‚Äî üíé';
    if (limit >= 100) return 'Pro ‚Äî 100 üí™';
    if (limit >= 30) return 'Plus ‚Äî 30 üéØ';
    return 'üÜì Free ‚Äî 5 üü¢';
}

function getDaysLeft(premiumUntil) {
    if (!premiumUntil) return 0;
    const diff = new Date(premiumUntil) - new Date();
    return Math.max(Math.ceil(diff / 86400000), 0);
}

function formatMenuMessage(user, ctx) {
    const tariffLabel = getTariffName(user.premium_limit);
    const downloadsToday = user.downloads_today || 0;
    const daysLeft = getDaysLeft(user.premium_until);

    let message = `
üëã –ü—Ä–∏–≤–µ—Ç, ${user.first_name || '–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å'}!
<b>–¢–≤–æ–π –ø—Ä–æ—Ñ–∏–ª—å:</b>
üíº <b>–¢–∞—Ä–∏—Ñ:</b> <i>${tariffLabel}</i>
‚è≥ <b>–û—Å—Ç–∞–ª–æ—Å—å –¥–Ω–µ–π –ø–æ–¥–ø–∏—Å–∫–∏:</b> <i>${daysLeft}</i>
üéß <b>–°–µ–≥–æ–¥–Ω—è —Å–∫–∞—á–∞–Ω–æ:</b> <i>${downloadsToday}</i> –∏–∑ <i>${user.premium_limit}</i>
    `.trim();

    if (!user.subscribed_bonus_used && CHANNEL_USERNAME) {
        const cleanUsername = CHANNEL_USERNAME.replace('@', '');
        const channelLink = `<a href="https://t.me/${cleanUsername}">–Ω–∞—à –∫–∞–Ω–∞–ª</a>`;
        message += `\n\nüéÅ <b>–ë–æ–Ω—É—Å!</b> –ü–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ ${channelLink} –∏ –ø–æ–ª—É—á–∏ <b>7 –¥–Ω–µ–π —Ç–∞—Ä–∏—Ñ–∞ Plus</b> –±–µ—Å–ø–ª–∞—Ç–Ω–æ!`;
    }

    message += '\n\n–ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å –º–Ω–µ —Å—Å—ã–ª–∫—É, –∏ —è —Å–∫–∞—á–∞—é —Ç—Ä–µ–∫!';
    return message;
}

async function handleSendMessageError(e, userId, ctx = null) {
    console.error(`üî¥ –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º ${userId}:`, e.message);
    if (e instanceof TelegramError && e.response?.error_code === 403) {
        await updateUserField(userId, 'active', false);
        console.log(`- –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${userId} –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª –±–æ—Ç–∞.`);
    } else if (ctx) {
        try { await ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –≤–∞—à–µ–≥–æ –∑–∞–ø—Ä–æ—Å–∞.'); } catch (sendError) {}
    }
}

export const bot = new Telegraf(BOT_TOKEN, { handlerTimeout: 300_000 });

bot.catch(async (err, ctx) => {
    console.error(`üî¥ [Telegraf Catch] –ì–ª–æ–±–∞–ª—å–Ω–∞—è –æ—à–∏–±–∫–∞ –¥–ª—è update ${ctx.update.update_id}:`, err);
    if (err instanceof TelegramError && err.response?.error_code === 403) {
        if (ctx.from?.id) await updateUserField(ctx.from.id, 'active', false);
    }
});

bot.use(async (ctx, next) => {
    if (!ctx.from) return next();
    const user = await getUser(ctx.from.id, ctx.from.first_name, ctx.from.username);
    ctx.state.user = user;
    if (user && user.active === false) {
        console.log(`[Access Denied] –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${ctx.from.id} –ø–æ–ø—ã—Ç–∞–ª—Å—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –±–æ—Ç–∞.`);
        ctx.reply(T('blockedMessage'), { parse_mode: 'HTML' }).catch(() => {});
        return; 
    }
    await resetDailyLimitIfNeeded(ctx.from.id);
    return next();
});

bot.start(async (ctx) => {
    await createUser(ctx.from.id, ctx.from.first_name, ctx.from.username, ctx.startPayload || null);
    const user = ctx.state.user;
    const isNewRegistration = (Date.now() - new Date(user.created_at).getTime()) < 5000;

    if (isNewRegistration) {
        await logUserAction(ctx.from.id, 'registration');
    }

    const startMessage = isNewRegistration ? T('start_new_user') : T('start');
    
    await ctx.reply(startMessage, {
        parse_mode: 'HTML',
        disable_web_page_preview: true,
        ...Markup.keyboard([
            [T('menu'), T('upgrade')],
            [T('mytracks'), T('help')]
        ]).resize()
    });
});

bot.command('admin', async (ctx) => {
    if (ctx.from.id !== ADMIN_ID) return;
    try {
        await ctx.reply('‚è≥ –°–æ–±–∏—Ä–∞—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É...');
        
        const [
            users,
            cachedTracksCount,
            topFailed,
            topRecent,
            newUsersToday, 
            newUsersWeek
        ] = await Promise.all([
            getAllUsers(true),
            getCachedTracksCount(),
            getTopFailedSearches(5),
            getTopRecentSearches(5),
            getNewUsersCount(1), 
            getNewUsersCount(7)
        ]);
        
        const totalUsers = users.length;
        const activeUsers = users.filter(u => u.active).length;
        const activeToday = users.filter(u => u.last_active && new Date(u.last_active).toDateString() === new Date().toDateString()).length;
        const totalDownloads = users.reduce((sum, u) => sum + (u.total_downloads || 0), 0);
        let storageStatusText = STORAGE_CHANNEL_ID ? '‚úÖ –î–æ—Å—Ç—É–ø–µ–Ω' : '‚ö†Ô∏è –ù–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω';
        
        let statsMessage = `<b>üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ë–æ—Ç–∞</b>\n\n` +
            `<b>üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏:</b>\n` +
            `   - –í—Å–µ–≥–æ: <i>${totalUsers}</i>\n` +
            `   - –ê–∫—Ç–∏–≤–Ω—ã—Ö: <i>${activeUsers}</i>\n` +
            `   - <b>–ù–æ–≤—ã—Ö –∑–∞ 24—á: <i>${newUsersToday}</i></b>\n` +
            `   - <b>–ù–æ–≤—ã—Ö –∑–∞ 7 –¥–Ω–µ–π: <i>${newUsersWeek}</i></b>\n` +
            `   - –ê–∫—Ç–∏–≤–Ω—ã—Ö —Å–µ–≥–æ–¥–Ω—è: <i>${activeToday}</i>\n\n` +
            `<b>üì• –ó–∞–≥—Ä—É–∑–∫–∏:</b>\n   - –í—Å–µ–≥–æ –∑–∞ –≤—Å–µ –≤—Ä–µ–º—è: <i>${totalDownloads}</i>\n\n`;
        
        if (topFailed.length > 0) {
            statsMessage += `---\n\n<b>üî• –¢–æ–ø-5 –Ω–µ—É–¥–∞—á–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ (–≤—Å–µ–≥–æ):</b>\n`;
            topFailed.forEach((item, index) => {
                statsMessage += `${index + 1}. <code>${item.query.slice(0, 30)}</code> (–∏—Å–∫–∞–ª–∏ <i>${item.search_count}</i> —Ä–∞–∑)\n`;
            });
            statsMessage += `\n`;
        }
        
        if (topRecent.length > 0) {
            statsMessage += `<b>üìà –¢–æ–ø-5 –∑–∞–ø—Ä–æ—Å–æ–≤ (–∑–∞ 24 —á–∞—Å–∞):</b>\n`;
            topRecent.forEach((item, index) => {
                statsMessage += `${index + 1}. <code>${item.query.slice(0, 30)}</code> (–∏—Å–∫–∞–ª–∏ <i>${item.total}</i> —Ä–∞–∑)\n`;
            });
            statsMessage += `\n`;
        }
        
        statsMessage += `---\n\n<b>‚öôÔ∏è –°–∏—Å—Ç–µ–º–∞:</b>\n` +
            `   - –û—á–µ—Ä–µ–¥—å: <i>${downloadQueue.size}</i> –≤ –æ–∂. / <i>${downloadQueue.active}</i> –≤ —Ä–∞–±.\n` +
            `   - –ö–∞–Ω–∞–ª-—Ö—Ä–∞–Ω–∏–ª–∏—â–µ: <i>${storageStatusText}</i>\n   - –¢—Ä–µ–∫–æ–≤ –≤ –∫—ç—à–µ: <i>${cachedTracksCount}</i>\n\n` +
            `<b>üîó –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å:</b>\n<a href="${WEBHOOK_URL.replace(/\/$/, '')}/dashboard">–û—Ç–∫—Ä—ã—Ç—å –¥–∞—à–±–æ—Ä–¥</a>`;
        
        await ctx.reply(statsMessage, { parse_mode: 'HTML', disable_web_page_preview: true });
    } catch (e) {
        console.error('‚ùå –û—à–∏–±–∫–∞ –≤ –∫–æ–º–∞–Ω–¥–µ /admin:', e);
        await ctx.reply('‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–±—Ä–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É.');
    }
});

bot.command('premium', async (ctx) => {
    await ctx.reply(T('upgradeInfo'), { parse_mode: 'HTML', disable_web_page_preview: true });
});

bot.action('check_subscription', async (ctx) => {
    const user = await getUser(ctx.from.id);
    if (user.subscribed_bonus_used) {
        return await ctx.answerCbQuery('–í—ã —É–∂–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ —ç—Ç–æ—Ç –±–æ–Ω—É—Å.', { show_alert: true });
    }
    const subscribed = await isSubscribed(ctx.from.id);
    if (subscribed) {
        await setPremium(ctx.from.id, 30, 7); 
        await updateUserField(ctx.from.id, 'subscribed_bonus_used', true);
        await logUserAction(ctx.from.id, 'bonus_received');
        await ctx.editMessageText('üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í–∞–º –Ω–∞—á–∏—Å–ª–µ–Ω–æ 7 –¥–Ω–µ–π —Ç–∞—Ä–∏—Ñ–∞ Plus. –°–ø–∞—Å–∏–±–æ –∑–∞ –ø–æ–¥–ø–∏—Å–∫—É!');
    } else {
        await ctx.answerCbQuery(`–í—ã –µ—â–µ –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –∏ –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É —Å–Ω–æ–≤–∞.`, { show_alert: true });
    }
});

bot.hears(T('menu'), async (ctx) => {
    const user = await getUser(ctx.from.id);
    const message = formatMenuMessage(user, ctx);
    const extraOptions = { 
        parse_mode: 'HTML',
        disable_web_page_preview: true
    };
    if (!user.subscribed_bonus_used && CHANNEL_USERNAME) {
        extraOptions.reply_markup = { inline_keyboard: [[ Markup.button.callback('‚úÖ –Ø –ø–æ–¥–ø–∏—Å–∞–ª—Å—è –∏ —Ö–æ—á—É –±–æ–Ω—É—Å!', 'check_subscription') ]] };
    }
    await ctx.reply(message, extraOptions);
});

bot.hears(T('mytracks'), async (ctx) => {
    try {
        const user = await getUser(ctx.from.id);
        const tracks = user.tracks_today;
        if (!tracks || !Array.isArray(tracks) || tracks.length === 0) {
            return await ctx.reply(T('noTracks'));
        }
        for (let i = 0; i < tracks.length; i += 10) {
            const chunk = tracks.slice(i, i + 10).filter(t => t && t.fileId);
            if (chunk.length > 0) {
                await ctx.replyWithMediaGroup(chunk.map(t => ({ type: 'audio', media: t.fileId })));
            }
        }
    } catch (e) {
        await handleSendMessageError(e, ctx.from.id, ctx);
    }
});

bot.hears(T('help'), async (ctx) => await ctx.reply(T('helpInfo'), { parse_mode: 'HTML', disable_web_page_preview: true }));
bot.hears(T('upgrade'), async (ctx) => await ctx.reply(T('upgradeInfo'), { parse_mode: 'HTML', disable_web_page_preview: true }));

bot.on('inline_query', async (ctx) => {
    const query = ctx.inlineQuery.query;
    if (!query || query.trim().length < 2) {
        return await ctx.answerInlineQuery([], {
            switch_pm_text: '–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç—Ä–µ–∫–∞ –¥–ª—è –ø–æ–∏—Å–∫–∞...',
            switch_pm_parameter: 'start',
        });
    }
    try {
        const results = await performInlineSearch(query, ctx.from.id);
        await ctx.answerInlineQuery(results, { cache_time: 60 });
    } catch (error) {
        console.error('[Inline Query] –ì–ª–æ–±–∞–ª—å–Ω–∞—è –æ—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞:', error);
        await ctx.answerInlineQuery([]);
    }
});

// ======================= –ù–û–í–´–ï –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –î–õ–Ø –ü–õ–ï–ô–õ–ò–°–¢–û–í =======================

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–°–∫–∞—á–∞—Ç—å –ø–µ—Ä–≤—ã–µ 10"
// –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–°–∫–∞—á–∞—Ç—å –ø–µ—Ä–≤—ã–µ 10"
bot.action(/pl_download_10:(.+)/, async (ctx) => {
    const playlistId = ctx.match[1];
    const userId = ctx.from.id;
    const session = playlistSessions.get(userId);
    
    if (!session || session.playlistId !== playlistId) {
        return await ctx.answerCbQuery('‚ùóÔ∏è –°–µ—Å—Å–∏—è –≤—ã–±–æ—Ä–∞ –∏—Å—Ç–µ–∫–ª–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Å—Å—ã–ª–∫—É –Ω–∞ –ø–ª–µ–π–ª–∏—Å—Ç –∑–∞–Ω–æ–≤–æ.', { show_alert: true });
    }
    
    // –ü–µ—Ä–µ–¥ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ–º –≤ –æ—á–µ—Ä–µ–¥—å, –ø—Ä–æ–≤–µ—Ä–∏–º –ª–∏–º–∏—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    await resetDailyLimitIfNeeded(userId);
    const user = await getUser(userId);
    const remainingLimit = user.premium_limit - user.downloads_today;
    
    if (remainingLimit <= 0) {
        await ctx.editMessageText(T('limitReached'), { parse_mode: 'HTML' });
        playlistSessions.delete(userId); // –û—á–∏—â–∞–µ–º —Å–µ—Å—Å–∏—é
        return;
    }
    
    const tracksFromPlaylist = session.tracks.slice(0, 10);
    // –ë–µ—Ä–µ–º –Ω–µ –±–æ–ª—å—à–µ, —á–µ–º –ø–æ–∑–≤–æ–ª—è–µ—Ç –æ—Å—Ç–∞–≤—à–∏–π—Å—è –ª–∏–º–∏—Ç
    const tracksToProcess = tracksFromPlaylist.slice(0, remainingLimit);
    
    if (tracksToProcess.length === 0) {
        await ctx.editMessageText('–í—Å–µ —Ç—Ä–µ–∫–∏ –∏–∑ —ç—Ç–æ–π —Å–µ—Å—Å–∏–∏ —É–∂–µ –Ω–µ –ø–æ–º–µ—â–∞—é—Ç—Å—è –≤ –≤–∞—à –¥–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç.');
        playlistSessions.delete(userId);
        return;
    }
    
    let message = `‚úÖ –û—Ç–ª–∏—á–Ω–æ! –°—Ç–∞–≤–ª—é ${tracksToProcess.length} —Ç—Ä–µ–∫(–æ–≤) –≤ –æ—á–µ—Ä–µ–¥—å –Ω–∞ —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ...`;
    if (tracksToProcess.length < tracksFromPlaylist.length) {
        message += `\n(–û—Å—Ç–∞–ª—å–Ω—ã–µ –Ω–µ –ø–æ–º–µ—Å—Ç–∏–ª–∏—Å—å –≤ –≤–∞—à –¥–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç)`
    }
    await ctx.editMessageText(message);
    
    // –ù–ê–ü–†–Ø–ú–£–Æ –¥–æ–±–∞–≤–ª—è–µ–º –∑–∞–¥–∞—á–∏ –≤ –æ—á–µ—Ä–µ–¥—å, –º–∏–Ω—É—è enqueue
    for (const track of tracksToProcess) {
        // –§–æ—Ä–º–∏—Ä—É–µ–º –∑–∞–¥–∞—á—É –≤ —Ç–æ–º –∂–µ —Ñ–æ—Ä–º–∞—Ç–µ, –∫–æ—Ç–æ—Ä—ã–π –æ–∂–∏–¥–∞–µ—Ç trackDownloadProcessor
        const task = {
            userId: userId,
            source: 'soundcloud',
            url: track.url, // URL –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è
            originalUrl: track.url, // URL –¥–ª—è –∫–ª—é—á–∞ –∫—ç—à–∞
            metadata: {
                id: track.id,
                title: track.title || 'Unknown Title',
                uploader: track.uploader || 'Unknown Artist',
                duration: track.duration,
                thumbnail: track.thumbnail,
            }
        };
        downloadQueue.add(task); // –ò—Å–ø–æ–ª—å–∑—É–µ–º –º–µ—Ç–æ–¥ .add() –∏–∑ –≤–∞—à–µ–≥–æ TaskQueue
    }
    
    // –û—á–∏—â–∞–µ–º —Å–µ—Å—Å–∏—é –ø–æ—Å–ª–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
    playlistSessions.delete(userId);
});
// –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–í—ã–±—Ä–∞—Ç—å —Ç—Ä–µ–∫–∏ –≤—Ä—É—á–Ω—É—é" (–ø–æ–∫–∞ —á—Ç–æ –∑–∞–≥–ª—É—à–∫–∞)
// ======================= –ö–û–î –î–õ–Ø –†–£–ß–ù–û–ì–û –í–´–ë–û–†–ê –¢–†–ï–ö–û–í (–í–°–¢–ê–í–ò–¢–¨ –í BOT.JS) =======================

const ITEMS_PER_PAGE = 5; // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç—Ä–µ–∫–æ–≤ –Ω–∞ –æ–¥–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ –≤—ã–±–æ—Ä–∞

/**
 * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–µ –º–µ–Ω—é –¥–ª—è –≤—ã–±–æ—Ä–∞ —Ç—Ä–µ–∫–æ–≤ —Å –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π.
 * @param {number} userId ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –¥–ª—è –∫–æ—Ç–æ—Ä–æ–≥–æ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è –º–µ–Ω—é.
 * @returns {object} –ì–æ—Ç–æ–≤—ã–π –æ–±—ä–µ–∫—Ç —Å —Ç–µ–∫—Å—Ç–æ–º –∏ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–æ–π –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏/—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è.
 */
function generateSelectionMenu(userId) {
    const session = playlistSessions.get(userId);
    if (!session) return null;
    
    const { tracks, selected, currentPage, playlistId, title } = session;
    const totalPages = Math.ceil(tracks.length / ITEMS_PER_PAGE);
    
    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –∫–∞–∫–∏–µ —Ç—Ä–µ–∫–∏ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –Ω–∞ —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ
    const startIndex = currentPage * ITEMS_PER_PAGE;
    const endIndex = startIndex + ITEMS_PER_PAGE;
    const tracksOnPage = tracks.slice(startIndex, endIndex);
    
    // –§–æ—Ä–º–∏—Ä—É–µ–º —Ä—è–¥—ã –∫–Ω–æ–ø–æ–∫ —Å —Ç—Ä–µ–∫–∞–º–∏
    const trackRows = tracksOnPage.map((track, index) => {
        const absoluteIndex = startIndex + index;
        const isSelected = selected.has(absoluteIndex);
        const icon = isSelected ? '‚úÖ' : '‚¨úÔ∏è';
        // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª–∏–Ω—É –Ω–∞–∑–≤–∞–Ω–∏—è —Ç—Ä–µ–∫–∞, —á—Ç–æ–±—ã –æ–Ω –ø–æ–º–µ—Å—Ç–∏–ª—Å—è –≤ –∫–Ω–æ–ø–∫—É
        const trackTitle = track.title.length > 50 ? track.title.slice(0, 47) + '...' : track.title;
        
        return [Markup.button.callback(`${icon} ${trackTitle}`, `pl_toggle:${playlistId}:${absoluteIndex}`)];
    });
    
    // –§–æ—Ä–º–∏—Ä—É–µ–º —Ä—è–¥ –∫–Ω–æ–ø–æ–∫ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
    const navRow = [];
    if (currentPage > 0) {
        navRow.push(Markup.button.callback('‚¨ÖÔ∏è –ù–∞–∑–∞–¥', `pl_page:${playlistId}:${currentPage - 1}`));
    }
    navRow.push(Markup.button.callback(`–°—Ç—Ä–∞–Ω–∏—Ü–∞ ${currentPage + 1}/${totalPages}`, 'pl_ignore')); // –ö–Ω–æ–ø–∫–∞-—Å—á–µ—Ç—á–∏–∫
    if (currentPage < totalPages - 1) {
        navRow.push(Markup.button.callback('–í–ø–µ—Ä–µ–¥ ‚û°Ô∏è', `pl_page:${playlistId}:${currentPage + 1}`));
    }
    
    // –§–æ—Ä–º–∏—Ä—É–µ–º —Ä—è–¥ —Å –∫–Ω–æ–ø–∫–æ–π "–ì–æ—Ç–æ–≤–æ"
    const actionRow = [
        Markup.button.callback(`‚úÖ –ì–æ—Ç–æ–≤–æ (${selected.size} –≤—ã–±—Ä–∞–Ω–æ)`, `pl_done:${playlistId}`)
    ];
    
    const messageText = `üé∂ <b>${title}</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ —Ç—Ä–µ–∫–∏ –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è:`;
    
    return {
        text: messageText,
        extra: {
            parse_mode: 'HTML',
            ...Markup.inlineKeyboard([
                ...trackRows,
                navRow,
                actionRow
            ])
        }
    };
}

// –ü—É—Å—Ç—ã—à–∫–∞, —á—Ç–æ–±—ã Telegram –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–ª "—á–∞—Å–∏–∫–∏" –Ω–∞ –∫–Ω–æ–ø–∫–µ —Å–æ —Å—á–µ—Ç—á–∏–∫–æ–º —Å—Ç—Ä–∞–Ω–∏—Ü
bot.action('pl_ignore', (ctx) => ctx.answerCbQuery());

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫, –∫–æ—Ç–æ—Ä—ã–π –ó–ê–ü–£–°–ö–ê–ï–¢ —Ä—É—á–Ω–æ–π –≤—ã–±–æ—Ä
bot.action(/pl_select_manual:(.+)/, async (ctx) => {
    const playlistId = ctx.match[1];
    const userId = ctx.from.id;
    const session = playlistSessions.get(userId);
    
    if (!session || session.playlistId !== playlistId) {
        return await ctx.answerCbQuery('‚ùóÔ∏è –°–µ—Å—Å–∏—è –≤—ã–±–æ—Ä–∞ –∏—Å—Ç–µ–∫–ª–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Å—Å—ã–ª–∫—É –∑–∞–Ω–æ–≤–æ.', { show_alert: true });
    }
    
    const menu = generateSelectionMenu(userId);
    if (menu) {
        await ctx.editMessageText(menu.text, menu.extra);
    }
});

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –ü–ï–†–ï–ö–õ–Æ–ß–ï–ù–ò–Ø –°–¢–†–ê–ù–ò–¶
bot.action(/pl_page:(.+):(\d+)/, async (ctx) => {
    const [playlistId, pageStr] = ctx.match.slice(1);
    const newPage = parseInt(pageStr, 10);
    const userId = ctx.from.id;
    
    const session = playlistSessions.get(userId);
    if (!session || session.playlistId !== playlistId) return await ctx.answerCbQuery('–°–µ—Å—Å–∏—è –∏—Å—Ç–µ–∫–ª–∞.');
    
    session.currentPage = newPage;
    const menu = generateSelectionMenu(userId);
    if (menu) {
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º try-catch, —Ç.–∫. –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –º–æ–∂–µ—Ç —Å–ø–∞–º–∏—Ç—å –∫–Ω–æ–ø–∫–∏, –∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –∏–∑–º–µ–Ω–∏—Ç—Å—è
        try {
            await ctx.editMessageText(menu.text, menu.extra);
        } catch (e) { /* ignore */ }
    }
    await ctx.answerCbQuery();
});

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –í–´–ë–û–†–ê/–°–ù–Ø–¢–ò–Ø –í–´–ë–û–†–ê —Ç—Ä–µ–∫–∞
bot.action(/pl_toggle:(.+):(\d+)/, async (ctx) => {
    const [playlistId, indexStr] = ctx.match.slice(1);
    const trackIndex = parseInt(indexStr, 10);
    const userId = ctx.from.id;
    
    const session = playlistSessions.get(userId);
    if (!session || session.playlistId !== playlistId) return await ctx.answerCbQuery('–°–µ—Å—Å–∏—è –∏—Å—Ç–µ–∫–ª–∞.');
    
    // –õ–æ–≥–∏–∫–∞ "–ø–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—è"
    if (session.selected.has(trackIndex)) {
        session.selected.delete(trackIndex);
    } else {
        session.selected.add(trackIndex);
    }
    
    const menu = generateSelectionMenu(userId);
    if (menu) {
        try {
            await ctx.editMessageText(menu.text, menu.extra);
        } catch (e) { /* ignore */ }
    }
    await ctx.answerCbQuery();
});

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–ì–æ—Ç–æ–≤–æ"
bot.action(/pl_done:(.+)/, async (ctx) => {
    const playlistId = ctx.match[1];
    const userId = ctx.from.id;
    const session = playlistSessions.get(userId);
    
    if (!session || session.playlistId !== playlistId) {
        return await ctx.answerCbQuery('‚ùóÔ∏è –°–µ—Å—Å–∏—è –≤—ã–±–æ—Ä–∞ –∏—Å—Ç–µ–∫–ª–∞.', { show_alert: true });
    }
    
    if (session.selected.size === 0) {
        return await ctx.answerCbQuery('–í—ã –Ω–µ –≤—ã–±—Ä–∞–ª–∏ –Ω–∏ –æ–¥–Ω–æ–≥–æ —Ç—Ä–µ–∫–∞.', { show_alert: true });
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–∏–º–∏—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    await resetDailyLimitIfNeeded(userId);
    const user = await getUser(userId);
    const remainingLimit = user.premium_limit - user.downloads_today;
    
    if (remainingLimit <= 0) {
        await ctx.editMessageText(T('limitReached'), { parse_mode: 'HTML' });
        playlistSessions.delete(userId);
        return;
    }
    
    // –ü–æ–ª—É—á–∞–µ–º —Ä–µ–∞–ª—å–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã —Ç—Ä–µ–∫–æ–≤ –ø–æ –≤—ã–±—Ä–∞–Ω–Ω—ã–º –∏–Ω–¥–µ–∫—Å–∞–º
    const selectedTracks = Array.from(session.selected).map(index => session.tracks[index]);
    const tracksToProcess = selectedTracks.slice(0, remainingLimit);
    
    let message = `‚úÖ –ì–æ—Ç–æ–≤–æ! –î–æ–±–∞–≤–ª—è—é ${tracksToProcess.length} –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö —Ç—Ä–µ–∫–æ–≤ –≤ –æ—á–µ—Ä–µ–¥—å...`;
    if (tracksToProcess.length < selectedTracks.length) {
        message += `\n(–û—Å—Ç–∞–ª—å–Ω—ã–µ –Ω–µ –ø–æ–º–µ—Å—Ç–∏–ª–∏—Å—å –≤ –≤–∞—à –¥–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç)`;
    }
    await ctx.editMessageText(message);
    
    // –ù–∞–ø—Ä—è–º—É—é –¥–æ–±–∞–≤–ª—è–µ–º –∑–∞–¥–∞—á–∏ –≤ –æ—á–µ—Ä–µ–¥—å
    for (const track of tracksToProcess) {
        const task = {
            userId: userId,
            source: 'soundcloud',
            url: track.url,
            originalUrl: track.url,
            metadata: {
                id: track.id,
                title: track.title || 'Unknown Title',
                uploader: track.uploader || 'Unknown Artist',
                duration: track.duration,
                thumbnail: track.thumbnail,
            }
        };
        downloadQueue.add(task);
    }
    
    playlistSessions.delete(userId); // –û—á–∏—â–∞–µ–º —Å–µ—Å—Å–∏—é
});

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–û—Ç–º–µ–Ω–∞"
bot.action(/pl_cancel:(.+)/, async (ctx) => {
    const userId = ctx.from.id;
    playlistSessions.delete(userId);
    await ctx.deleteMessage().catch(() => {}); // –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–Ω–æ–ø–∫–∞–º–∏
    await ctx.answerCbQuery('–î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.');
});


// ======================= –ú–û–î–ò–§–ò–¶–ò–†–û–í–ê–ù–ù–´–ô –û–ë–†–ê–ë–û–¢–ß–ò–ö –¢–ï–ö–°–¢–ê =======================
// –í–ê–ñ–ù–û: –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ —Ç–µ–∫—Å—Ç–∞ –¥–æ–ª–∂–µ–Ω –∏–¥—Ç–∏ –ü–û–°–õ–ï –≤—Å–µ—Ö –∫–æ–º–∞–Ω–¥ –∏ hears
bot.on('text', async (ctx) => {
    const userText = ctx.message.text;

    if (userText.startsWith('/')) {
        return; 
    }
    
    if (Object.values(allTextsSync()).includes(userText)) {
        return; 
    }
    
    const urlMatch = userText.match(/(https?:\/\/[^\s]+)/g);
    if (!urlMatch || urlMatch.length === 0) {
        await ctx.reply('–Ø –Ω–µ –ø–æ–Ω—è–ª. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –º–Ω–µ —Å—Å—ã–ª–∫—É –Ω–∞ —Ç—Ä–µ–∫, –∞–ª—å–±–æ–º –∏–ª–∏ –ø–ª–µ–π–ª–∏—Å—Ç.');
        return;
    }
    
    const url = urlMatch[0];
    
    // –ù–æ–≤–∞—è –ª–æ–≥–∏–∫–∞: —Å–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—Å—ã–ª–∫–∞ –ø–ª–µ–π–ª–∏—Å—Ç–æ–º
    if (SOUNDCLOUD_PLAYLIST_REGEX.test(url)) {
        await handlePlaylistLink(ctx, url);
    } else if (url.includes('soundcloud.com')) {
        // –°—Ç–∞—Ä–∞—è –ª–æ–≥–∏–∫–∞ –¥–ª—è –æ–¥–∏–Ω–æ—á–Ω—ã—Ö —Ç—Ä–µ–∫–æ–≤
        enqueue(ctx, ctx.from.id, url).catch(err => {
            console.error(`[SC Enqueue Error] –û—à–∏–±–∫–∞ –¥–ª—è user ${ctx.from.id}:`, err.message);
        });
    } else if (url.includes('open.spotify.com')) {
        spotifyEnqueue(ctx, ctx.from.id, url).catch(err => {
            console.error(`[Spotify Enqueue Error] –û—à–∏–±–∫–∞ –¥–ª—è user ${ctx.from.id}:`, err.message);
        });
    } else {
        await ctx.reply('–Ø –ø–æ–∫–∞ —É–º–µ—é —Å–∫–∞—á–∏–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ —Å SoundCloud –∏ Spotify. –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –¥—Ä—É–≥–∏—Ö –ø–ª–∞—Ç—Ñ–æ—Ä–º –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ!');
    }
});

// ======================= –ù–û–í–´–ï –§–£–ù–ö–¶–ò–ò –î–õ–Ø –û–ë–†–ê–ë–û–¢–ö–ò –ü–õ–ï–ô–õ–ò–°–¢–û–í =======================
async function handlePlaylistLink(ctx, url) {
    let loadingMessage;
    try {
        loadingMessage = await ctx.reply('üîç –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é –ø–ª–µ–π–ª–∏—Å—Ç... –≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–µ–∫—É–Ω–¥.');

        const youtubeDl = getYoutubeDl();
        const output = await youtubeDl(url, {
            dumpSingleJson: true,
            flatPlaylist: true,
        });

        const playlistData = JSON.parse(output);
        const tracks = playlistData.entries;

        if (!tracks || tracks.length === 0) {
            await ctx.telegram.editMessageText(ctx.chat.id, loadingMessage.message_id, undefined, '–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —Ç—Ä–µ–∫–∏ –≤ —ç—Ç–æ–º –ø–ª–µ–π–ª–∏—Å—Ç–µ –∏–ª–∏ –ø–ª–µ–π–ª–∏—Å—Ç –ø—É—Å—Ç.');
            return;
        }

        // –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ "–ê–Ω–∞–ª–∏–∑–∏—Ä—É—é..." –ø–µ—Ä–µ–¥ –æ—Ç–ø—Ä–∞–≤–∫–æ–π –Ω–æ–≤–æ–≥–æ
        await ctx.telegram.deleteMessage(ctx.chat.id, loadingMessage.message_id).catch(()=>{});
        
        // –ü–µ—Ä–µ–¥–∞–µ–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Å–µ—Å—Å–∏–∏ –∏ –æ—Ç–ø—Ä–∞–≤–∫–∏ –º–µ–Ω—é
        await startPlaylistSelection(ctx, playlistData);

    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –ø–ª–µ–π–ª–∏—Å—Ç–∞:', error);
        if (loadingMessage) {
            await ctx.telegram.editMessageText(ctx.chat.id, loadingMessage.message_id, undefined, '‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å —Å—Å—ã–ª–∫—É –Ω–∞ –ø–ª–µ–π–ª–∏—Å—Ç. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –æ–Ω–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞ –∏ –ø–ª–µ–π–ª–∏—Å—Ç –¥–æ—Å—Ç—É–ø–µ–Ω.');
        } else {
            await ctx.reply('‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å —Å—Å—ã–ª–∫—É –Ω–∞ –ø–ª–µ–π–ª–∏—Å—Ç. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –æ–Ω–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞ –∏ –ø–ª–µ–π–ª–∏—Å—Ç –¥–æ—Å—Ç—É–ø–µ–Ω.');
        }
    }
}

async function startPlaylistSelection(ctx, playlistData) {
    const userId = ctx.from.id;
    const tracks = playlistData.entries;
    const playlistId = playlistData.id || `pl_${Date.now()}`; // ID –¥–ª—è callback'–æ–≤, —Å —Ñ–æ–ª–±—ç–∫–æ–º

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –ø–ª–µ–π–ª–∏—Å—Ç–∞ –¥–ª—è —ç—Ç–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    playlistSessions.set(userId, {
        playlistId: playlistId,
        title: playlistData.title,
        tracks: tracks,
        selected: new Set(), // –î–ª—è –±—É–¥—É—â–µ–≥–æ —Ä—É—á–Ω–æ–≥–æ –≤—ã–±–æ—Ä–∞
        currentPage: 0     // –î–ª—è –±—É–¥—É—â–µ–π –ø–∞–≥–∏–Ω–∞—Ü–∏–∏
    });

    const message = `üé∂ –í –ø–ª–µ–π–ª–∏—Å—Ç–µ <b>"${playlistData.title}"</b> –Ω–∞–π–¥–µ–Ω–æ <b>${tracks.length}</b> —Ç—Ä–µ–∫–æ–≤.\n\n–ß—Ç–æ –¥–µ–ª–∞–µ–º?`;
    await ctx.reply(message, {
        parse_mode: 'HTML',
        ...generateInitialPlaylistMenu(playlistId)
    });
}

function generateInitialPlaylistMenu(playlistId) {
    return Markup.inlineKeyboard([
        [Markup.button.callback('üì• –°–∫–∞—á–∞—Ç—å –ø–µ—Ä–≤—ã–µ 10', `pl_download_10:${playlistId}`)],
        [Markup.button.callback('üìù –í—ã–±—Ä–∞—Ç—å —Ç—Ä–µ–∫–∏ –≤—Ä—É—á–Ω—É—é', `pl_select_manual:${playlistId}`)],
        [Markup.button.callback('‚ùå –û—Ç–º–µ–Ω–∞', `pl_cancel:${playlistId}`)]
    ]);
}