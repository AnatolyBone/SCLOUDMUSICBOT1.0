// bot.js (—Ñ–∏–Ω–∞–ª—å–Ω–∞—è, —á–∏—Å—Ç–∞—è –≤–µ—Ä—Å–∏—è, —Å–æ–≤–º–µ—Å—Ç–∏–º–∞—è —Å downloadManager v3.0)

import { Telegraf, Markup, TelegramError } from 'telegraf';
import { HttpsProxyAgent } from 'https-proxy-agent';
import { ADMIN_ID, BOT_TOKEN, WEBHOOK_URL, CHANNEL_USERNAME, PROXY_URL } from './config.js';
import { 
    updateUserField, getUser, setPremium, getAllUsers, 
    resetDailyLimitIfNeeded, getCachedTracksCount, logUserAction, 
    getTopFailedSearches, getTopRecentSearches, getNewUsersCount,
    resetExpiredPremiumIfNeeded
} from './db.js';
import { T, allTextsSync } from './config/texts.js';
import { performInlineSearch } from './services/searchManager.js';
import { enqueue as soundcloudEnqueue, downloadQueue } from './services/downloadManager.js';
import { handleReferralCommand, processNewUserReferral } from './services/referralManager.js';
import { isShuttingDown, isMaintenanceMode, setMaintenanceMode } from './services/appState.js';

// ========================= HELPER FUNCTIONS =========================

function escapeHtml(text) {
    if (typeof text !== 'string') return '';
    return text.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/&/g, '&amp;');
}

async function isSubscribed(userId) {
    if (!CHANNEL_USERNAME) return false;
    try {
        const member = await bot.telegram.getChatMember(CHANNEL_USERNAME, userId);
        return ['creator', 'administrator', 'member'].includes(member.status);
    } catch (e) {
        return false;
    }
}

function getTariffName(limit) {
    if (limit >= 10000) return 'Unlimited ‚Äî üíé';
    if (limit >= 100) return 'Pro ‚Äî 100 üí™';
    if (limit >= 30) return 'Plus ‚Äî 30 üéØ';
    return 'üÜì Free ‚Äî 5 üü¢';
}

function getDaysLeft(premiumUntil) {
    if (!premiumUntil) return 0;
    const diff = new Date(premiumUntil) - new Date();
    return Math.max(Math.ceil(diff / 86400000), 0);
}

function formatMenuMessage(user, botUsername) {
    const tariffLabel = getTariffName(user.premium_limit);
    const downloadsToday = user.downloads_today || 0;
    const daysLeft = getDaysLeft(user.premium_until);
    const referralCount = user.referral_count || 0;
    const referralLink = `https://t.me/${botUsername}?start=ref_${user.id}`;
    
    const statsBlock = `üíº <b>–¢–∞—Ä–∏—Ñ:</b> <i>${tariffLabel}</i>\n` +
                       `‚è≥ <b>–û—Å—Ç–∞–ª–æ—Å—å –¥–Ω–µ–π –ø–æ–¥–ø–∏—Å–∫–∏:</b> <i>${daysLeft}</i>\n` +
                       `üéß <b>–°–µ–≥–æ–¥–Ω—è —Å–∫–∞—á–∞–Ω–æ:</b> <i>${downloadsToday}</i> –∏–∑ <i>${user.premium_limit}</i>`;
    
    const header = T('menu_header').replace('{first_name}', escapeHtml(user.first_name) || '–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å');
    const referralBlock = T('menu_referral_block').replace('{referral_count}', referralCount).replace('{referral_link}', referralLink);
    
    let bonusBlock = '';
    if (!user.subscribed_bonus_used && CHANNEL_USERNAME) {
        const channelLink = `<a href="https://t.me/${CHANNEL_USERNAME.replace('@', '')}">–Ω–∞—à –∫–∞–Ω–∞–ª</a>`;
        bonusBlock = T('menu_bonus_block').replace('{channel_link}', channelLink);
    }
    
    const footer = T('menu_footer');
    return [header, statsBlock, '---', referralBlock, bonusBlock, footer].filter(Boolean).join('\n\n');
}

// ========================= TELEGRAF INIT & MIDDLEWARE =========================

const telegrafOptions = { handlerTimeout: 300_000 };
if (PROXY_URL) {
    telegrafOptions.telegram = { agent: new HttpsProxyAgent(PROXY_URL) };
    console.log('[App] –ò—Å–ø–æ–ª—å–∑—É—é –ø—Ä–æ–∫—Å–∏ –¥–ª—è Telegram API.');
}

export const bot = new Telegraf(BOT_TOKEN, telegrafOptions);

bot.catch(async (err, ctx) => {
    console.error(`üî¥ [Telegraf Catch] –ì–ª–æ–±–∞–ª—å–Ω–∞—è –æ—à–∏–±–∫–∞ –¥–ª—è update ${ctx.update.update_id}:`, err);
    try {
        await bot.telegram.sendMessage(ADMIN_ID, `üî¥ <b>–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ –±–æ—Ç–µ!</b>\n<code>${escapeHtml(err.message)}</code>`, { parse_mode: 'HTML' });
    } catch (sendError) {}
    
    if (err instanceof TelegramError && err.response?.error_code === 403 && ctx.from?.id) {
        await updateUserField(ctx.from.id, 'active', false);
    }
});

bot.use(async (ctx, next) => {
    if (!ctx.from) return next();
    
    const payload = ctx.startPayload || (ctx.message?.text?.startsWith('/start ') ? ctx.message.text.split(' ')[1] : null);
    const user = await getUser(ctx.from.id, ctx.from.first_name, ctx.from.username, payload);
    ctx.state.user = user;
    
    if (!user?.active) return;
    if (user.can_receive_broadcasts === false) {
        try { await updateUserField(user.id, { can_receive_broadcasts: true }); } catch {}
    }
    
    await resetDailyLimitIfNeeded(ctx.from.id);
    await resetExpiredPremiumIfNeeded(ctx.from.id);
    return next();
});

// ========================= COMMANDS & HEARS =========================

bot.start(async (ctx) => {
    const user = ctx.state.user;
    const isNewRegistration = (Date.now() - new Date(user.created_at).getTime()) < 5000;
    
    if (isNewRegistration) {
        await logUserAction(ctx.from.id, 'registration');
        await processNewUserReferral(user, ctx);
    }
    
    const startMessage = isNewRegistration ? T('start_new_user') : T('start');
    await ctx.reply(startMessage, {
        parse_mode: 'HTML',
        disable_web_page_preview: true,
        ...Markup.keyboard([[T('menu'), T('upgrade')], [T('mytracks'), T('help')]]).resize()
    });
});

bot.command('admin', async (ctx) => {
    if (ctx.from.id !== ADMIN_ID) return;
    try {
        await ctx.reply('‚è≥ –°–æ–±–∏—Ä–∞—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É...');
        const [users, cached, failed, recent, newToday, newWeek] = await Promise.all([
            getAllUsers(true), getCachedTracksCount(), getTopFailedSearches(5),
            getTopRecentSearches(5), getNewUsersCount(1), getNewUsersCount(7)
        ]);
        const active = users.filter(u => u.active).length;
        const activeToday = users.filter(u => u.last_active && new Date(u.last_active).toDateString() === new Date().toDateString()).length;
        const totalDl = users.reduce((sum, u) => sum + (u.total_downloads || 0), 0);
        
        let statsMsg = `<b>üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</b>\n\n` +
                       `<b>üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏:</b> ${users.length} –≤—Å–µ–≥–æ / ${active} –∞–∫—Ç–∏–≤–Ω—ã—Ö\n` +
                       `   - –ù–æ–≤—ã—Ö –∑–∞ 24—á/7–¥: ${newToday} / ${newWeek}\n` +
                       `   - –ê–∫—Ç–∏–≤–Ω—ã—Ö —Å–µ–≥–æ–¥–Ω—è: ${activeToday}\n\n` +
                       `<b>üì• –ó–∞–≥—Ä—É–∑–∫–∏:</b> ${totalDl} –≤—Å–µ–≥–æ\n\n` +
                       `<b>‚öôÔ∏è –°–∏—Å—Ç–µ–º–∞:</b>\n` +
                       `   - –û—á–µ—Ä–µ–¥—å: ${downloadQueue.size} / ${downloadQueue.pending}\n` +
                       `   - –ö—ç—à: ${cached} —Ç—Ä–µ–∫–æ–≤\n\n` +
                       `<a href="${WEBHOOK_URL.replace(/\/$/, '')}/dashboard">–û—Ç–∫—Ä—ã—Ç—å –¥–∞—à–±–æ—Ä–¥</a>`;
        await ctx.replyWithHTML(statsMsg, { disable_web_page_preview: true });
    } catch (e) {
        await ctx.reply('‚ùå –û—à–∏–±–∫–∞ —Å–±–æ—Ä–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏.');
    }
});

bot.command('referral', handleReferralCommand);
bot.command('premium', (ctx) => ctx.reply(T('upgradeInfo'), { parse_mode: 'HTML', disable_web_page_preview: true }));

bot.hears(T('menu'), async (ctx) => {
    const message = formatMenuMessage(ctx.state.user, ctx.botInfo.username);
    const extra = { parse_mode: 'HTML', disable_web_page_preview: true };
    if (!ctx.state.user.subscribed_bonus_used && CHANNEL_USERNAME) {
        extra.reply_markup = { inline_keyboard: [[ Markup.button.callback('‚úÖ –Ø –ø–æ–¥–ø–∏—Å–∞–ª—Å—è –∏ —Ö–æ—á—É –±–æ–Ω—É—Å!', 'check_subscription') ]] };
    }
    await ctx.reply(message, extra);
});

bot.hears(T('mytracks'), async (ctx) => {
    try {
        const user = ctx.state.user;
        if (!user.tracks_today?.length) return await ctx.reply(T('noTracks'));
        for (let i = 0; i < user.tracks_today.length; i += 10) {
            const chunk = user.tracks_today.slice(i, i + 10).filter(t => t?.fileId);
            if (chunk.length > 0) await ctx.replyWithMediaGroup(chunk.map(t => ({ type: 'audio', media: t.fileId })));
        }
    } catch (e) {
        console.error(`üî¥ –û—à–∏–±–∫–∞ –≤ mytracks –¥–ª—è ${ctx.from.id}:`, e.message);
    }
});

bot.hears(T('help'), (ctx) => ctx.reply(T('helpInfo'), { parse_mode: 'HTML', disable_web_page_preview: true }));
bot.hears(T('upgrade'), (ctx) => ctx.reply(T('upgradeInfo'), { parse_mode: 'HTML', disable_web_page_preview: true }));

// ========================= URL & TEXT HANDLER =========================

bot.on('text', async (ctx) => {
    if (isShuttingDown()) return;
    if (isMaintenanceMode() && ctx.from.id !== ADMIN_ID) {
        return await ctx.reply('‚è≥ –ë–æ—Ç –Ω–∞ –æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —á–µ—Ä–µ–∑ 5-10 –º–∏–Ω—É—Ç.');
    }
    if (ctx.chat.type !== 'private') return;

    const text = ctx.message.text;
    if (text.startsWith('/') || Object.values(allTextsSync()).includes(text)) return;

    const urlMatch = text.match(/(https?:\/\/[^\s]+)/g);
    if (!urlMatch) {
        return await ctx.reply('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –º–Ω–µ —Å—Å—ã–ª–∫—É –Ω–∞ —Ç—Ä–µ–∫ –∏–ª–∏ –ø–ª–µ–π–ª–∏—Å—Ç SoundCloud.');
    }
    const url = urlMatch[0];

    if (url.includes('soundcloud.com')) {
        // üî• –ü–†–û–°–¢–û –ü–ï–†–ï–î–ê–Å–ú –ó–ê–î–ê–ß–£ –í –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–´–ô downloadManager
        soundcloudEnqueue(ctx, ctx.from.id, url);
    } else if (url.includes('open.spotify.com')) {
        await ctx.reply('üõ† –°–∫–∞—á–∏–≤–∞–Ω–∏–µ –∏–∑ Spotify –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ.');
    } else {
        await ctx.reply('–Ø —É–º–µ—é —Å–∫–∞—á–∏–≤–∞—Ç—å —Ç—Ä–µ–∫–∏ —Ç–æ–ª—å–∫–æ –∏–∑ SoundCloud.');
    }
});

// ========================= INLINE QUERY & ACTIONS =========================

bot.on('inline_query', async (ctx) => {
    const query = ctx.inlineQuery.query;
    if (!query || query.trim().length < 2) {
        return await ctx.answerInlineQuery([], { switch_pm_text: '–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç—Ä–µ–∫–∞...', switch_pm_parameter: 'start' });
    }
    try {
        const results = await performInlineSearch(query, ctx.from.id);
        await ctx.answerInlineQuery(results, { cache_time: 60 });
    } catch (error) {
        console.error('[Inline Query] –ì–ª–æ–±–∞–ª—å–Ω–∞—è –æ—à–∏–±–∫–∞:', error);
        await ctx.answerInlineQuery([]);
    }
});

bot.action('check_subscription', async (ctx) => {
    try {
        if (ctx.state.user.subscribed_bonus_used) {
            return await ctx.answerCbQuery('–í—ã —É–∂–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ —ç—Ç–æ—Ç –±–æ–Ω—É—Å.', { show_alert: true });
        }
        const subscribed = await isSubscribed(ctx.from.id);
        if (subscribed) {
            await setPremium(ctx.from.id, 30, 7);
            await updateUserField(ctx.from.id, 'subscribed_bonus_used', true);
            await logUserAction(ctx.from.id, 'bonus_received');
            await ctx.answerCbQuery('–ë–æ–Ω—É—Å –Ω–∞—á–∏—Å–ª–µ–Ω!');
            await ctx.editMessageText('üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í–∞–º –Ω–∞—á–∏—Å–ª–µ–Ω–æ 7 –¥–Ω–µ–π —Ç–∞—Ä–∏—Ñ–∞ Plus.');
        } else {
            return await ctx.answerCbQuery(`–í—ã –µ—â–µ –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ –∫–∞–Ω–∞–ª ${CHANNEL_USERNAME}.`, { show_alert: true });
        }
    } catch (e) {
        await ctx.answerCbQuery('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.', { show_alert: true });
    }
});