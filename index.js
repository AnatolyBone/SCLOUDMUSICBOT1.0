// index.js

// === –í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ –∏ —Å—Ç–æ—Ä–æ–Ω–Ω–∏–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ ===
import express from 'express';
import session from 'express-session';
import compression from 'compression';
import path from 'path';
import fs from 'fs';
import multer from 'multer';
import expressLayouts from 'express-ejs-layouts';
import { fileURLToPath } from 'url';
import { Telegraf, Markup } from 'telegraf';
import { createClient } from 'redis';
import pgSessionFactory from 'connect-pg-simple';
import json2csv from 'json-2-csv';
import ytdl from 'youtube-dl-exec';

// === –ò–º–ø–æ—Ä—Ç—ã –º–æ–¥—É–ª–µ–π –ù–ê–®–ï–ì–û –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è ===
import { pool, supabase, getFunnelData, createUser, getUser, updateUserField, setPremium, getAllUsers, resetDailyStats, addReview, saveTrackForUser, hasLeftReview, getLatestReviews, resetDailyLimitIfNeeded, getRegistrationsByDate, getDownloadsByDate, getActiveUsersByDate, getExpiringUsers, getReferralSourcesStats, markSubscribedBonusUsed, getUserActivityByDayHour, logUserActivity, getUserById, getExpiringUsersCount, getExpiringUsersPaginated, findCachedTrack, cacheTrack } from './db.js';
import { enqueue, downloadQueue } from './services/downloadManager.js';

// === –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è ===
const BOT_TOKEN = process.env.BOT_TOKEN;
const ADMIN_ID = Number(process.env.ADMIN_ID);
const WEBHOOK_URL = process.env.WEBHOOK_URL;
const WEBHOOK_PATH = '/telegram';
const PORT = process.env.PORT ?? 3000;
const SESSION_SECRET = process.env.SESSION_SECRET || 'a-very-secret-key-for-session';
const ADMIN_LOGIN = process.env.ADMIN_LOGIN;
const ADMIN_PASSWORD = process.env.ADMIN_PASSWORD;
const STORAGE_CHANNEL_ID = process.env.STORAGE_CHANNEL_ID;

if (!BOT_TOKEN || !ADMIN_ID || !ADMIN_LOGIN || !ADMIN_PASSWORD || !WEBHOOK_URL || !STORAGE_CHANNEL_ID) {
    console.error('‚ùå –û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è! (BOT_TOKEN, ADMIN_ID, ADMIN_LOGIN, ADMIN_PASSWORD, WEBHOOK_URL, STORAGE_CHANNEL_ID)');
    process.exit(1);
}

// === –ì–ª–æ–±–∞–ª—å–Ω—ã–µ —ç–∫–∑–µ–º–ø–ª—è—Ä—ã –∏ —É—Ç–∏–ª–∏—Ç—ã ===
const bot = new Telegraf(BOT_TOKEN);
const app = express();
const upload = multer({ dest: 'uploads/' });
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const cacheDir = path.join(__dirname, 'cache');
let redisClient = null;

export function getRedisClient() {
    if (!redisClient) throw new Error('Redis –∫–ª–∏–µ–Ω—Ç –µ—â—ë –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω');
    return redisClient;
}

async function cleanupCache(directory, maxAgeMinutes = 60) {
    try {
        const now = Date.now();
        const files = await fs.promises.readdir(directory);
        let cleanedCount = 0;
        for (const file of files) {
            try {
                const filePath = path.join(directory, file);
                const stat = await fs.promises.stat(filePath);
                if ((now - stat.mtimeMs) / 60000 > maxAgeMinutes) {
                    await fs.promises.unlink(filePath);
                    cleanedCount++;
                }
            } catch (fileError) {}
        }
        if (cleanedCount > 0) console.log(`[Cache Cleanup] –£–¥–∞–ª–µ–Ω–æ ${cleanedCount} —Å—Ç–∞—Ä—ã—Ö —Ñ–∞–π–ª–æ–≤.`);
    } catch (dirError) {
        console.error('[Cache Cleanup] –û—à–∏–±–∫–∞:', dirError);
    }
}

export const texts = {
    start: 'üëã –ü—Ä–∏—à–ª–∏ —Å—Å—ã–ª–∫—É –Ω–∞ —Ç—Ä–µ–∫ –∏–ª–∏ –ø–ª–µ–π–ª–∏—Å—Ç —Å SoundCloud.',
    menu: 'üìã –ú–µ–Ω—é',
    upgrade: 'üîì –†–∞—Å—à–∏—Ä–∏—Ç—å –ª–∏–º–∏—Ç',
    mytracks: 'üéµ –ú–æ–∏ —Ç—Ä–µ–∫–∏',
    help: '‚ÑπÔ∏è –ü–æ–º–æ—â—å',
    downloading: 'üéß –ó–∞–≥—Ä—É–∂–∞—é...',
    error: '‚ùå –û—à–∏–±–∫–∞',
    noTracks: '–°–µ–≥–æ–¥–Ω—è –Ω–µ—Ç —Ç—Ä–µ–∫–æ–≤.',
    limitReached: `üö´ –õ–∏–º–∏—Ç –¥–æ—Å—Ç–∏–≥–Ω—É—Ç ‚ùå\n\nüí° –ß—Ç–æ–±—ã –∫–∞—á–∞—Ç—å –±–æ–ª—å—à–µ —Ç—Ä–µ–∫–æ–≤, –ø–µ—Ä–µ—Ö–æ–¥–∏ –Ω–∞ —Ç–∞—Ä–∏—Ñ Plus –∏–ª–∏ –≤—ã—à–µ –∏ –∫–∞—á–∞–π –±–µ–∑ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π.\n\nüéÅ –ë–æ–Ω—É—Å\nüì£ –ü–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –Ω–∞—à –Ω–æ–≤–æ—Å—Ç–Ω–æ–π –∫–∞–Ω–∞–ª @SCM_BLOG –∏ –ø–æ–ª—É—á–∏ 7 –¥–Ω–µ–π —Ç–∞—Ä–∏—Ñ–∞ Plus –±–µ—Å–ø–ª–∞—Ç–Ω–æ!`,
    upgradeInfo: `üöÄ –•–æ—á–µ—à—å –±–æ–ª—å—à–µ —Ç—Ä–µ–∫–æ–≤?\n\nüÜì Free ‚Äî 5 üü¢  \nPlus ‚Äî 20 üéØ (59‚ÇΩ)  \nPro ‚Äî 50 üí™ (119‚ÇΩ)  \nUnlimited ‚Äî üíé (199‚ÇΩ)\n\nüëâ –î–æ–Ω–∞—Ç: https://boosty.to/anatoly_bone/donate  \n‚úâÔ∏è –ü–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã –Ω–∞–ø–∏—à–∏: @anatolybone\n\nüì£ –ù–æ–≤–æ—Å—Ç–∏ –∏ —Ñ–∏—à–∫–∏: @SCM_BLOG`,
    helpInfo: `‚ÑπÔ∏è –ü—Ä–æ—Å—Ç–æ –ø—Ä–∏—à–ª–∏ —Å—Å—ã–ª–∫—É –∏ –ø–æ–ª—É—á–∏—à—å mp3.  \nüîì –†–∞—Å—à–∏—Ä–∏—Ç—å ‚Äî –æ–ø–ª–∞—Ç–∏ –∏ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏.  \nüéµ –ú–æ–∏ —Ç—Ä–µ–∫–∏ ‚Äî —Å–ø–∏—Å–æ–∫ –∑–∞ —Å–µ–≥–æ–¥–Ω—è.  \nüìã –ú–µ–Ω—é ‚Äî —Ç–∞—Ä–∏—Ñ, –ª–∏–º–∏—Ç—ã, —Ä–µ—Ñ–µ—Ä–∞–ª—ã.  \nüì£ –ö–∞–Ω–∞–ª: @SCM_BLOG`,
    adminCommands: '\n\nüìã –ö–æ–º–∞–Ω–¥—ã –∞–¥–º–∏–Ω–∞:\n/admin ‚Äî —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞'
};

const kb = () => Markup.keyboard([[texts.menu, texts.upgrade], [texts.mytracks, texts.help]]).resize();

// =================================================================
// ===           –õ–û–ì–ò–ö–ê –ë–û–¢–ê-–ò–ù–î–ï–ö–°–ê–¢–û–†–ê ("–ü–ê–£–ö–ê")              ===
// =================================================================
async function getUrlsToIndex() {
    try {
        const { rows } = await pool.query(`
            SELECT url, COUNT(url) as download_count
            FROM downloads_log
            WHERE url IS NOT NULL AND url LIKE '%soundcloud.com%' AND url NOT IN (SELECT url FROM track_cache)
            GROUP BY url
            ORDER BY download_count DESC
            LIMIT 10;
        `);
        return rows.map(row => row.url);
    } catch (e) {
        console.error('[Indexer] –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è URL –¥–ª—è –∏–Ω–¥–µ–∫—Å–∞—Ü–∏–∏:', e);
        return [];
    }
}

async function processUrlForIndexing(url) {
    let tempFilePath = null;
    try {
        const isCached = await findCachedTrack(url);
        if (isCached) return;

        console.log(`[Indexer] –ò–Ω–¥–µ–∫—Å–∏—Ä—É—é: ${url}`);
        const info = await ytdl(url, { dumpSingleJson: true });
        if (!info || Array.isArray(info.entries)) return;

        const trackName = (info.title || 'track').slice(0, 100);
        tempFilePath = path.join(cacheDir, `indexer_${info.id || Date.now()}.mp3`);
        
        await ytdl(url, { output: tempFilePath, extractAudio: true, audioFormat: 'mp3' });

        if (!fs.existsSync(tempFilePath)) throw new Error('–§–∞–π–ª –Ω–µ —Å–æ–∑–¥–∞–Ω');
        
        const message = await bot.telegram.sendAudio(
            STORAGE_CHANNEL_ID,
            { source: fs.createReadStream(tempFilePath) },
            { caption: trackName, title: trackName }
        );

        if (message?.audio?.file_id) {
            await cacheTrack(url, message.audio.file_id, trackName);
            console.log(`‚úÖ [Indexer] –£—Å–ø–µ—à–Ω–æ –∑–∞–∫—ç—à–∏—Ä–æ–≤–∞–Ω: ${trackName}`);
        }
    } catch (err) {
        console.error(`‚ùå [Indexer] –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ ${url}:`, err.stderr || err.message);
    } finally {
        if (tempFilePath) await fs.promises.unlink(tempFilePath).catch(() => {});
    }
}

async function startIndexer() {
    console.log('üöÄ [Indexer] –ó–∞–ø—É—Å–∫ —Ñ–æ–Ω–æ–≤–æ–≥–æ –∏–Ω–¥–µ–∫—Å–∞—Ç–æ—Ä–∞...');
    while (true) {
        try {
            const urls = await getUrlsToIndex();
            if (urls.length > 0) {
                console.log(`[Indexer] –ù–∞–π–¥–µ–Ω–æ ${urls.length} —Ç—Ä–µ–∫–æ–≤ –¥–ª—è —É–ø—Ä–µ–∂–¥–∞—é—â–µ–≥–æ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è.`);
                for (const url of urls) {
                    await processUrlForIndexing(url);
                    await new Promise(resolve => setTimeout(resolve, 30 * 1000));
                }
            }
        } catch (e) {
            console.error('[Indexer] –û—à–∏–±–∫–∞ –≤ –≥–ª–∞–≤–Ω–æ–º —Ü–∏–∫–ª–µ –∏–Ω–¥–µ–∫—Å–∞—Ç–æ—Ä–∞:', e);
        }
        console.log('[Indexer] –ü–∞—É–∑–∞ –Ω–∞ 1 —á–∞—Å.');
        await new Promise(resolve => setTimeout(resolve, 60 * 60 * 1000));
    }
}

// =================================================================
// ===                    –û–°–ù–û–í–ù–ê–Ø –õ–û–ì–ò–ö–ê                       ===
// =================================================================
async function startApp() {
    try {
        console.log('[App] –ó–∞–ø—É—Å–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è...');
        const client = createClient({ url: process.env.REDIS_URL, socket: { connectTimeout: 10000 } });
        client.on('error', (err) => console.error('üî¥ –û—à–∏–±–∫–∞ Redis:', err));
        await client.connect();
        redisClient = client;
        console.log('‚úÖ [App] Redis –ø–æ–¥–∫–ª—é—á—ë–Ω');

        if (!fs.existsSync(cacheDir)) fs.mkdirSync(cacheDir);

        setupExpress();
        setupTelegramBot();
        
        console.log('[App] –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Ñ–æ–Ω–æ–≤—ã—Ö –∑–∞–¥–∞—á (—Ç–∞–π–º–µ—Ä–æ–≤)...');
        setInterval(() => resetDailyStats(), 24 * 3600 * 1000);
        setInterval(() => console.log(`[Monitor] –û—á–µ—Ä–µ–¥—å: ${downloadQueue.size} –≤ –æ–∂–∏–¥–∞–Ω–∏–∏, ${downloadQueue.active} –≤ —Ä–∞–±–æ—Ç–µ.`), 60000);
        setInterval(() => cleanupCache(cacheDir, 60), 30 * 60 * 1000);
        await cleanupCache(cacheDir, 60);

        if (process.env.NODE_ENV === 'production') {
            console.log(`[App] –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –≤–µ–±—Ö—É–∫–∞ –¥–ª—è Telegram –Ω–∞ ${WEBHOOK_URL}...`);
            app.use(await bot.createWebhook({ domain: WEBHOOK_URL, path: WEBHOOK_PATH }));
            app.listen(PORT, () => console.log(`‚úÖ [App] –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É ${PORT}.`));
        } else {
            console.log('[App] –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ –≤ —Ä–µ–∂–∏–º–µ long-polling –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏...');
            await bot.launch();
            console.log('‚úÖ [App] –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω.');
        }
        
        // <<< –ò–ó–ú–ï–ù–ï–ù–û: –§–æ–Ω–æ–≤—ã–π –∏–Ω–¥–µ–∫—Å–∞—Ç–æ—Ä –æ—Ç–∫–ª—é—á–µ–Ω –¥–ª—è —Å–Ω–∏–∂–µ–Ω–∏—è –Ω–∞–≥—Ä—É–∑–∫–∏ >>>
        console.log('[App] –§–æ–Ω–æ–≤—ã–π –∏–Ω–¥–µ–∫—Å–∞—Ç–æ—Ä –≤—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–∫–ª—é—á–µ–Ω.');
        // startIndexer().catch(err => console.error("üî¥ –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ –∏–Ω–¥–µ–∫—Å–∞—Ç–æ—Ä–µ:", err));

    } catch (err) {
        console.error('üî¥ –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è:', err);
        process.exit(1);
    }
}

function setupExpress() {
    console.log('[Express] –ù–∞—Å—Ç—Ä–æ–π–∫–∞ Express —Å–µ—Ä–≤–µ—Ä–∞...');
    app.use(compression());
    app.use(express.urlencoded({ extended: true }));
    app.use(express.json());
    app.use(expressLayouts);
    app.set('view engine', 'ejs');
    app.set('views', path.join(__dirname, 'views'));
    app.set('layout', 'layout');
    
    const pgSession = pgSessionFactory(session);
    app.use(session({
        store: new pgSession({ pool, tableName: 'session', createTableIfMissing: true }),
        secret: SESSION_SECRET,
        resave: false,
        saveUninitialized: false,
        cookie: { maxAge: 30 * 24 * 60 * 60 * 1000 }
    }));

    app.use(async (req, res, next) => {
        res.locals.user = null;
        res.locals.page = '';
        if (req.session.authenticated && req.session.userId === ADMIN_ID) {
            try {
                req.user = await getUserById(req.session.userId);
                res.locals.user = req.user;
            } catch(e) { console.error(e); }
        }
        next();
    });

    const requireAuth = (req, res, next) => {
        if (req.session.authenticated && req.session.userId === ADMIN_ID) return next();
        res.redirect('/admin');
    };
    
    app.get('/health', (req, res) => res.status(200).send('OK'));
    
    app.get('/admin', (req, res) => {
        if (req.session.authenticated && req.session.userId === ADMIN_ID) return res.redirect('/dashboard');
        res.render('login', { title: '–í—Ö–æ–¥ –≤ –∞–¥–º–∏–Ω–∫—É', error: null });
    });

    app.post('/admin', (req, res) => {
        const { username, password } = req.body;
        if (username === ADMIN_LOGIN && password === ADMIN_PASSWORD) {
            req.session.authenticated = true;
            req.session.userId = ADMIN_ID;
            res.redirect('/dashboard');
        } else {
            res.render('login', { title: '–í—Ö–æ–¥ –≤ –∞–¥–º–∏–Ω–∫—É', error: '–ù–µ–≤–µ—Ä–Ω—ã–π –ª–æ–≥–∏–Ω –∏–ª–∏ –ø–∞—Ä–æ–ª—å' });
        }
    });

    app.get('/logout', (req, res) => { req.session.destroy(() => res.redirect('/admin')); });
    
    app.get('/broadcast', requireAuth, (req, res) => {
        res.render('broadcast-form', { title: '–†–∞—Å—Å—ã–ª–∫–∞', error: null, success: null });
    });

    app.post('/broadcast', requireAuth, upload.single('audio'), async (req, res) => {
        console.log('[Admin] –ó–∞–ø—É—â–µ–Ω–∞ —Ä–∞—Å—Å—ã–ª–∫–∞...');
        const { message } = req.body;
        const audio = req.file;
        if (!message && !audio) return res.status(400).render('broadcast-form', { error: '–¢–µ–∫—Å—Ç –∏–ª–∏ —Ñ–∞–π–ª –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã' });
        
        const users = await getAllUsers();
        let success = 0, error = 0;
        
        for (const u of users) {
            if (!u.active) continue;
            try {
                if (audio) await bot.telegram.sendAudio(u.id, { source: fs.createReadStream(audio.path) }, { caption: message });
                else await bot.telegram.sendMessage(u.id, message);
                success++;
            } catch (e) {
                error++;
                if (e.response?.error_code === 403) await updateUserField(u.id, 'active', false);
            }
            await new Promise(r => setTimeout(r, 150));
        }
        
        if (audio) await fs.promises.unlink(audio.path);
        console.log(`[Admin] –†–∞—Å—Å—ã–ª–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –£—Å–ø–µ—à–Ω–æ: ${success}, –û—à–∏–±–æ–∫: ${error}`);
        
        try {
            await bot.telegram.sendMessage(ADMIN_ID, `üì£ –†–∞—Å—Å—ã–ª–∫–∞: ‚úÖ ${success} ‚ùå ${error}`);
        } catch (adminError) {
            console.error('–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ç—á–µ—Ç –∞–¥–º–∏–Ω—É –æ —Ä–∞—Å—Å—ã–ª–∫–µ:', adminError.message);
        }
        
        res.render('broadcast-form', { title: '–†–∞—Å—Å—ã–ª–∫–∞', success: `–£—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: ${success}`, error: `–û—à–∏–±–æ–∫: ${error}` });
    });
}

function setupTelegramBot() {
    console.log('[Telegraf] –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ –±–æ—Ç–∞...');

    bot.catch((err, ctx) => {
        console.error(`üî¥ [Telegraf] –ì–ª–æ–±–∞–ª—å–Ω–∞—è –Ω–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –¥–ª—è update ${ctx.update.update_id}:`, err);
        try {
            ctx.reply('–û–π, —á—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –µ—â–µ —Ä–∞–∑.').catch(() => {});
        } catch {}
    });

    bot.use(async (ctx, next) => {
        const userId = ctx.from?.id;
        if (!userId) return next();
        try {
            ctx.state.user = await getUser(userId, ctx.from.first_name, ctx.from.username);
        } catch (error) { console.error(`–û—à–∏–±–∫–∞ –≤ –º–∏–¥–ª–≤–∞—Ä–µ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${userId}:`, error); }
        return next();
    });

    bot.start(async (ctx) => {
        console.log(`[Bot] /start –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${ctx.from.id}`);
        try {
            await createUser(ctx.from.id, ctx.from.first_name, ctx.from.username, ctx.startPayload || null);
            await ctx.reply(texts.start, kb());
        } catch (e) { console.error(`–û—à–∏–±–∫–∞ –≤ /start –¥–ª—è ${ctx.from.id}:`, e); }
    });

    bot.hears(texts.menu, async (ctx) => {
        console.log(`[Bot] "–ú–µ–Ω—é" –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${ctx.from.id}`);
        try {
            // ... –≤–∞—à–∞ –ª–æ–≥–∏–∫–∞ –º–µ–Ω—é
        } catch (e) { console.error(`–û—à–∏–±–∫–∞ –≤ "–ú–µ–Ω—é" –¥–ª—è ${ctx.from.id}:`, e); }
    });

    // ... –î—Ä—É–≥–∏–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ ...

    bot.on('text', async (ctx) => {
        const userId = ctx.from.id;
        console.log(`[Bot] –ü–æ–ª—É—á–µ–Ω–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç ${userId}`);
        try {
            const url = ctx.message.text.match(/(https?:\/\/[^\s]+)/g)?.find(u => u.includes('soundcloud.com'));
            if (url) {
                console.log(`[Bot] –ù–∞–π–¥–µ–Ω–∞ SoundCloud —Å—Å—ã–ª–∫–∞ –æ—Ç ${userId}: ${url}`);
                await enqueue(ctx, userId, url);
            } else {
                if (!Object.values(texts).includes(ctx.message.text)) {
                    await ctx.reply('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–∏—à–ª–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é —Å—Å—ã–ª–∫—É –Ω–∞ —Ç—Ä–µ–∫ –∏–ª–∏ –ø–ª–µ–π–ª–∏—Å—Ç.');
                }
            }
        } catch (e) {
            console.error(`[Bot] –û—à–∏–±–∫–∞ –≤ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–µ —Ç–µ–∫—Å—Ç–∞ –¥–ª—è ${userId}:`, e);
            await ctx.reply(texts.error).catch(() => {});
        }
    });
}

// === –ó–ê–ü–£–°–ö –ò –û–°–¢–ê–ù–û–í–ö–ê –ü–†–ò–õ–û–ñ–ï–ù–ò–Ø ===
async function stopBot(signal) {
    console.log(`[App] –ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª ${signal}. –ù–∞—á–∏–Ω–∞—é –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ...`);
    try {
        if (bot.polling?.isRunning()) {
            bot.stop(signal);
            console.log('[App] Telegraf –±–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.');
        }
        
        const promises = [];
        if (redisClient?.isOpen) {
            promises.push(redisClient.quit().then(() => console.log('[App] Redis –æ—Ç–∫–ª—é—á—ë–Ω.')));
        }
        promises.push(pool.end().then(() => console.log('[App] –ü—É–ª PostgreSQL –∑–∞–∫—Ä—ã—Ç.')));
        
        await Promise.allSettled(promises);
        console.log('[App] –í—Å–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –∑–∞–∫—Ä—ã—Ç—ã. –í—ã—Ö–æ–¥.');
        
        process.exit(0);

    } catch (e) {
        console.error('üî¥ –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ —Ä–∞–±–æ—Ç—ã:', e);
        process.exit(1);
    }
}

process.once('SIGINT', () => stopBot('SIGINT'));
process.once('SIGTERM', () => stopBot('SIGTERM'));

startApp();

export { app, bot, startApp };