// index.js

// === –í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ –∏ —Å—Ç–æ—Ä–æ–Ω–Ω–∏–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ ===
import express from 'express';
import session from 'express-session';
import compression from 'compression';
import path from 'path';
import fs from 'fs';
import multer from 'multer';
import expressLayouts from 'express-ejs-layouts';
import { fileURLToPath } from 'url';
import { Telegraf, Markup } from 'telegraf';
import { createClient } from 'redis';
import pgSessionFactory from 'connect-pg-simple';
import json2csv from 'json-2-csv';
import ytdl from 'youtube-dl-exec';

// === –ò–º–ø–æ—Ä—Ç—ã –º–æ–¥—É–ª–µ–π –ù–ê–®–ï–ì–û –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è ===
import { pool, supabase, getFunnelData, createUser, getUser, updateUserField, setPremium, getAllUsers, resetDailyStats, addReview, saveTrackForUser, hasLeftReview, getLatestReviews, resetDailyLimitIfNeeded, getRegistrationsByDate, getDownloadsByDate, getActiveUsersByDate, getExpiringUsers, getReferralSourcesStats, markSubscribedBonusUsed, getUserActivityByDayHour, logUserActivity, getUserById, getExpiringUsersCount, getExpiringUsersPaginated, findCachedTrack, cacheTrack } from './db.js';
import { enqueue, downloadQueue } from './services/downloadManager.js';

// === –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è ===
const BOT_TOKEN = process.env.BOT_TOKEN;
const ADMIN_ID = Number(process.env.ADMIN_ID);
const WEBHOOK_URL = process.env.WEBHOOK_URL;
const WEBHOOK_PATH = '/telegram';
const PORT = process.env.PORT ?? 3000;
const SESSION_SECRET = process.env.SESSION_SECRET || 'a-very-secret-key-for-session';
const ADMIN_LOGIN = process.env.ADMIN_LOGIN;
const ADMIN_PASSWORD = process.env.ADMIN_PASSWORD;
const STORAGE_CHANNEL_ID = process.env.STORAGE_CHANNEL_ID;

if (!BOT_TOKEN || !ADMIN_ID || !ADMIN_LOGIN || !ADMIN_PASSWORD || !WEBHOOK_URL || !STORAGE_CHANNEL_ID) {
    console.error('‚ùå –û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è!');
    process.exit(1);
}

// === –ì–ª–æ–±–∞–ª—å–Ω—ã–µ —ç–∫–∑–µ–º–ø–ª—è—Ä—ã –∏ —É—Ç–∏–ª–∏—Ç—ã ===
const bot = new Telegraf(BOT_TOKEN);
const app = express();
const upload = multer({ dest: 'uploads/' });
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const cacheDir = path.join(__dirname, 'cache');
let redisClient = null;

export function getRedisClient() {
    if (!redisClient) throw new Error('Redis –∫–ª–∏–µ–Ω—Ç –µ—â—ë –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω');
    return redisClient;
}

async function cleanupCache(directory, maxAgeMinutes = 60) {
    // ... (–∫–æ–¥ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
}

export const texts = {
    start: 'üëã –ü—Ä–∏—à–ª–∏ —Å—Å—ã–ª–∫—É –Ω–∞ —Ç—Ä–µ–∫ –∏–ª–∏ –ø–ª–µ–π–ª–∏—Å—Ç —Å SoundCloud.',
    menu: 'üìã –ú–µ–Ω—é',
    upgrade: 'üîì –†–∞—Å—à–∏—Ä–∏—Ç—å –ª–∏–º–∏—Ç',
    mytracks: 'üéµ –ú–æ–∏ —Ç—Ä–µ–∫–∏',
    help: '‚ÑπÔ∏è –ü–æ–º–æ—â—å',
    // ... (–æ—Å—Ç–∞–ª—å–Ω—ã–µ —Ç–µ–∫—Å—Ç—ã –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
};

const kb = () => Markup.keyboard([[texts.menu, texts.upgrade], [texts.mytracks, texts.help]]).resize();

// ... (–∫–æ–¥ –∏–Ω–¥–µ–∫—Å–∞—Ç–æ—Ä–∞ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ...

// =================================================================
// ===                    –û–°–ù–û–í–ù–ê–Ø –õ–û–ì–ò–ö–ê                       ===
// =================================================================
async function startApp() {
    console.log('[App] –ó–∞–ø—É—Å–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è...');
    try {
        const client = createClient({ url: process.env.REDIS_URL, socket: { connectTimeout: 10000 } });
        client.on('error', (err) => console.error('üî¥ –û—à–∏–±–∫–∞ Redis:', err));
        await client.connect();
        redisClient = client;
        console.log('‚úÖ [App] Redis –ø–æ–¥–∫–ª—é—á—ë–Ω');

        if (!fs.existsSync(cacheDir)) fs.mkdirSync(cacheDir);

        setupExpress();
        setupTelegramBot();
        
        console.log('[App] –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Ñ–æ–Ω–æ–≤—ã—Ö –∑–∞–¥–∞—á (—Ç–∞–π–º–µ—Ä–æ–≤)...');
        setInterval(() => resetDailyStats(), 24 * 3600 * 1000);
        setInterval(() => console.log(`[Monitor] –û—á–µ—Ä–µ–¥—å: ${downloadQueue.size} –≤ –æ–∂–∏–¥–∞–Ω–∏–∏, ${downloadQueue.active} –≤ —Ä–∞–±–æ—Ç–µ.`), 60000);
        setInterval(() => cleanupCache(cacheDir, 60), 30 * 60 * 1000);
        
        if (process.env.NODE_ENV === 'production') {
            console.log(`[App] –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –≤–µ–±—Ö—É–∫–∞ –¥–ª—è Telegram –Ω–∞ ${WEBHOOK_URL}...`);
            app.use(await bot.createWebhook({ domain: WEBHOOK_URL, path: WEBHOOK_PATH }));
            app.listen(PORT, () => console.log(`‚úÖ [App] –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É ${PORT}.`));
        } else {
            console.log('[App] –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ –≤ —Ä–µ–∂–∏–º–µ long-polling –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏...');
            await bot.launch();
        }
        
        console.log('[App] –§–æ–Ω–æ–≤—ã–π –∏–Ω–¥–µ–∫—Å–∞—Ç–æ—Ä –≤—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–∫–ª—é—á–µ–Ω.');
        // startIndexer().catch(err => console.error("üî¥ –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ –∏–Ω–¥–µ–∫—Å–∞—Ç–æ—Ä–µ:", err));

    } catch (err) {
        console.error('üî¥ –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è:', err);
        process.exit(1);
    }
}

function setupExpress() {
    console.log('[Express] –ù–∞—Å—Ç—Ä–æ–π–∫–∞ Express —Å–µ—Ä–≤–µ—Ä–∞...');
    app.use(compression());
    app.use(express.urlencoded({ extended: true }));
    app.use(express.json());
    app.use(expressLayouts);
    app.set('view engine', 'ejs');
    app.set('views', path.join(__dirname, 'views'));
    app.set('layout', 'layout');
    
    const pgSession = pgSessionFactory(session);
    app.use(session({ store: new pgSession({ pool }), secret: SESSION_SECRET, resave: false, saveUninitialized: false, cookie: { maxAge: 30 * 24 * 60 * 60 * 1000 }}));

    const requireAuth = (req, res, next) => {
        if (req.session.authenticated && req.session.userId === ADMIN_ID) return next();
        res.redirect('/admin');
    };
    
    app.get('/health', (req, res) => res.status(200).send('OK'));
    
    // ... (–≤—Å–µ –º–∞—Ä—à—Ä—É—Ç—ã –∞–¥–º–∏–Ω–∫–∏ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ...
    app.get('/admin', (req, res) => res.render('login', { title: '–í—Ö–æ–¥ –≤ –∞–¥–º–∏–Ω–∫—É', error: null }));
    app.post('/admin', (req, res) => { /* ... */ });
    app.get('/broadcast', requireAuth, (req, res) => res.render('broadcast-form', { title: '–†–∞—Å—Å—ã–ª–∫–∞', error: null, success: null }));
    app.post('/broadcast', requireAuth, upload.single('audio'), async (req, res) => { /* ... */ });
}

function setupTelegramBot() {
    console.log('[Telegraf] –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ –±–æ—Ç–∞...');

    bot.catch((err, ctx) => {
        console.error(`üî¥ [Telegraf] –ì–ª–æ–±–∞–ª—å–Ω–∞—è –æ—à–∏–±–∫–∞ –¥–ª—è update ${ctx.update.update_id}:`, err);
    });

    bot.use(async (ctx, next) => {
        const userId = ctx.from?.id;
        if (!userId) return next();
        try {
            ctx.state.user = await getUser(userId, ctx.from.first_name, ctx.from.username);
        } catch (error) { console.error(`–û—à–∏–±–∫–∞ –≤ –º–∏–¥–ª–≤–∞—Ä–µ –¥–ª—è ${userId}:`, error); }
        return next();
    });

    bot.start(async (ctx) => {
        console.log(`[Bot] /start –æ—Ç ${ctx.from.id}`);
        try {
            await createUser(ctx.from.id, ctx.from.first_name, ctx.from.username, ctx.startPayload || null);
            await ctx.reply(texts.start, kb());
        } catch (e) { console.error(e); }
    });

    // <<< –í–û–°–°–¢–ê–ù–û–í–õ–ï–ù–û: –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥ —Å –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã >>>
    bot.hears(texts.menu, async (ctx) => {
        console.log(`[Bot] "–ú–µ–Ω—é" –æ—Ç ${ctx.from.id}`);
        try {
            const user = await getUser(ctx.from.id);
            // –¢—É—Ç –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –≤–∞—à–∞ —Ñ—É–Ω–∫—Ü–∏—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è –º–µ–Ω—é
            await ctx.reply(`–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –ø–æ –≤–∞—à–µ–º—É –ø—Ä–æ—Ñ–∏–ª—é...`, kb());
        } catch (e) { console.error(e); }
    });
    
    bot.hears(texts.mytracks, async (ctx) => {
        console.log(`[Bot] "–ú–æ–∏ —Ç—Ä–µ–∫–∏" –æ—Ç ${ctx.from.id}`);
        try {
            const user = await getUser(ctx.from.id);
            let tracks = [];
            try { if (user.tracks_today) tracks = JSON.parse(user.tracks_today); } catch {}
            if (!tracks.length) return await ctx.reply(texts.noTracks);
            
            for (let i = 0; i < tracks.length; i += 10) {
                const chunk = tracks.slice(i, i + 10).filter(t => t.fileId);
                if (chunk.length > 0) {
                    await ctx.replyWithMediaGroup(chunk.map(t => ({ type: 'audio', media: t.fileId })));
                }
            }
        } catch (e) { console.error(e); }
    });

    bot.hears(texts.help, async (ctx) => {
        console.log(`[Bot] "–ü–æ–º–æ—â—å" –æ—Ç ${ctx.from.id}`);
        await ctx.reply(texts.helpInfo, kb());
    });

    bot.hears(texts.upgrade, async (ctx) => {
        console.log(`[Bot] "–†–∞—Å—à–∏—Ä–∏—Ç—å –ª–∏–º–∏—Ç" –æ—Ç ${ctx.from.id}`);
        await ctx.reply(texts.upgradeInfo, kb());
    });
    
    // ... (–¥—Ä—É–≥–∏–µ –≤–∞—à–∏ –∫–æ–º–∞–Ω–¥—ã, –Ω–∞–ø—Ä–∏–º–µ—Ä /admin)
    bot.command('admin', async (ctx) => {
        if (ctx.from.id !== ADMIN_ID) return;
        // ... –≤–∞—à–∞ –ª–æ–≥–∏–∫–∞ –∞–¥–º–∏–Ω-–∫–æ–º–∞–Ω–¥—ã
    });


    // <<< –ò–°–ü–†–ê–í–õ–ï–ù–û: –£—Å–∏–ª–µ–Ω–Ω—ã–π –æ–±—â–∏–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ —Ç–µ–∫—Å—Ç–∞, –∫–æ—Ç–æ—Ä—ã–π –∏–¥–µ—Ç –ü–û–°–õ–ï hears >>>
    bot.on('text', async (ctx) => {
        const userId = ctx.from.id;
        const userText = ctx.message.text;

        // –®–∞–≥ 1: –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ç–µ–∫—Å—Ç –∏–∑–≤–µ—Å—Ç–Ω–æ–π –∫–æ–º–∞–Ω–¥–æ–π.
        // `bot.hears` —É–∂–µ –¥–æ–ª–∂–µ–Ω –±—ã–ª –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å —ç—Ç–∏ –∫–æ–º–∞–Ω–¥—ã, –ø–æ—ç—Ç–æ–º—É –∑–¥–µ—Å—å –º—ã –∏—Ö –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º.
        if (Object.values(texts).includes(userText)) {
            return;
        }

        console.log(`[Bot] –ü–æ–ª—É—á–µ–Ω–æ –ù–ï–∫–æ–º–∞–Ω–¥–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç ${userId}, –∏—â–µ–º —Å—Å—ã–ª–∫—É...`);
        try {
            // –®–∞–≥ 2: –ò—â–µ–º —Å—Å—ã–ª–∫—É —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —ç—Ç–æ –Ω–µ –∫–æ–º–∞–Ω–¥–∞.
            const url = userText.match(/(https?:\/\/[^\s]+)/g)?.find(u => u.includes('soundcloud.com'));
            
            if (url) {
                console.log(`[Bot] –ù–∞–π–¥–µ–Ω–∞ SoundCloud —Å—Å—ã–ª–∫–∞ –æ—Ç ${userId}: ${url}`);
                await enqueue(ctx, userId, url);
            } else {
                // –®–∞–≥ 3: –ï—Å–ª–∏ —ç—Ç–æ –Ω–µ –∫–æ–º–∞–Ω–¥–∞ –∏ –Ω–µ —Å—Å—ã–ª–∫–∞, –¥–∞–µ–º –ø–æ–Ω—è—Ç–Ω—ã–π –æ—Ç–≤–µ—Ç.
                await ctx.reply('–Ø –Ω–µ –ø–æ–Ω—è–ª. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–∏—à–ª–∏—Ç–µ —Å—Å—ã–ª–∫—É –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –º–µ–Ω—é.');
            }
        } catch (e) {
            console.error(`[Bot] –û—à–∏–±–∫–∞ –≤ –æ–±—â–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–µ —Ç–µ–∫—Å—Ç–∞ –¥–ª—è ${userId}:`, e);
            await ctx.reply(texts.error).catch(() => {});
        }
    });
}

// === –ó–ê–ü–£–°–ö –ò –û–°–¢–ê–ù–û–í–ö–ê –ü–†–ò–õ–û–ñ–ï–ù–ò–Ø ===
async function stopBot(signal) {
    console.log(`[App] –ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª ${signal}. –ù–∞—á–∏–Ω–∞—é –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ...`);
    try {
        if (bot.polling?.isRunning()) bot.stop(signal);
        
        const promises = [];
        if (redisClient?.isOpen) promises.push(redisClient.quit());
        promises.push(pool.end());
        
        await Promise.allSettled(promises);
        console.log('[App] –í—Å–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –∑–∞–∫—Ä—ã—Ç—ã. –í—ã—Ö–æ–¥.');
        process.exit(0);
    } catch (e) {
        console.error('üî¥ –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ —Ä–∞–±–æ—Ç—ã:', e);
        process.exit(1);
    }
}

process.once('SIGINT', () => stopBot('SIGINT'));
process.once('SIGTERM', () => stopBot('SIGTERM'));

startApp();

export { app, bot, startApp };