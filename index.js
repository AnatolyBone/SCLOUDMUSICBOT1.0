// index.js (–§–ò–ù–ê–õ–¨–ù–ê–Ø –í–ï–†–°–ò–Ø –°–û –í–°–ï–ú–ò –§–£–ù–ö–¶–ò–Ø–ú–ò –ò –ò–ú–ü–û–†–¢–ê–ú–ò)

import express from 'express';
import session from 'express-session';
import compression from 'compression';
import path from 'path';
import multer from 'multer';
import expressLayouts from 'express-ejs-layouts';
import { fileURLToPath } from 'url';
import pgSessionFactory from 'connect-pg-simple';
import pLimit from 'p-limit';
import fs from 'fs';
import cron from 'node-cron';

// –ü–æ–ª–Ω—ã–π –∏ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Å–ø–∏—Å–æ–∫ –∏–º–ø–æ—Ä—Ç–æ–≤ –∏–∑ db.js
import { 
    pool, supabase, getUserById, resetDailyStats, getAllUsers, getPaginatedUsers, 
    getReferralSourcesStats, getDownloadsByDate, getRegistrationsByDate, 
    getActiveUsersByDate, getExpiringUsers, setPremium, updateUserField, 
    getLatestReviews, getUserActivityByDayHour, getDownloadsByUserId, getReferralsByUserId, 
    getCachedTracksCount, getActiveFreeUsers, getActivePremiumUsers,
    createBroadcastTask, getPendingBroadcastTask, completeBroadcastTask, failBroadcastTask,
    getAllBroadcastTasks, deleteBroadcastTask, getBroadcastTaskById, updateBroadcastTask,
    getUsersCountByTariff, getTopReferralSources, getDailyStats, getActivityByWeekday, logEvent
} from './db.js';
import { bot } from './bot.js';
import redisService from './services/redisClient.js';
import { WEBHOOK_URL, PORT, SESSION_SECRET, ADMIN_ID, ADMIN_LOGIN, ADMIN_PASSWORD, WEBHOOK_PATH, STORAGE_CHANNEL_ID, CHANNEL_USERNAME } from './config.js';
import { loadTexts } from './config/texts.js';
import { downloadQueue } from './services/downloadManager.js';

const app = express();
const upload = multer({ dest: 'uploads/' });
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const limit = pLimit(1); 

async function startApp() {
    console.log('[App] –ó–∞–ø—É—Å–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è...');
    try {
        await loadTexts(true);
        await redisService.connect();
        
        setupExpress();
        startBroadcastWorker();

        if (process.env.NODE_ENV === 'production') {
            const fullWebhookUrl = (WEBHOOK_URL.endsWith('/') ? WEBHOOK_URL.slice(0, -1) : WEBHOOK_URL) + WEBHOOK_PATH;
            const webhookInfo = await bot.telegram.getWebhookInfo();
            if (webhookInfo.url !== fullWebhookUrl) {
                await bot.telegram.setWebhook(fullWebhookUrl, { drop_pending_updates: true });
                console.log('[App] –í–µ–±—Ö—É–∫ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.');
            } else {
                console.log('[App] –í–µ–±—Ö—É–∫ —É–∂–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.');
            }
            app.use(bot.webhookCallback(WEBHOOK_PATH));
        } else {
            console.log('[App] –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ –≤ —Ä–µ–∂–∏–º–µ long-polling...');
            await bot.telegram.deleteWebhook({ drop_pending_updates: true });
            bot.launch();
        }
        
        app.listen(PORT, () => console.log(`‚úÖ [App] –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É ${PORT}.`));
        
        console.log('[App] –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Ñ–æ–Ω–æ–≤—ã—Ö –∑–∞–¥–∞—á...');
        setInterval(() => resetDailyStats(), 24 * 3600 * 1000);
        setInterval(() => console.log(`[Monitor] –û—á–µ—Ä–µ–¥—å: ${downloadQueue.size} –≤ –æ–∂–∏–¥–∞–Ω–∏–∏, ${downloadQueue.active} –≤ —Ä–∞–±–æ—Ç–µ.`), 60000);

    } catch (err) {
        console.error('üî¥ –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ:', err);
        process.exit(1);
    }
}

function setupExpress() {
    console.log('[Express] –ù–∞—Å—Ç—Ä–æ–π–∫–∞ Express —Å–µ—Ä–≤–µ—Ä–∞...');
    app.use(compression());
    app.use(express.urlencoded({ extended: true }));
    app.use(express.json());
    app.use('/static', express.static(path.join(__dirname, 'public')));
    app.use(expressLayouts);
    app.set('view engine', 'ejs');
    app.set('views', path.join(__dirname, 'views'));
    app.set('layout', 'layout');
    const pgSession = pgSessionFactory(session);
    app.use(session({ store: new pgSession({ pool, tableName: 'session' }), secret: SESSION_SECRET, resave: false, saveUninitialized: false, cookie: { maxAge: 30 * 24 * 60 * 60 * 1000 } }));
    app.use(async (req, res, next) => {
        res.locals.user = null;
        res.locals.page = '';
        if (req.session.authenticated && req.session.userId === ADMIN_ID) {
            try { res.locals.user = await getUserById(req.session.userId); } catch {}
        }
        next();
    });
    const requireAuth = (req, res, next) => {
        if (req.session.authenticated && req.session.userId === ADMIN_ID) return next();
        res.redirect('/admin');
    };
    
    app.get('/health', (req, res) => res.status(200).send('OK'));
    app.get('/', requireAuth, (req, res) => res.redirect('/dashboard'));
    app.get('/admin', (req, res) => {
        if (req.session.authenticated) return res.redirect('/dashboard');
        res.render('login', { title: '–í—Ö–æ–¥', page: 'login', layout: false, error: null });
    });
    app.post('/admin', (req, res) => {
        if (req.body.username === ADMIN_LOGIN && req.body.password === ADMIN_PASSWORD) {
            req.session.authenticated = true;
            req.session.userId = ADMIN_ID;
            res.redirect('/dashboard');
        } else {
            res.render('login', { title: '–í—Ö–æ–¥', error: '–ù–µ–≤–µ—Ä–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ', page: 'login', layout: false });
        }
    });
    app.get('/logout', (req, res) => req.session.destroy(() => res.redirect('/admin')));
    
    // –í –§–ê–ô–õ–ï index.js

// >>>>> –ó–ê–ú–ï–ù–ò–¢–ï –í–ï–°–¨ –ë–õ–û–ö app.get('/dashboard', ...) –ù–ê –≠–¢–û–¢ <<<<<

app.get('/dashboard', requireAuth, async (req, res) => {
    try {
        const period = req.query.period || 30; // –ë–µ—Ä–µ–º –ø–µ—Ä–∏–æ–¥ –∏–∑ URL, –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 30 –¥–Ω–µ–π
        
        let storageStatus = { available: false, error: '' };
        if (STORAGE_CHANNEL_ID) {
            try {
                await bot.telegram.getChat(STORAGE_CHANNEL_ID);
                storageStatus.available = true;
            } catch (e) {
                storageStatus.error = e.message;
                console.error("[Dashboard] –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–∞–Ω–∞–ª–∞-—Ö—Ä–∞–Ω–∏–ª–∏—â–∞:", e.message);
            }
        }
        
        // –ó–∞–ø—É—Å–∫–∞–µ–º –≤—Å–µ –∑–∞–ø—Ä–æ—Å—ã –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ –¥–ª—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π —Å–∫–æ—Ä–æ—Å—Ç–∏
        const [
            users,
            cachedTracksCount,
            usersByTariff,
            topSources,
            dailyStats,
            weekdayActivity
        ] = await Promise.all([
            getAllUsers(true),
            getCachedTracksCount(),
            getUsersCountByTariff(),
            getTopReferralSources(),
            getDailyStats(period),
            getActivityByWeekday()
        ]);
        
        // –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ –º–µ—Ç—Ä–∏–∫–∏ –≤ –æ–¥–∏–Ω —É–¥–æ–±–Ω—ã–π –æ–±—ä–µ–∫—Ç
        const stats = {
            total_users: users.length,
            active_users: users.filter(u => u.active).length,
            total_downloads: users.reduce((sum, u) => sum + (u.total_downloads || 0), 0),
            active_today: users.filter(u => u.last_active && new Date(u.last_active).toDateString() === new Date().toDateString()).length,
            queueWaiting: downloadQueue.size,
            queueActive: downloadQueue.active,
            cachedTracksCount: cachedTracksCount,
            usersByTariff: usersByTariff,
            topSources: topSources
        };
        
        // –ì–æ—Ç–æ–≤–∏–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –ì—Ä–∞—Ñ–∏–∫–∞ 1: –î–∏–Ω–∞–º–∏–∫–∞ –º–µ—Ç—Ä–∏–∫
        const chartDataCombined = {
            labels: dailyStats.map(d => new Date(d.day).toLocaleDateString('ru-RU', { day: '2-digit', month: '2-digit' })),
            datasets: [
                { label: '–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏', data: dailyStats.map(d => d.registrations), borderColor: '#198754', tension: 0.1, fill: false },
                { label: '–ê–∫—Ç–∏–≤–Ω—ã–µ —é–∑–µ—Ä—ã', data: dailyStats.map(d => d.active_users), borderColor: '#0d6efd', tension: 0.1, fill: false },
                { label: '–ó–∞–≥—Ä—É–∑–∫–∏', data: dailyStats.map(d => d.downloads), borderColor: '#fd7e14', tension: 0.1, fill: false }
            ]
        };
        
        // –ì–æ—Ç–æ–≤–∏–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –ì—Ä–∞—Ñ–∏–∫–∞ 2: –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–æ —Ç–∞—Ä–∏—Ñ–∞–º
        const chartDataTariffs = {
            labels: Object.keys(usersByTariff),
            datasets: [{
                data: Object.values(usersByTariff),
                backgroundColor: ['#6c757d', '#17a2b8', '#ffc107', '#007bff'] // –¶–≤–µ—Ç–∞ –¥–ª—è Free, Plus, Pro, Unlimited
            }]
        };
        
        // –ì–æ—Ç–æ–≤–∏–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –ì—Ä–∞—Ñ–∏–∫–∞ 3: –ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –ø–æ –¥–Ω—è–º –Ω–µ–¥–µ–ª–∏
        const chartDataWeekday = {
            labels: weekdayActivity.map(d => d.weekday.trim()),
            datasets: [{
                label: '–ó–∞–≥—Ä—É–∑–∫–∏',
                data: weekdayActivity.map(d => d.count),
                backgroundColor: 'rgba(13, 110, 253, 0.5)',
                borderColor: 'rgba(13, 110, 253, 1)',
                borderWidth: 1
            }]
        };
        
        // –†–µ–Ω–¥–µ—Ä–∏–º —à–∞–±–ª–æ–Ω, –ø–µ—Ä–µ–¥–∞–≤–∞—è –≤—Å–µ –ø–æ–¥–≥–æ—Ç–æ–≤–ª–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
        res.render('dashboard', {
            title: '–î–∞—à–±–æ—Ä–¥',
            page: 'dashboard',
            stats,
            storageStatus,
            period,
            chartDataCombined,
            chartDataTariffs,
            chartDataWeekday
        });
    } catch (error) {
        console.error("–û—à–∏–±–∫–∞ –¥–∞—à–±–æ—Ä–¥–∞:", error);
        res.status(500).send("–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞");
    }
});

    app.get('/users', requireAuth, async (req, res) => {
        try {
            const { q = '', status = '', page = 1, limit = 25, sort = 'created_at', order = 'desc' } = req.query;
            const { users, totalPages, totalUsers } = await getPaginatedUsers({
                searchQuery: q, statusFilter: status, page: parseInt(page), limit: parseInt(limit), sortBy: sort, sortOrder: order
            });
            const queryParams = { q, status, page, limit, sort, order };
            res.render('users', { title: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏', page: 'users', users, totalUsers, totalPages, currentPage: parseInt(page), limit: parseInt(limit), searchQuery: q, statusFilter: status, queryParams });
        } catch (error) {
            console.error("–û—à–∏–±–∫–∞ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:", error);
            res.status(500).send("–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞");
        }
    });

    app.get('/users-table', requireAuth, async (req, res) => {
        try {
            const { q = '', status = '', page = 1, limit = 25, sort = 'created_at', order = 'desc' } = req.query;
            const { users, totalPages } = await getPaginatedUsers({
                searchQuery: q, statusFilter: status, page: parseInt(page), limit: parseInt(limit), sortBy: sort, sortOrder: order
            });
            const queryParams = { q, status, page, limit, sort, order };
            res.render('partials/users-table', { users, totalPages, currentPage: parseInt(page), queryParams, layout: false });
        } catch (error) {
            console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Ç–∞–±–ª–∏—Ü—ã:", error);
            res.status(500).send("–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞");
        }
    });
    
    app.get('/user/:id', requireAuth, async (req, res) => {
        try {
            const userId = req.params.id;
            const [userProfile, downloads, referrals] = await Promise.all([ getUserById(userId), getDownloadsByUserId(userId), getReferralsByUserId(userId) ]);
            if (!userProfile) {
                return res.status(404).render('user-profile', { title: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω', page: 'users', userProfile: null, downloads: [], referrals: [] });
            }
            res.render('user-profile', { title: `–ü—Ä–æ—Ñ–∏–ª—å: ${userProfile.first_name || userId}`, page: 'users', userProfile, downloads, referrals });
        } catch (error) {
            console.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø—Ä–æ—Ñ–∏–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${req.params.id}:`, error);
            res.status(500).send("–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞");
        }
    });
    
    app.get('/broadcasts', requireAuth, async (req, res) => {
        const tasks = await getAllBroadcastTasks();
        res.render('broadcasts', { title: '–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä–∞—Å—Å—ã–ª–∫–∞–º–∏', page: 'broadcasts', tasks });
    });
    
    app.get('/broadcast/new', requireAuth, (req, res) => { 
        res.render('broadcast-form', { title: '–ù–æ–≤–∞—è —Ä–∞—Å—Å—ã–ª–∫–∞', page: 'broadcasts', error: null, success: null }); 
    });

    app.get('/broadcast/edit/:id', requireAuth, async (req, res) => {
        const task = await getBroadcastTaskById(req.params.id);
        if (!task || task.status !== 'pending') {
            return res.redirect('/broadcasts');
        }
        res.render('broadcast-form', { title: '–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Ä–∞—Å—Å—ã–ª–∫—É', page: 'broadcasts', task, error: null, success: null });
    });

    app.post('/broadcast/delete', requireAuth, async (req, res) => {
        const { taskId } = req.body;
        await deleteBroadcastTask(taskId);
        res.redirect('/broadcasts');
    });

    app.post(['/broadcast/new', '/broadcast/edit/:id'], requireAuth, upload.single('audio'), async (req, res) => {
        const isEditing = !!req.params.id;
        const taskId = req.params.id;
        try {
            const { message, targetAudience, scheduledAt, disable_notification, action } = req.body;
            const audioFile = req.file;
            const renderOptions = { title: isEditing ? '–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Ä–∞—Å—Å—ã–ª–∫—É' : '–ù–æ–≤–∞—è —Ä–∞—Å—Å—ã–ª–∫–∞', page: 'broadcasts', success: null, error: null, task: isEditing ? await getBroadcastTaskById(taskId) : undefined };
            if (!message) {
                renderOptions.error = '–¢–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.';
                return res.render('broadcast-form', renderOptions);
            }
            const taskData = {
                message,
                audioPath: audioFile ? audioFile.path : (isEditing ? (await getBroadcastTaskById(taskId)).audio_path : null),
                targetAudience,
                disableNotification: !!disable_notification,
            };
            if (action === 'preview') {
                await runSingleBroadcast(taskData, [{ id: ADMIN_ID }]);
                if (audioFile) fs.unlinkSync(audioFile.path);
                renderOptions.success = '–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤–∞–º –≤ Telegram.';
                return res.render('broadcast-form', renderOptions);
            }
            const scheduleTime = scheduledAt ? new Date(scheduledAt) : new Date();
            if (isEditing) {
                await updateBroadcastTask(taskId, { ...taskData, scheduledAt: scheduleTime });
            } else {
                await createBroadcastTask({ ...taskData, scheduledAt: scheduleTime });
            }
            res.redirect('/broadcasts');
        } catch (e) {
            console.error('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è/—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∑–∞–¥–∞—á–∏:', e);
            res.render('broadcast-form', { title: '–û—à–∏–±–∫–∞', page: 'broadcasts', error: '–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∑–∞–¥–∞—á—É.', success: null, task: isEditing ? { ...req.body, id: taskId } : req.body });
        }
    });

    app.get('/expiring-users', requireAuth, async (req, res) => {
        try {
            const users = await getExpiringUsers();
            res.render('expiring-users', { title: '–ò—Å—Ç–µ–∫–∞—é—â–∏–µ –ø–æ–¥–ø–∏—Å–∫–∏', page: 'expiring-users', users });
        } catch(e) {
            res.status(500).send("–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞");
        }
    });

    app.post('/set-tariff', requireAuth, async (req, res) => {
        const { userId, limit, days } = req.body;
        try {
            await setPremium(userId, parseInt(limit), parseInt(days) || 30);
            let tariffName = '';
            const newLimit = parseInt(limit);
            if (newLimit <= 5) tariffName = 'Free';
            else if (newLimit <= 30) tariffName = 'Plus';
            else if (newLimit <= 100) tariffName = 'Pro';
            else tariffName = 'Unlimited';
            const message = `üéâ –í–∞—à —Ç–∞—Ä–∏—Ñ –±—ã–ª –æ–±–Ω–æ–≤–ª–µ–Ω –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º!\n\n–ù–æ–≤—ã–π —Ç–∞—Ä–∏—Ñ: *${tariffName}* (${newLimit} –∑–∞–≥—Ä—É–∑–æ–∫/–¥–µ–Ω—å).\n–°—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è: *${parseInt(days) || 30} –¥–Ω–µ–π*.`;
            await bot.telegram.sendMessage(userId, message, { parse_mode: 'Markdown' });
        } catch (error) {
            console.error(`[Admin] –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–º–µ–Ω–µ —Ç–∞—Ä–∏—Ñ–∞ –¥–ª—è ${userId}:`, error.message);
        }
        res.redirect(req.get('Referrer') || '/users');
    });

    app.post('/reset-bonus', requireAuth, async (req, res) => {
        const { userId } = req.body;
        if (userId) { await updateUserField(userId, 'subscribed_bonus_used', false); }
        res.redirect(req.get('Referrer') || '/users');
    });

    app.post('/reset-daily-limit', requireAuth, async (req, res) => {
        const { userId } = req.body;
        if (userId) {
            await updateUserField(userId, 'downloads_today', 0);
            await updateUserField(userId, 'tracks_today', '[]');
        }
        res.redirect(req.get('Referrer') || '/users');
    });
}

async function runSingleBroadcast(task, users, taskId = null) {
    console.log(`[Broadcast Worker] –ó–∞–ø—É—Å–∫ —Ä–∞—Å—Å—ã–ª–∫–∏ –¥–ª—è ${users.length} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.`);
    let successCount = 0, errorCount = 0;
    let safeMessage = task.message.replace(/\*(.*?)\*/g, '<b>$1</b>').replace(/_(.*?)_/g, '<i>$1</i>').replace(/(https?:\/\/[^\s]+)/g, '<a href="$1">$1</a>');
    for (const user of users) {
        try {
            const options = { parse_mode: 'HTML', disable_web_page_preview: true, disable_notification: task.disableNotification };
            if (task.audioPath || task.audio_path) {
                options.caption = safeMessage;
                await bot.telegram.sendAudio(user.id, { source: task.audioPath || task.audio_path }, options);
            } else {
                await bot.telegram.sendMessage(user.id, safeMessage, options);
            }
            successCount++;
        } catch (e) {
            errorCount++;
            if (e.response?.error_code === 403) await updateUserField(user.id, 'active', false);
        }
        await new Promise(resolve => setTimeout(resolve, 50));
    }
    const report = { successCount, errorCount, totalUsers: users.length };
    console.log(`[Broadcast Worker] –†–∞—Å—Å—ã–ª–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞.`, report);
    if (users.length > 1 || (users.length === 1 && users[0].id !== ADMIN_ID)) {
        try {
            const audienceName = task.targetAudience.replace('_', ' ');
            const reportMessage = `üì¢ –û—Ç—á–µ—Ç –ø–æ —Ä–∞—Å—Å—ã–ª–∫–µ ${taskId ? `(–∑–∞–¥–∞—á–∞ #${taskId})` : ''}\n\n‚úÖ –£—Å–ø–µ—à–Ω–æ: *${successCount}*\n‚ùå –û—à–∏–±–∫–∏: *${errorCount}*\nüë• –ê—É–¥–∏—Ç–æ—Ä–∏—è: *${audienceName}* (${users.length} —á–µ–ª.)`;
            await bot.telegram.sendMessage(ADMIN_ID, reportMessage, { parse_mode: 'Markdown' });
        } catch (e) { console.error('–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ç—á–µ—Ç –∞–¥–º–∏–Ω—É:', e.message); }
    }
    return report;
}

function startBroadcastWorker() {
    console.log('[Broadcast Worker] –ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –∑–∞–ø—É—â–µ–Ω.');
    cron.schedule('* * * * *', async () => {
        const task = await getPendingBroadcastTask();
        if (task) {
            try {
                console.log(`[Broadcast Worker] –ù–∞–π–¥–µ–Ω–∞ –∑–∞–¥–∞—á–∞ #${task.id}. –ù–∞—á–∏–Ω–∞—é –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ.`);
                let users = [];
                if (task.target_audience === 'all') users = await getAllUsers(true);
                else if (task.target_audience === 'free_users') users = await getActiveFreeUsers();
                else if (task.target_audience === 'premium_users') users = await getActivePremiumUsers();
                const report = await runSingleBroadcast(task, users, task.id);
                await completeBroadcastTask(task.id, report);
                if (task.audio_path) {
                    fs.unlink(task.audio_path, (err) => {
                        if (err) console.error("–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª —Ä–∞—Å—Å—ã–ª–∫–∏:", err);
                    });
                }
            } catch (error) {
                console.error(`[Broadcast Worker] –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –∑–∞–¥–∞—á–∏ #${task.id}:`, error);
                await failBroadcastTask(task.id, error.message);
            }
        }
    });
}

async function stopBot(signal) {
    console.log(`[App] –ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª ${signal}. –ù–∞—á–∏–Ω–∞—é –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ...`);
    try {
        if (bot.polling?.isRunning()) bot.stop(signal);
        const promises = [];
        if (redisService.client?.isOpen) promises.push(redisService.client.quit());
        promises.push(pool.end());
        await Promise.allSettled(promises);
        console.log('[App] –í—Å–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –∑–∞–∫—Ä—ã—Ç—ã. –í—ã—Ö–æ–¥.');
        process.exit(0);
    } catch (e) {
        console.error('üî¥ –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ —Ä–∞–±–æ—Ç—ã:', e);
        process.exit(1);
    }
}

process.once('SIGINT', () => stopBot('SIGINT'));
process.once('SIGTERM', () => stopBot('SIGTERM'));

startApp();